SCRIPT  /etc/xdg/nvim/sysinit.vim
Sourced 1 time
Total time:   0.000054
 Self time:   0.000039

count  total (s)   self (s)
                            " This line makes pacman-installed global Arch Linux vim packages work.
    1   0.000048   0.000033 source /usr/share/nvim/archlinux.vim

SCRIPT  /usr/share/nvim/archlinux.vim
Sourced 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000008 set runtimepath+=/usr/share/vim/vimfiles

SCRIPT  /home/tony/.config/nvim/init.vim
Sourced 1 time
Total time:   0.050687
 Self time:   0.001984

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  Init vim config  "
                            """"""""""""""""""""""
                            
                            " Source plugins
    1   0.039080   0.000091 source $HOME/.config/nvim/vim-plug/plugins.vim
                            
                            " Coc settings
    1   0.000946   0.000084 source $HOME/.config/nvim/plug-config/coc/coc-init.vim
                            
                            " General settings
    1   0.004732   0.000070 source $HOME/.config/nvim/general/settings.vim
    1   0.000225   0.000155 source $HOME/.config/nvim/general/commands.vim
                            
                            " key mappings
    1   0.000207   0.000086 source $HOME/.config/nvim/keys/mappings.vim
    1   0.000117   0.000070 source $HOME/.config/nvim/keys/snippets.vim
    1   0.001396   0.000070 source $HOME/.config/nvim/keys/which-key.vim
                            
                            " Specific plugin settings
    1   0.000170   0.000127 source $HOME/.config/nvim/plug-config/arduino.vim
    1   0.000165   0.000119 source $HOME/.config/nvim/plug-config/coderunner.vim
    1   0.000234   0.000134 source $HOME/.config/nvim/plug-config/codi.vim
    1   0.000193   0.000085 source $HOME/.config/nvim/plug-config/easymotion.vim
    1   0.000236   0.000069 source $HOME/.config/nvim/plug-config/fzf.vim
    1   0.000133   0.000066 source $HOME/.config/nvim/plug-config/quickscope.vim
    1   0.000112   0.000064 source $HOME/.config/nvim/plug-config/rainbow.vim
    1   0.000122   0.000065 source $HOME/.config/nvim/plug-config/rnvimr.vim
    1   0.000123   0.000077 source $HOME/.config/nvim/plug-config/signature.vim
    1   0.000154   0.000067 source $HOME/.config/nvim/plug-config/signify.vim
    1   0.000150   0.000075 source $HOME/.config/nvim/plug-config/sneak.vim
    1   0.000111   0.000059 source $HOME/.config/nvim/plug-config/start-screen.vim
    1   0.001629   0.000065 source $HOME/.config/nvim/plug-config/lualine.vim
                            
                            " Themes
    1   0.000134   0.000067 source $HOME/.config/nvim/plug-config/airline.vim
                            
    1              0.000001 lua << EOF
                            require('lualine').get_config()
                            require('lualine').setup()
                            EOF
                            
                            " Autorun
    1   0.000129   0.000070 source $HOME/.config/nvim/autorun/auto-source.vim
    1   0.000103   0.000065 source $HOME/.config/nvim/autorun/on-startup.vim

SCRIPT  /home/tony/.config/nvim/vim-plug/plugins.vim
Sourced 1 time
Total time:   0.038976
 Self time:   0.003773

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "    NVIM Plugins    "
                            """"""""""""""""""""""
                            
                            " auto-install vim-plug
    1              0.000068 if empty(glob('~/.config/nvim/autoload/plug.vim'))
                              silent !curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs
                                \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
                              "autocmd VimEnter * PlugInstall
                              "autocmd VimEnter * PlugInstall | source $MYVIMRC
    1              0.000001 endif
                            
    1   0.001872   0.000602 call plug#begin('~/.config/nvim/autoload/plugged')
                            
                                """"""""""""""""""""""
                                "       theme        "
                                """"""""""""""""""""""
                                " Dracula theme
    1              0.000087     Plug 'Mofiqul/dracula.nvim'
                            
                            
                                """"""""""""""""""""""
                                "    Programming     "
                                """"""""""""""""""""""
                                " Conqueror of completion (stable)
    1              0.000154     Plug 'neoclide/coc.nvim', {'branch': 'release'}
                            
                                " Coc snippets
    1              0.000071     Plug 'honza/vim-snippets'
                            
                                " code runner
    1              0.000067     Plug 'xianzhon/vim-code-runner'
                            
                                " Realtime coding
    1              0.000067     Plug 'metakirby5/codi.vim'
                            
                                " Arduino
    1              0.000064     Plug 'stevearc/vim-arduino'
                            
                                """"""""""""""""""""""
                                "    Syntax/typing   "
                                """"""""""""""""""""""
                                " Better Syntax Support
    1              0.000066     Plug 'sheerun/vim-polyglot'
                            
                                " Nerd commenter
    1              0.000070     Plug 'preservim/nerdcommenter'
    1              0.000065     Plug 'tpope/vim-commentary'
                            
                                " Auto pairs for '(' '[' '{'
    1              0.000064     Plug 'jiangmiao/auto-pairs'
                            
                                " Auto close tags (press >)
    1              0.000063     Plug 'alvan/vim-closetag'
                            
                                " Surround with ({""})
    1              0.000064     Plug 'tpope/vim-surround'
                            
                                " Prettier post install (yarn install | npm install) then load plugin only for editing supported files
    1              0.000162     Plug 'prettier/vim-prettier', { 'do': 'yarn install --frozen-lockfile --production' }
                            
                                """"""""""""""""""""""
                                "     Navigation     "
                                """"""""""""""""""""""
                                " More target operators
                                " Plug 'wellle/targets.vim'
    1              0.000147     Plug 'wellle/targets.vim', {'on' : []}
    1              0.000001     augroup LoadDuringHold_Targets
    1              0.000002         autocmd!
    1              0.000005         autocmd CursorHold,CursorHoldI * call plug#load('targets.vim') | autocmd! LoadDuringHold_Targets
    1              0.000001     augroup end
                            
                                " Visible marks
    1              0.000073     Plug 'kshenoy/vim-signature'
                            
                                " Quicker search (s)
    1              0.000066     Plug 'justinmk/vim-sneak'
                            
                                " Better t and f
    1              0.000066     Plug 'unblevable/quick-scope'
                            
                                " Focus (like qutebrowser)
    1              0.000067     Plug 'easymotion/vim-easymotion'
                            
                                """"""""""""""""""""""
                                "   File navigation  "
                                """"""""""""""""""""""
                                " File Explorer
                                " Plug 'scrooloose/NERDTree'
                            
                                " Ranger FM
    1              0.000142     Plug 'kevinhwang91/rnvimr', {'do': 'make sync'}
                            
                                " Sayonara (close buffers)
    1              0.000140     Plug 'mhinz/vim-sayonara', { 'on': 'Sayonara' }
                            
                                " Startify (project manager vim)
    1              0.000068     Plug 'mhinz/vim-startify'
                            
                                " Fuzzy finder
    1              0.000143     Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
    1              0.000070     Plug 'junegunn/fzf.vim'
    1              0.000065     Plug 'airblade/vim-rooter'
                            
                            
                                """"""""""""""""""""""
                                "   Git integration  "
                                """"""""""""""""""""""
                                 " Git integration
    1              0.000065     Plug 'mhinz/vim-signify'
                            
                                " Git commands from vim (:Git)
    1              0.000065     Plug 'tpope/vim-fugitive'
                            
                                " Hub commands (:GBrowse :GRemove)
    1              0.000067     Plug 'tpope/vim-rhubarb'
                            
                                " Browse commits (:GV! :GV? :GV)
    1              0.000063     Plug 'junegunn/gv.vim'
                            
                            
                                """"""""""""""""""""""
                                "   Aesthetics/QOL   "
                                """"""""""""""""""""""
                                " Status bar
                                 "Plug 'vim-airline/vim-airline'
                                 "Plug 'vim-airline/vim-airline-themes'
    1              0.000065     Plug 'nvim-lualine/lualine.nvim'
                                " If you want to have icons in your statusline choose one of these
    1              0.000067     Plug 'kyazdani42/nvim-web-devicons'
                            
                                " Colors
    1              0.000064     Plug 'norcalli/nvim-colorizer.lua'
    1              0.000066     Plug 'junegunn/rainbow_parentheses.vim'
                            
                                " zen mode
    1              0.000063     Plug 'junegunn/goyo.vim'
                            
                                " Which key
    1              0.000064     Plug 'liuchengxu/vim-which-key'
                            
                                " neovim sudo privileges (:Sudawrite :Sudaread)
    1              0.000066     Plug 'lambdalisue/suda.vim'
                            
                                " Show indent lines
    1              0.000062     Plug 'Yggdroot/indentLine'
                            
                                " Add repeat dot with some plugins
    1              0.000063     Plug 'tpope/vim-repeat'
                            
                                " Startup TB
    1              0.000064     Plug 'tweekmonster/startuptime.vim'
                            
                                """
    1   0.033938   0.000006     call plug#end()
                            

SCRIPT  /home/tony/.config/nvim/autoload/plug.vim
Sourced 1 time
Total time:   0.001081
 Self time:   0.001011

count  total (s)   self (s)
                            " vim-plug: Vim plugin manager
                            " ============================
                            "
                            " Download plug.vim and put it in ~/.vim/autoload
                            "
                            "   curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
                            "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
                            "
                            " Edit your .vimrc
                            "
                            "   call plug#begin('~/.vim/plugged')
                            "
                            "   " Make sure you use single quotes
                            "
                            "   " Shorthand notation; fetches https://github.com/junegunn/vim-easy-align
                            "   Plug 'junegunn/vim-easy-align'
                            "
                            "   " Any valid git URL is allowed
                            "   Plug 'https://github.com/junegunn/vim-github-dashboard.git'
                            "
                            "   " Multiple Plug commands can be written in a single line using | separators
                            "   Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'
                            "
                            "   " On-demand loading
                            "   Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }
                            "   Plug 'tpope/vim-fireplace', { 'for': 'clojure' }
                            "
                            "   " Using a non-default branch
                            "   Plug 'rdnetto/YCM-Generator', { 'branch': 'stable' }
                            "
                            "   " Using a tagged release; wildcard allowed (requires git 1.9.2 or above)
                            "   Plug 'fatih/vim-go', { 'tag': '*' }
                            "
                            "   " Plugin options
                            "   Plug 'nsf/gocode', { 'tag': 'v.20150303', 'rtp': 'vim' }
                            "
                            "   " Plugin outside ~/.vim/plugged with post-update hook
                            "   Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
                            "
                            "   " Unmanaged plugin (manually installed and updated)
                            "   Plug '~/my-prototype-plugin'
                            "
                            "   " Initialize plugin system
                            "   call plug#end()
                            "
                            " Then reload .vimrc and :PlugInstall to install plugins.
                            "
                            " Plug options:
                            "
                            "| Option                  | Description                                      |
                            "| ----------------------- | ------------------------------------------------ |
                            "| `branch`/`tag`/`commit` | Branch/tag/commit of the repository to use       |
                            "| `rtp`                   | Subdirectory that contains Vim plugin            |
                            "| `dir`                   | Custom directory for the plugin                  |
                            "| `as`                    | Use different name for the plugin                |
                            "| `do`                    | Post-update hook (string or funcref)             |
                            "| `on`                    | On-demand loading: Commands or `<Plug>`-mappings |
                            "| `for`                   | On-demand loading: File types                    |
                            "| `frozen`                | Do not update unless explicitly specified        |
                            "
                            " More information: https://github.com/junegunn/vim-plug
                            "
                            "
                            " Copyright (c) 2017 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000004 if exists('g:loaded_plug')
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_plug = 1
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000002 let s:plug_src = 'https://github.com/junegunn/vim-plug.git'
    1              0.000003 let s:plug_tab = get(s:, 'plug_tab', -1)
    1              0.000001 let s:plug_buf = get(s:, 'plug_buf', -1)
    1              0.000008 let s:mac_gui = has('gui_macvim') && has('gui_running')
    1              0.000002 let s:is_win = has('win32')
    1              0.000004 let s:nvim = has('nvim-0.2') || (has('nvim') && exists('*jobwait') && !s:is_win)
    1              0.000004 let s:vim8 = has('patch-8.0.0039') && exists('*job_start')
    1              0.000001 if s:is_win && &shellslash
                              set noshellslash
                              let s:me = resolve(expand('<sfile>:p'))
                              set shellslash
    1              0.000001 else
    1              0.000028   let s:me = resolve(expand('<sfile>:p'))
    1              0.000003 endif
    1              0.000003 let s:base_spec = { 'branch': '', 'frozen': 0 }
    1              0.000009 let s:TYPE = {
                            \   'string':  type(''),
                            \   'list':    type([]),
                            \   'dict':    type({}),
                            \   'funcref': type(function('call'))
                            \ }
    1              0.000002 let s:loaded = get(s:, 'loaded', {})
    1              0.000002 let s:triggers = get(s:, 'triggers', {})
                            
    1              0.000003 function! s:is_powershell(shell)
                              return a:shell =~# 'powershell\(\.exe\)\?$' || a:shell =~# 'pwsh\(\.exe\)\?$'
                            endfunction
                            
    1              0.000001 function! s:isabsolute(dir) abort
                              return a:dir =~# '^/' || (has('win32') && a:dir =~? '^\%(\\\|[A-Z]:\)')
                            endfunction
                            
    1              0.000001 function! s:git_dir(dir) abort
                              let gitdir = s:trim(a:dir) . '/.git'
                              if isdirectory(gitdir)
                                return gitdir
                              endif
                              if !filereadable(gitdir)
                                return ''
                              endif
                              let gitdir = matchstr(get(readfile(gitdir), 0, ''), '^gitdir: \zs.*')
                              if len(gitdir) && !s:isabsolute(gitdir)
                                let gitdir = a:dir . '/' . gitdir
                              endif
                              return isdirectory(gitdir) ? gitdir : ''
                            endfunction
                            
    1              0.000001 function! s:git_origin_url(dir) abort
                              let gitdir = s:git_dir(a:dir)
                              let config = gitdir . '/config'
                              if empty(gitdir) || !filereadable(config)
                                return ''
                              endif
                              return matchstr(join(readfile(config)), '\[remote "origin"\].\{-}url\s*=\s*\zs\S*\ze')
                            endfunction
                            
    1              0.000001 function! s:git_revision(dir) abort
                              let gitdir = s:git_dir(a:dir)
                              let head = gitdir . '/HEAD'
                              if empty(gitdir) || !filereadable(head)
                                return ''
                              endif
                            
                              let line = get(readfile(head), 0, '')
                              let ref = matchstr(line, '^ref: \zs.*')
                              if empty(ref)
                                return line
                              endif
                            
                              if filereadable(gitdir . '/' . ref)
                                return get(readfile(gitdir . '/' . ref), 0, '')
                              endif
                            
                              if filereadable(gitdir . '/packed-refs')
                                for line in readfile(gitdir . '/packed-refs')
                                  if line =~# ' ' . ref
                                    return matchstr(line, '^[0-9a-f]*')
                                  endif
                                endfor
                              endif
                            
                              return ''
                            endfunction
                            
    1              0.000001 function! s:git_local_branch(dir) abort
                              let gitdir = s:git_dir(a:dir)
                              let head = gitdir . '/HEAD'
                              if empty(gitdir) || !filereadable(head)
                                return ''
                              endif
                              let branch = matchstr(get(readfile(head), 0, ''), '^ref: refs/heads/\zs.*')
                              return len(branch) ? branch : 'HEAD'
                            endfunction
                            
    1              0.000001 function! s:git_origin_branch(spec)
                              if len(a:spec.branch)
                                return a:spec.branch
                              endif
                            
                              " The file may not be present if this is a local repository
                              let gitdir = s:git_dir(a:spec.dir)
                              let origin_head = gitdir.'/refs/remotes/origin/HEAD'
                              if len(gitdir) && filereadable(origin_head)
                                return matchstr(get(readfile(origin_head), 0, ''),
                                              \ '^ref: refs/remotes/origin/\zs.*')
                              endif
                            
                              " The command may not return the name of a branch in detached HEAD state
                              let result = s:lines(s:system('git symbolic-ref --short HEAD', a:spec.dir))
                              return v:shell_error ? '' : result[-1]
                            endfunction
                            
    1              0.000001 if s:is_win
                              function! s:plug_call(fn, ...)
                                let shellslash = &shellslash
                                try
                                  set noshellslash
                                  return call(a:fn, a:000)
                                finally
                                  let &shellslash = shellslash
                                endtry
                              endfunction
    1              0.000001 else
    1              0.000001   function! s:plug_call(fn, ...)
                                return call(a:fn, a:000)
                              endfunction
    1              0.000000 endif
                            
    1              0.000001 function! s:plug_getcwd()
                              return s:plug_call('getcwd')
                            endfunction
                            
    1              0.000001 function! s:plug_fnamemodify(fname, mods)
                              return s:plug_call('fnamemodify', a:fname, a:mods)
                            endfunction
                            
    1              0.000001 function! s:plug_expand(fmt)
                              return s:plug_call('expand', a:fmt, 1)
                            endfunction
                            
    1              0.000001 function! s:plug_tempname()
                              return s:plug_call('tempname')
                            endfunction
                            
    1              0.000001 function! plug#begin(...)
                              if a:0 > 0
                                let s:plug_home_org = a:1
                                let home = s:path(s:plug_fnamemodify(s:plug_expand(a:1), ':p'))
                              elseif exists('g:plug_home')
                                let home = s:path(g:plug_home)
                              elseif has('nvim')
                                let home = stdpath('data') . '/plugged'
                              elseif !empty(&rtp)
                                let home = s:path(split(&rtp, ',')[0]) . '/plugged'
                              else
                                return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
                              endif
                              if s:plug_fnamemodify(home, ':t') ==# 'plugin' && s:plug_fnamemodify(home, ':h') ==# s:first_rtp
                                return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')
                              endif
                            
                              let g:plug_home = home
                              let g:plugs = {}
                              let g:plugs_order = []
                              let s:triggers = {}
                            
                              call s:define_commands()
                              return 1
                            endfunction
                            
    1              0.000001 function! s:define_commands()
                              command! -nargs=+ -bar Plug call plug#(<args>)
                              if !executable('git')
                                return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
                              endif
                              if has('win32')
                              \ && &shellslash
                              \ && (&shell =~# 'cmd\(\.exe\)\?$' || s:is_powershell(&shell))
                                return s:err('vim-plug does not support shell, ' . &shell . ', when shellslash is set.')
                              endif
                              if !has('nvim')
                                \ && (has('win32') || has('win32unix'))
                                \ && !has('multi_byte')
                                return s:err('Vim needs +multi_byte feature on Windows to run shell commands. Enable +iconv for best results.')
                              endif
                              command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
                              command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
                              command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
                              command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
                              command! -nargs=0 -bar PlugStatus  call s:status()
                              command! -nargs=0 -bar PlugDiff    call s:diff()
                              command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)
                            endfunction
                            
    1              0.000001 function! s:to_a(v)
                              return type(a:v) == s:TYPE.list ? a:v : [a:v]
                            endfunction
                            
    1              0.000001 function! s:to_s(v)
                              return type(a:v) == s:TYPE.string ? a:v : join(a:v, "\n") . "\n"
                            endfunction
                            
    1              0.000001 function! s:glob(from, pattern)
                              return s:lines(globpath(a:from, a:pattern))
                            endfunction
                            
    1              0.000001 function! s:source(from, ...)
                              let found = 0
                              for pattern in a:000
                                for vim in s:glob(a:from, pattern)
                                  execute 'source' s:esc(vim)
                                  let found = 1
                                endfor
                              endfor
                              return found
                            endfunction
                            
    1              0.000001 function! s:assoc(dict, key, val)
                              let a:dict[a:key] = add(get(a:dict, a:key, []), a:val)
                            endfunction
                            
    1              0.000001 function! s:ask(message, ...)
                              call inputsave()
                              echohl WarningMsg
                              let answer = input(a:message.(a:0 ? ' (y/N/a) ' : ' (y/N) '))
                              echohl None
                              call inputrestore()
                              echo "\r"
                              return (a:0 && answer =~? '^a') ? 2 : (answer =~? '^y') ? 1 : 0
                            endfunction
                            
    1              0.000001 function! s:ask_no_interrupt(...)
                              try
                                return call('s:ask', a:000)
                              catch
                                return 0
                              endtry
                            endfunction
                            
    1              0.000001 function! s:lazy(plug, opt)
                              return has_key(a:plug, a:opt) &&
                                    \ (empty(s:to_a(a:plug[a:opt]))         ||
                                    \  !isdirectory(a:plug.dir)             ||
                                    \  len(s:glob(s:rtp(a:plug), 'plugin')) ||
                                    \  len(s:glob(s:rtp(a:plug), 'after/plugin')))
                            endfunction
                            
    1              0.000001 function! plug#end()
                              if !exists('g:plugs')
                                return s:err('plug#end() called without calling plug#begin() first')
                              endif
                            
                              if exists('#PlugLOD')
                                augroup PlugLOD
                                  autocmd!
                                augroup END
                                augroup! PlugLOD
                              endif
                              let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
                            
                              if exists('g:did_load_filetypes')
                                filetype off
                              endif
                              for name in g:plugs_order
                                if !has_key(g:plugs, name)
                                  continue
                                endif
                                let plug = g:plugs[name]
                                if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
                                  let s:loaded[name] = 1
                                  continue
                                endif
                            
                                if has_key(plug, 'on')
                                  let s:triggers[name] = { 'map': [], 'cmd': [] }
                                  for cmd in s:to_a(plug.on)
                                    if cmd =~? '^<Plug>.\+'
                                      if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
                                        call s:assoc(lod.map, cmd, name)
                                      endif
                                      call add(s:triggers[name].map, cmd)
                                    elseif cmd =~# '^[A-Z]'
                                      let cmd = substitute(cmd, '!*$', '', '')
                                      if exists(':'.cmd) != 2
                                        call s:assoc(lod.cmd, cmd, name)
                                      endif
                                      call add(s:triggers[name].cmd, cmd)
                                    else
                                      call s:err('Invalid `on` option: '.cmd.
                                      \ '. Should start with an uppercase letter or `<Plug>`.')
                                    endif
                                  endfor
                                endif
                            
                                if has_key(plug, 'for')
                                  let types = s:to_a(plug.for)
                                  if !empty(types)
                                    augroup filetypedetect
                                    call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
                                    augroup END
                                  endif
                                  for type in types
                                    call s:assoc(lod.ft, type, name)
                                  endfor
                                endif
                              endfor
                            
                              for [cmd, names] in items(lod.cmd)
                                execute printf(
                                \ 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)',
                                \ cmd, string(cmd), string(names))
                              endfor
                            
                              for [map, names] in items(lod.map)
                                for [mode, map_prefix, key_prefix] in
                                      \ [['i', '<C-\><C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
                                  execute printf(
                                  \ '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>',
                                  \ mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)
                                endfor
                              endfor
                            
                              for [ft, names] in items(lod.ft)
                                augroup PlugLOD
                                  execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)',
                                        \ ft, string(ft), string(names))
                                augroup END
                              endfor
                            
                              call s:reorg_rtp()
                              filetype plugin indent on
                              if has('vim_starting')
                                if has('syntax') && !exists('g:syntax_on')
                                  syntax enable
                                end
                              else
                                call s:reload_plugins()
                              endif
                            endfunction
                            
    1              0.000001 function! s:loaded_names()
                              return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')
                            endfunction
                            
    1              0.000001 function! s:load_plugin(spec)
                              call s:source(s:rtp(a:spec), 'plugin/**/*.vim', 'after/plugin/**/*.vim')
                            endfunction
                            
    1              0.000001 function! s:reload_plugins()
                              for name in s:loaded_names()
                                call s:load_plugin(g:plugs[name])
                              endfor
                            endfunction
                            
    1              0.000001 function! s:trim(str)
                              return substitute(a:str, '[\/]\+$', '', '')
                            endfunction
                            
    1              0.000001 function! s:version_requirement(val, min)
                              for idx in range(0, len(a:min) - 1)
                                let v = get(a:val, idx, 0)
                                if     v < a:min[idx] | return 0
                                elseif v > a:min[idx] | return 1
                                endif
                              endfor
                              return 1
                            endfunction
                            
    1              0.000001 function! s:git_version_requirement(...)
                              if !exists('s:git_version')
                                let s:git_version = map(split(split(s:system(['git', '--version']))[2], '\.'), 'str2nr(v:val)')
                              endif
                              return s:version_requirement(s:git_version, a:000)
                            endfunction
                            
    1              0.000001 function! s:progress_opt(base)
                              return a:base && !s:is_win &&
                                    \ s:git_version_requirement(1, 7, 1) ? '--progress' : ''
                            endfunction
                            
    1              0.000001 function! s:rtp(spec)
                              return s:path(a:spec.dir . get(a:spec, 'rtp', ''))
                            endfunction
                            
    1              0.000001 if s:is_win
                              function! s:path(path)
                                return s:trim(substitute(a:path, '/', '\', 'g'))
                              endfunction
                            
                              function! s:dirpath(path)
                                return s:path(a:path) . '\'
                              endfunction
                            
                              function! s:is_local_plug(repo)
                                return a:repo =~? '^[a-z]:\|^[%~]'
                              endfunction
                            
                              " Copied from fzf
                              function! s:wrap_cmds(cmds)
                                let cmds = [
                                  \ '@echo off',
                                  \ 'setlocal enabledelayedexpansion']
                                \ + (type(a:cmds) == type([]) ? a:cmds : [a:cmds])
                                \ + ['endlocal']
                                if has('iconv')
                                  if !exists('s:codepage')
                                    let s:codepage = libcallnr('kernel32.dll', 'GetACP', 0)
                                  endif
                                  return map(cmds, printf('iconv(v:val."\r", "%s", "cp%d")', &encoding, s:codepage))
                                endif
                                return map(cmds, 'v:val."\r"')
                              endfunction
                            
                              function! s:batchfile(cmd)
                                let batchfile = s:plug_tempname().'.bat'
                                call writefile(s:wrap_cmds(a:cmd), batchfile)
                                let cmd = plug#shellescape(batchfile, {'shell': &shell, 'script': 0})
                                if s:is_powershell(&shell)
                                  let cmd = '& ' . cmd
                                endif
                                return [batchfile, cmd]
                              endfunction
    1              0.000000 else
    1              0.000001   function! s:path(path)
                                return s:trim(a:path)
                              endfunction
                            
    1              0.000001   function! s:dirpath(path)
                                return substitute(a:path, '[/\\]*$', '/', '')
                              endfunction
                            
    1              0.000001   function! s:is_local_plug(repo)
                                return a:repo[0] =~ '[/$~]'
                              endfunction
    1              0.000000 endif
                            
    1              0.000001 function! s:err(msg)
                              echohl ErrorMsg
                              echom '[vim-plug] '.a:msg
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:warn(cmd, msg)
                              echohl WarningMsg
                              execute a:cmd 'a:msg'
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:esc(path)
                              return escape(a:path, ' ')
                            endfunction
                            
    1              0.000001 function! s:escrtp(path)
                              return escape(a:path, ' ,')
                            endfunction
                            
    1              0.000001 function! s:remove_rtp()
                              for name in s:loaded_names()
                                let rtp = s:rtp(g:plugs[name])
                                execute 'set rtp-='.s:escrtp(rtp)
                                let after = globpath(rtp, 'after')
                                if isdirectory(after)
                                  execute 'set rtp-='.s:escrtp(after)
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! s:reorg_rtp()
                              if !empty(s:first_rtp)
                                execute 'set rtp-='.s:first_rtp
                                execute 'set rtp-='.s:last_rtp
                              endif
                            
                              " &rtp is modified from outside
                              if exists('s:prtp') && s:prtp !=# &rtp
                                call s:remove_rtp()
                                unlet! s:middle
                              endif
                            
                              let s:middle = get(s:, 'middle', &rtp)
                              let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
                              let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
                              let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',')
                                             \ . ','.s:middle.','
                                             \ . join(map(afters, 'escape(v:val, ",")'), ',')
                              let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
                              let s:prtp   = &rtp
                            
                              if !empty(s:first_rtp)
                                execute 'set rtp^='.s:first_rtp
                                execute 'set rtp+='.s:last_rtp
                              endif
                            endfunction
                            
    1              0.000001 function! s:doautocmd(...)
                              if exists('#'.join(a:000, '#'))
                                execute 'doautocmd' ((v:version > 703 || has('patch442')) ? '<nomodeline>' : '') join(a:000)
                              endif
                            endfunction
                            
    1              0.000001 function! s:dobufread(names)
                              for name in a:names
                                let path = s:rtp(g:plugs[name])
                                for dir in ['ftdetect', 'ftplugin', 'after/ftdetect', 'after/ftplugin']
                                  if len(finddir(dir, path))
                                    if exists('#BufRead')
                                      doautocmd BufRead
                                    endif
                                    return
                                  endif
                                endfor
                              endfor
                            endfunction
                            
    1              0.000001 function! plug#load(...)
                              if a:0 == 0
                                return s:err('Argument missing: plugin name(s) required')
                              endif
                              if !exists('g:plugs')
                                return s:err('plug#begin was not called')
                              endif
                              let names = a:0 == 1 && type(a:1) == s:TYPE.list ? a:1 : a:000
                              let unknowns = filter(copy(names), '!has_key(g:plugs, v:val)')
                              if !empty(unknowns)
                                let s = len(unknowns) > 1 ? 's' : ''
                                return s:err(printf('Unknown plugin%s: %s', s, join(unknowns, ', ')))
                              end
                              let unloaded = filter(copy(names), '!get(s:loaded, v:val, 0)')
                              if !empty(unloaded)
                                for name in unloaded
                                  call s:lod([name], ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                                endfor
                                call s:dobufread(unloaded)
                                return 1
                              end
                              return 0
                            endfunction
                            
    1              0.000001 function! s:remove_triggers(name)
                              if !has_key(s:triggers, a:name)
                                return
                              endif
                              for cmd in s:triggers[a:name].cmd
                                execute 'silent! delc' cmd
                              endfor
                              for map in s:triggers[a:name].map
                                execute 'silent! unmap' map
                                execute 'silent! iunmap' map
                              endfor
                              call remove(s:triggers, a:name)
                            endfunction
                            
    1              0.000001 function! s:lod(names, types, ...)
                              for name in a:names
                                call s:remove_triggers(name)
                                let s:loaded[name] = 1
                              endfor
                              call s:reorg_rtp()
                            
                              for name in a:names
                                let rtp = s:rtp(g:plugs[name])
                                for dir in a:types
                                  call s:source(rtp, dir.'/**/*.vim')
                                endfor
                                if a:0
                                  if !s:source(rtp, a:1) && !empty(s:glob(rtp, a:2))
                                    execute 'runtime' a:1
                                  endif
                                  call s:source(rtp, a:2)
                                endif
                                call s:doautocmd('User', name)
                              endfor
                            endfunction
                            
    1              0.000001 function! s:lod_ft(pat, names)
                              let syn = 'syntax/'.a:pat.'.vim'
                              call s:lod(a:names, ['plugin', 'after/plugin'], syn, 'after/'.syn)
                              execute 'autocmd! PlugLOD FileType' a:pat
                              call s:doautocmd('filetypeplugin', 'FileType')
                              call s:doautocmd('filetypeindent', 'FileType')
                            endfunction
                            
    1              0.000002 function! s:lod_cmd(cmd, bang, l1, l2, args, names)
                              call s:lod(a:names, ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                              call s:dobufread(a:names)
                              execute printf('%s%s%s %s', (a:l1 == a:l2 ? '' : (a:l1.','.a:l2)), a:cmd, a:bang, a:args)
                            endfunction
                            
    1              0.000001 function! s:lod_map(map, names, with_prefix, prefix)
                              call s:lod(a:names, ['ftdetect', 'after/ftdetect', 'plugin', 'after/plugin'])
                              call s:dobufread(a:names)
                              let extra = ''
                              while 1
                                let c = getchar(0)
                                if c == 0
                                  break
                                endif
                                let extra .= nr2char(c)
                              endwhile
                            
                              if a:with_prefix
                                let prefix = v:count ? v:count : ''
                                let prefix .= '"'.v:register.a:prefix
                                if mode(1) == 'no'
                                  if v:operator == 'c'
                                    let prefix = "\<esc>" . prefix
                                  endif
                                  let prefix .= v:operator
                                endif
                                call feedkeys(prefix, 'n')
                              endif
                              call feedkeys(substitute(a:map, '^<Plug>', "\<Plug>", '') . extra)
                            endfunction
                            
    1              0.000001 function! plug#(repo, ...)
                              if a:0 > 1
                                return s:err('Invalid number of arguments (1..2)')
                              endif
                            
                              try
                                let repo = s:trim(a:repo)
                                let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
                                let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
                                let spec = extend(s:infer_properties(name, repo), opts)
                                if !has_key(g:plugs, name)
                                  call add(g:plugs_order, name)
                                endif
                                let g:plugs[name] = spec
                                let s:loaded[name] = get(s:loaded, name, 0)
                              catch
                                return s:err(repo . ' ' . v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:parse_options(arg)
                              let opts = copy(s:base_spec)
                              let type = type(a:arg)
                              let opt_errfmt = 'Invalid argument for "%s" option of :Plug (expected: %s)'
                              if type == s:TYPE.string
                                if empty(a:arg)
                                  throw printf(opt_errfmt, 'tag', 'string')
                                endif
                                let opts.tag = a:arg
                              elseif type == s:TYPE.dict
                                for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
                                  if has_key(a:arg, opt)
                                  \ && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
                                    throw printf(opt_errfmt, opt, 'string')
                                  endif
                                endfor
                                for opt in ['on', 'for']
                                  if has_key(a:arg, opt)
                                  \ && type(a:arg[opt]) != s:TYPE.list
                                  \ && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
                                    throw printf(opt_errfmt, opt, 'string or list')
                                  endif
                                endfor
                                if has_key(a:arg, 'do')
                                  \ && type(a:arg.do) != s:TYPE.funcref
                                  \ && (type(a:arg.do) != s:TYPE.string || empty(a:arg.do))
                                    throw printf(opt_errfmt, 'do', 'string or funcref')
                                endif
                                call extend(opts, a:arg)
                                if has_key(opts, 'dir')
                                  let opts.dir = s:dirpath(s:plug_expand(opts.dir))
                                endif
                              else
                                throw 'Invalid argument type (expected: string or dictionary)'
                              endif
                              return opts
                            endfunction
                            
    1              0.000001 function! s:infer_properties(name, repo)
                              let repo = a:repo
                              if s:is_local_plug(repo)
                                return { 'dir': s:dirpath(s:plug_expand(repo)) }
                              else
                                if repo =~ ':'
                                  let uri = repo
                                else
                                  if repo !~ '/'
                                    throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
                                  endif
                                  let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
                                  let uri = printf(fmt, repo)
                                endif
                                return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
                              endif
                            endfunction
                            
    1              0.000001 function! s:install(force, names)
                              call s:update_impl(0, a:force, a:names)
                            endfunction
                            
    1              0.000001 function! s:update(force, names)
                              call s:update_impl(1, a:force, a:names)
                            endfunction
                            
    1              0.000001 function! plug#helptags()
                              if !exists('g:plugs')
                                return s:err('plug#begin was not called')
                              endif
                              for spec in values(g:plugs)
                                let docd = join([s:rtp(spec), 'doc'], '/')
                                if isdirectory(docd)
                                  silent! execute 'helptags' s:esc(docd)
                                endif
                              endfor
                              return 1
                            endfunction
                            
    1              0.000001 function! s:syntax()
                              syntax clear
                              syntax region plug1 start=/\%1l/ end=/\%2l/ contains=plugNumber
                              syntax region plug2 start=/\%2l/ end=/\%3l/ contains=plugBracket,plugX
                              syn match plugNumber /[0-9]\+[0-9.]*/ contained
                              syn match plugBracket /[[\]]/ contained
                              syn match plugX /x/ contained
                              syn match plugDash /^-\{1}\ /
                              syn match plugPlus /^+/
                              syn match plugStar /^*/
                              syn match plugMessage /\(^- \)\@<=.*/
                              syn match plugName /\(^- \)\@<=[^ ]*:/
                              syn match plugSha /\%(: \)\@<=[0-9a-f]\{4,}$/
                              syn match plugTag /(tag: [^)]\+)/
                              syn match plugInstall /\(^+ \)\@<=[^:]*/
                              syn match plugUpdate /\(^* \)\@<=[^:]*/
                              syn match plugCommit /^  \X*[0-9a-f]\{7,9} .*/ contains=plugRelDate,plugEdge,plugTag
                              syn match plugEdge /^  \X\+$/
                              syn match plugEdge /^  \X*/ contained nextgroup=plugSha
                              syn match plugSha /[0-9a-f]\{7,9}/ contained
                              syn match plugRelDate /([^)]*)$/ contained
                              syn match plugNotLoaded /(not loaded)$/
                              syn match plugError /^x.*/
                              syn region plugDeleted start=/^\~ .*/ end=/^\ze\S/
                              syn match plugH2 /^.*:\n-\+$/
                              syn match plugH2 /^-\{2,}/
                              syn keyword Function PlugInstall PlugStatus PlugUpdate PlugClean
                              hi def link plug1       Title
                              hi def link plug2       Repeat
                              hi def link plugH2      Type
                              hi def link plugX       Exception
                              hi def link plugBracket Structure
                              hi def link plugNumber  Number
                            
                              hi def link plugDash    Special
                              hi def link plugPlus    Constant
                              hi def link plugStar    Boolean
                            
                              hi def link plugMessage Function
                              hi def link plugName    Label
                              hi def link plugInstall Function
                              hi def link plugUpdate  Type
                            
                              hi def link plugError   Error
                              hi def link plugDeleted Ignore
                              hi def link plugRelDate Comment
                              hi def link plugEdge    PreProc
                              hi def link plugSha     Identifier
                              hi def link plugTag     Constant
                            
                              hi def link plugNotLoaded Comment
                            endfunction
                            
    1              0.000001 function! s:lpad(str, len)
                              return a:str . repeat(' ', a:len - len(a:str))
                            endfunction
                            
    1              0.000001 function! s:lines(msg)
                              return split(a:msg, "[\r\n]")
                            endfunction
                            
    1              0.000001 function! s:lastline(msg)
                              return get(s:lines(a:msg), -1, '')
                            endfunction
                            
    1              0.000001 function! s:new_window()
                              execute get(g:, 'plug_window', 'vertical topleft new')
                            endfunction
                            
    1              0.000001 function! s:plug_window_exists()
                              let buflist = tabpagebuflist(s:plug_tab)
                              return !empty(buflist) && index(buflist, s:plug_buf) >= 0
                            endfunction
                            
    1              0.000001 function! s:switch_in()
                              if !s:plug_window_exists()
                                return 0
                              endif
                            
                              if winbufnr(0) != s:plug_buf
                                let s:pos = [tabpagenr(), winnr(), winsaveview()]
                                execute 'normal!' s:plug_tab.'gt'
                                let winnr = bufwinnr(s:plug_buf)
                                execute winnr.'wincmd w'
                                call add(s:pos, winsaveview())
                              else
                                let s:pos = [winsaveview()]
                              endif
                            
                              setlocal modifiable
                              return 1
                            endfunction
                            
    1              0.000001 function! s:switch_out(...)
                              call winrestview(s:pos[-1])
                              setlocal nomodifiable
                              if a:0 > 0
                                execute a:1
                              endif
                            
                              if len(s:pos) > 1
                                execute 'normal!' s:pos[0].'gt'
                                execute s:pos[1] 'wincmd w'
                                call winrestview(s:pos[2])
                              endif
                            endfunction
                            
    1              0.000001 function! s:finish_bindings()
                              nnoremap <silent> <buffer> R  :call <SID>retry()<cr>
                              nnoremap <silent> <buffer> D  :PlugDiff<cr>
                              nnoremap <silent> <buffer> S  :PlugStatus<cr>
                              nnoremap <silent> <buffer> U  :call <SID>status_update()<cr>
                              xnoremap <silent> <buffer> U  :call <SID>status_update()<cr>
                              nnoremap <silent> <buffer> ]] :silent! call <SID>section('')<cr>
                              nnoremap <silent> <buffer> [[ :silent! call <SID>section('b')<cr>
                            endfunction
                            
    1              0.000001 function! s:prepare(...)
                              if empty(s:plug_getcwd())
                                throw 'Invalid current working directory. Cannot proceed.'
                              endif
                            
                              for evar in ['$GIT_DIR', '$GIT_WORK_TREE']
                                if exists(evar)
                                  throw evar.' detected. Cannot proceed.'
                                endif
                              endfor
                            
                              call s:job_abort()
                              if s:switch_in()
                                if b:plug_preview == 1
                                  pc
                                endif
                                enew
                              else
                                call s:new_window()
                              endif
                            
                              nnoremap <silent> <buffer> q :call <SID>close_pane()<cr>
                              if a:0 == 0
                                call s:finish_bindings()
                              endif
                              let b:plug_preview = -1
                              let s:plug_tab = tabpagenr()
                              let s:plug_buf = winbufnr(0)
                              call s:assign_name()
                            
                              for k in ['<cr>', 'L', 'o', 'X', 'd', 'dd']
                                execute 'silent! unmap <buffer>' k
                              endfor
                              setlocal buftype=nofile bufhidden=wipe nobuflisted nolist noswapfile nowrap cursorline modifiable nospell
                              if exists('+colorcolumn')
                                setlocal colorcolumn=
                              endif
                              setf vim-plug
                              if exists('g:syntax_on')
                                call s:syntax()
                              endif
                            endfunction
                            
    1              0.000001 function! s:close_pane()
                              if b:plug_preview == 1
                                pc
                                let b:plug_preview = -1
                              else
                                bd
                              endif
                            endfunction
                            
    1              0.000001 function! s:assign_name()
                              " Assign buffer name
                              let prefix = '[Plugins]'
                              let name   = prefix
                              let idx    = 2
                              while bufexists(name)
                                let name = printf('%s (%s)', prefix, idx)
                                let idx = idx + 1
                              endwhile
                              silent! execute 'f' fnameescape(name)
                            endfunction
                            
    1              0.000001 function! s:chsh(swap)
                              let prev = [&shell, &shellcmdflag, &shellredir]
                              if !s:is_win
                                set shell=sh
                              endif
                              if a:swap
                                if s:is_powershell(&shell)
                                  let &shellredir = '2>&1 | Out-File -Encoding UTF8 %s'
                                elseif &shell =~# 'sh' || &shell =~# 'cmd\(\.exe\)\?$'
                                  set shellredir=>%s\ 2>&1
                                endif
                              endif
                              return prev
                            endfunction
                            
    1              0.000001 function! s:bang(cmd, ...)
                              let batchfile = ''
                              try
                                let [sh, shellcmdflag, shrd] = s:chsh(a:0)
                                " FIXME: Escaping is incomplete. We could use shellescape with eval,
                                "        but it won't work on Windows.
                                let cmd = a:0 ? s:with_cd(a:cmd, a:1) : a:cmd
                                if s:is_win
                                  let [batchfile, cmd] = s:batchfile(cmd)
                                endif
                                let g:_plug_bang = (s:is_win && has('gui_running') ? 'silent ' : '').'!'.escape(cmd, '#!%')
                                execute "normal! :execute g:_plug_bang\<cr>\<cr>"
                              finally
                                unlet g:_plug_bang
                                let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                                if s:is_win && filereadable(batchfile)
                                  call delete(batchfile)
                                endif
                              endtry
                              return v:shell_error ? 'Exit status: ' . v:shell_error : ''
                            endfunction
                            
    1              0.000001 function! s:regress_bar()
                              let bar = substitute(getline(2)[1:-2], '.*\zs=', 'x', '')
                              call s:progress_bar(2, bar, len(bar))
                            endfunction
                            
    1              0.000001 function! s:is_updated(dir)
                              return !empty(s:system_chomp(['git', 'log', '--pretty=format:%h', 'HEAD...HEAD@{1}'], a:dir))
                            endfunction
                            
    1              0.000001 function! s:do(pull, force, todo)
                              for [name, spec] in items(a:todo)
                                if !isdirectory(spec.dir)
                                  continue
                                endif
                                let installed = has_key(s:update.new, name)
                                let updated = installed ? 0 :
                                  \ (a:pull && index(s:update.errors, name) < 0 && s:is_updated(spec.dir))
                                if a:force || installed || updated
                                  execute 'cd' s:esc(spec.dir)
                                  call append(3, '- Post-update hook for '. name .' ... ')
                                  let error = ''
                                  let type = type(spec.do)
                                  if type == s:TYPE.string
                                    if spec.do[0] == ':'
                                      if !get(s:loaded, name, 0)
                                        let s:loaded[name] = 1
                                        call s:reorg_rtp()
                                      endif
                                      call s:load_plugin(spec)
                                      try
                                        execute spec.do[1:]
                                      catch
                                        let error = v:exception
                                      endtry
                                      if !s:plug_window_exists()
                                        cd -
                                        throw 'Warning: vim-plug was terminated by the post-update hook of '.name
                                      endif
                                    else
                                      let error = s:bang(spec.do)
                                    endif
                                  elseif type == s:TYPE.funcref
                                    try
                                      call s:load_plugin(spec)
                                      let status = installed ? 'installed' : (updated ? 'updated' : 'unchanged')
                                      call spec.do({ 'name': name, 'status': status, 'force': a:force })
                                    catch
                                      let error = v:exception
                                    endtry
                                  else
                                    let error = 'Invalid hook type'
                                  endif
                                  call s:switch_in()
                                  call setline(4, empty(error) ? (getline(4) . 'OK')
                                                             \ : ('x' . getline(4)[1:] . error))
                                  if !empty(error)
                                    call add(s:update.errors, name)
                                    call s:regress_bar()
                                  endif
                                  cd -
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! s:hash_match(a, b)
                              return stridx(a:a, a:b) == 0 || stridx(a:b, a:a) == 0
                            endfunction
                            
    1              0.000001 function! s:checkout(spec)
                              let sha = a:spec.commit
                              let output = s:git_revision(a:spec.dir)
                              if !empty(output) && !s:hash_match(sha, s:lines(output)[0])
                                let credential_helper = s:git_version_requirement(2) ? '-c credential.helper= ' : ''
                                let output = s:system(
                                      \ 'git '.credential_helper.'fetch --depth 999999 && git checkout '.plug#shellescape(sha).' --', a:spec.dir)
                              endif
                              return output
                            endfunction
                            
    1              0.000001 function! s:finish(pull)
                              let new_frozen = len(filter(keys(s:update.new), 'g:plugs[v:val].frozen'))
                              if new_frozen
                                let s = new_frozen > 1 ? 's' : ''
                                call append(3, printf('- Installed %d frozen plugin%s', new_frozen, s))
                              endif
                              call append(3, '- Finishing ... ') | 4
                              redraw
                              call plug#helptags()
                              call plug#end()
                              call setline(4, getline(4) . 'Done!')
                              redraw
                              let msgs = []
                              if !empty(s:update.errors)
                                call add(msgs, "Press 'R' to retry.")
                              endif
                              if a:pull && len(s:update.new) < len(filter(getline(5, '$'),
                                            \ "v:val =~ '^- ' && v:val !~# 'Already up.to.date'"))
                                call add(msgs, "Press 'D' to see the updated changes.")
                              endif
                              echo join(msgs, ' ')
                              call s:finish_bindings()
                            endfunction
                            
    1              0.000001 function! s:retry()
                              if empty(s:update.errors)
                                return
                              endif
                              echo
                              call s:update_impl(s:update.pull, s:update.force,
                                    \ extend(copy(s:update.errors), [s:update.threads]))
                            endfunction
                            
    1              0.000001 function! s:is_managed(name)
                              return has_key(g:plugs[a:name], 'uri')
                            endfunction
                            
    1              0.000002 function! s:names(...)
                              return sort(filter(keys(g:plugs), 'stridx(v:val, a:1) == 0 && s:is_managed(v:val)'))
                            endfunction
                            
    1              0.000001 function! s:check_ruby()
                              silent! ruby require 'thread'; VIM::command("let g:plug_ruby = '#{RUBY_VERSION}'")
                              if !exists('g:plug_ruby')
                                redraw!
                                return s:warn('echom', 'Warning: Ruby interface is broken')
                              endif
                              let ruby_version = split(g:plug_ruby, '\.')
                              unlet g:plug_ruby
                              return s:version_requirement(ruby_version, [1, 8, 7])
                            endfunction
                            
    1              0.000001 function! s:update_impl(pull, force, args) abort
                              let sync = index(a:args, '--sync') >= 0 || has('vim_starting')
                              let args = filter(copy(a:args), 'v:val != "--sync"')
                              let threads = (len(args) > 0 && args[-1] =~ '^[1-9][0-9]*$') ?
                                              \ remove(args, -1) : get(g:, 'plug_threads', 16)
                            
                              let managed = filter(copy(g:plugs), 's:is_managed(v:key)')
                              let todo = empty(args) ? filter(managed, '!v:val.frozen || !isdirectory(v:val.dir)') :
                                                     \ filter(managed, 'index(args, v:key) >= 0')
                            
                              if empty(todo)
                                return s:warn('echo', 'No plugin to '. (a:pull ? 'update' : 'install'))
                              endif
                            
                              if !s:is_win && s:git_version_requirement(2, 3)
                                let s:git_terminal_prompt = exists('$GIT_TERMINAL_PROMPT') ? $GIT_TERMINAL_PROMPT : ''
                                let $GIT_TERMINAL_PROMPT = 0
                                for plug in values(todo)
                                  let plug.uri = substitute(plug.uri,
                                        \ '^https://git::@github\.com', 'https://github.com', '')
                                endfor
                              endif
                            
                              if !isdirectory(g:plug_home)
                                try
                                  call mkdir(g:plug_home, 'p')
                                catch
                                  return s:err(printf('Invalid plug directory: %s. '.
                                          \ 'Try to call plug#begin with a valid directory', g:plug_home))
                                endtry
                              endif
                            
                              if has('nvim') && !exists('*jobwait') && threads > 1
                                call s:warn('echom', '[vim-plug] Update Neovim for parallel installer')
                              endif
                            
                              let use_job = s:nvim || s:vim8
                              let python = (has('python') || has('python3')) && !use_job
                              let ruby = has('ruby') && !use_job && (v:version >= 703 || v:version == 702 && has('patch374')) && !(s:is_win && has('gui_running')) && threads > 1 && s:check_ruby()
                            
                              let s:update = {
                                \ 'start':   reltime(),
                                \ 'all':     todo,
                                \ 'todo':    copy(todo),
                                \ 'errors':  [],
                                \ 'pull':    a:pull,
                                \ 'force':   a:force,
                                \ 'new':     {},
                                \ 'threads': (python || ruby || use_job) ? min([len(todo), threads]) : 1,
                                \ 'bar':     '',
                                \ 'fin':     0
                              \ }
                            
                              call s:prepare(1)
                              call append(0, ['', ''])
                              normal! 2G
                              silent! redraw
                            
                              " Set remote name, overriding a possible user git config's clone.defaultRemoteName
                              let s:clone_opt = ['--origin', 'origin']
                              if get(g:, 'plug_shallow', 1)
                                call extend(s:clone_opt, ['--depth', '1'])
                                if s:git_version_requirement(1, 7, 10)
                                  call add(s:clone_opt, '--no-single-branch')
                                endif
                              endif
                            
                              if has('win32unix') || has('wsl')
                                call extend(s:clone_opt, ['-c', 'core.eol=lf', '-c', 'core.autocrlf=input'])
                              endif
                            
                              let s:submodule_opt = s:git_version_requirement(2, 8) ? ' --jobs='.threads : ''
                            
                              " Python version requirement (>= 2.7)
                              if python && !has('python3') && !ruby && !use_job && s:update.threads > 1
                                redir => pyv
                                silent python import platform; print platform.python_version()
                                redir END
                                let python = s:version_requirement(
                                      \ map(split(split(pyv)[0], '\.'), 'str2nr(v:val)'), [2, 6])
                              endif
                            
                              if (python || ruby) && s:update.threads > 1
                                try
                                  let imd = &imd
                                  if s:mac_gui
                                    set noimd
                                  endif
                                  if ruby
                                    call s:update_ruby()
                                  else
                                    call s:update_python()
                                  endif
                                catch
                                  let lines = getline(4, '$')
                                  let printed = {}
                                  silent! 4,$d _
                                  for line in lines
                                    let name = s:extract_name(line, '.', '')
                                    if empty(name) || !has_key(printed, name)
                                      call append('$', line)
                                      if !empty(name)
                                        let printed[name] = 1
                                        if line[0] == 'x' && index(s:update.errors, name) < 0
                                          call add(s:update.errors, name)
                                        end
                                      endif
                                    endif
                                  endfor
                                finally
                                  let &imd = imd
                                  call s:update_finish()
                                endtry
                              else
                                call s:update_vim()
                                while use_job && sync
                                  sleep 100m
                                  if s:update.fin
                                    break
                                  endif
                                endwhile
                              endif
                            endfunction
                            
    1              0.000001 function! s:log4(name, msg)
                              call setline(4, printf('- %s (%s)', a:msg, a:name))
                              redraw
                            endfunction
                            
    1              0.000001 function! s:update_finish()
                              if exists('s:git_terminal_prompt')
                                let $GIT_TERMINAL_PROMPT = s:git_terminal_prompt
                              endif
                              if s:switch_in()
                                call append(3, '- Updating ...') | 4
                                for [name, spec] in items(filter(copy(s:update.all), 'index(s:update.errors, v:key) < 0 && (s:update.force || s:update.pull || has_key(s:update.new, v:key))'))
                                  let [pos, _] = s:logpos(name)
                                  if !pos
                                    continue
                                  endif
                                  if has_key(spec, 'commit')
                                    call s:log4(name, 'Checking out '.spec.commit)
                                    let out = s:checkout(spec)
                                  elseif has_key(spec, 'tag')
                                    let tag = spec.tag
                                    if tag =~ '\*'
                                      let tags = s:lines(s:system('git tag --list '.plug#shellescape(tag).' --sort -version:refname 2>&1', spec.dir))
                                      if !v:shell_error && !empty(tags)
                                        let tag = tags[0]
                                        call s:log4(name, printf('Latest tag for %s -> %s', spec.tag, tag))
                                        call append(3, '')
                                      endif
                                    endif
                                    call s:log4(name, 'Checking out '.tag)
                                    let out = s:system('git checkout -q '.plug#shellescape(tag).' -- 2>&1', spec.dir)
                                  else
                                    let branch = s:git_origin_branch(spec)
                                    call s:log4(name, 'Merging origin/'.s:esc(branch))
                                    let out = s:system('git checkout -q '.plug#shellescape(branch).' -- 2>&1'
                                          \. (has_key(s:update.new, name) ? '' : ('&& git merge --ff-only '.plug#shellescape('origin/'.branch).' 2>&1')), spec.dir)
                                  endif
                                  if !v:shell_error && filereadable(spec.dir.'/.gitmodules') &&
                                        \ (s:update.force || has_key(s:update.new, name) || s:is_updated(spec.dir))
                                    call s:log4(name, 'Updating submodules. This may take a while.')
                                    let out .= s:bang('git submodule update --init --recursive'.s:submodule_opt.' 2>&1', spec.dir)
                                  endif
                                  let msg = s:format_message(v:shell_error ? 'x': '-', name, out)
                                  if v:shell_error
                                    call add(s:update.errors, name)
                                    call s:regress_bar()
                                    silent execute pos 'd _'
                                    call append(4, msg) | 4
                                  elseif !empty(out)
                                    call setline(pos, msg[0])
                                  endif
                                  redraw
                                endfor
                                silent 4 d _
                                try
                                  call s:do(s:update.pull, s:update.force, filter(copy(s:update.all), 'index(s:update.errors, v:key) < 0 && has_key(v:val, "do")'))
                                catch
                                  call s:warn('echom', v:exception)
                                  call s:warn('echo', '')
                                  return
                                endtry
                                call s:finish(s:update.pull)
                                call setline(1, 'Updated. Elapsed time: ' . split(reltimestr(reltime(s:update.start)))[0] . ' sec.')
                                call s:switch_out('normal! gg')
                              endif
                            endfunction
                            
    1              0.000001 function! s:job_abort()
                              if (!s:nvim && !s:vim8) || !exists('s:jobs')
                                return
                              endif
                            
                              for [name, j] in items(s:jobs)
                                if s:nvim
                                  silent! call jobstop(j.jobid)
                                elseif s:vim8
                                  silent! call job_stop(j.jobid)
                                endif
                                if j.new
                                  call s:rm_rf(g:plugs[name].dir)
                                endif
                              endfor
                              let s:jobs = {}
                            endfunction
                            
    1              0.000001 function! s:last_non_empty_line(lines)
                              let len = len(a:lines)
                              for idx in range(len)
                                let line = a:lines[len-idx-1]
                                if !empty(line)
                                  return line
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000001 function! s:job_out_cb(self, data) abort
                              let self = a:self
                              let data = remove(self.lines, -1) . a:data
                              let lines = map(split(data, "\n", 1), 'split(v:val, "\r", 1)[-1]')
                              call extend(self.lines, lines)
                              " To reduce the number of buffer updates
                              let self.tick = get(self, 'tick', -1) + 1
                              if !self.running || self.tick % len(s:jobs) == 0
                                let bullet = self.running ? (self.new ? '+' : '*') : (self.error ? 'x' : '-')
                                let result = self.error ? join(self.lines, "\n") : s:last_non_empty_line(self.lines)
                                call s:log(bullet, self.name, result)
                              endif
                            endfunction
                            
    1              0.000001 function! s:job_exit_cb(self, data) abort
                              let a:self.running = 0
                              let a:self.error = a:data != 0
                              call s:reap(a:self.name)
                              call s:tick()
                            endfunction
                            
    1              0.000001 function! s:job_cb(fn, job, ch, data)
                              if !s:plug_window_exists() " plug window closed
                                return s:job_abort()
                              endif
                              call call(a:fn, [a:job, a:data])
                            endfunction
                            
    1              0.000001 function! s:nvim_cb(job_id, data, event) dict abort
                              return (a:event == 'stdout' || a:event == 'stderr') ?
                                \ s:job_cb('s:job_out_cb',  self, 0, join(a:data, "\n")) :
                                \ s:job_cb('s:job_exit_cb', self, 0, a:data)
                            endfunction
                            
    1              0.000001 function! s:spawn(name, cmd, opts)
                              let job = { 'name': a:name, 'running': 1, 'error': 0, 'lines': [''],
                                        \ 'new': get(a:opts, 'new', 0) }
                              let s:jobs[a:name] = job
                            
                              if s:nvim
                                if has_key(a:opts, 'dir')
                                  let job.cwd = a:opts.dir
                                endif
                                let argv = a:cmd
                                call extend(job, {
                                \ 'on_stdout': function('s:nvim_cb'),
                                \ 'on_stderr': function('s:nvim_cb'),
                                \ 'on_exit':   function('s:nvim_cb'),
                                \ })
                                let jid = s:plug_call('jobstart', argv, job)
                                if jid > 0
                                  let job.jobid = jid
                                else
                                  let job.running = 0
                                  let job.error   = 1
                                  let job.lines   = [jid < 0 ? argv[0].' is not executable' :
                                        \ 'Invalid arguments (or job table is full)']
                                endif
                              elseif s:vim8
                                let cmd = join(map(copy(a:cmd), 'plug#shellescape(v:val, {"script": 0})'))
                                if has_key(a:opts, 'dir')
                                  let cmd = s:with_cd(cmd, a:opts.dir, 0)
                                endif
                                let argv = s:is_win ? ['cmd', '/s', '/c', '"'.cmd.'"'] : ['sh', '-c', cmd]
                                let jid = job_start(s:is_win ? join(argv, ' ') : argv, {
                                \ 'out_cb':   function('s:job_cb', ['s:job_out_cb',  job]),
                                \ 'err_cb':   function('s:job_cb', ['s:job_out_cb',  job]),
                                \ 'exit_cb':  function('s:job_cb', ['s:job_exit_cb', job]),
                                \ 'err_mode': 'raw',
                                \ 'out_mode': 'raw'
                                \})
                                if job_status(jid) == 'run'
                                  let job.jobid = jid
                                else
                                  let job.running = 0
                                  let job.error   = 1
                                  let job.lines   = ['Failed to start job']
                                endif
                              else
                                let job.lines = s:lines(call('s:system', has_key(a:opts, 'dir') ? [a:cmd, a:opts.dir] : [a:cmd]))
                                let job.error = v:shell_error != 0
                                let job.running = 0
                              endif
                            endfunction
                            
    1              0.000001 function! s:reap(name)
                              let job = s:jobs[a:name]
                              if job.error
                                call add(s:update.errors, a:name)
                              elseif get(job, 'new', 0)
                                let s:update.new[a:name] = 1
                              endif
                              let s:update.bar .= job.error ? 'x' : '='
                            
                              let bullet = job.error ? 'x' : '-'
                              let result = job.error ? join(job.lines, "\n") : s:last_non_empty_line(job.lines)
                              call s:log(bullet, a:name, empty(result) ? 'OK' : result)
                              call s:bar()
                            
                              call remove(s:jobs, a:name)
                            endfunction
                            
    1              0.000001 function! s:bar()
                              if s:switch_in()
                                let total = len(s:update.all)
                                call setline(1, (s:update.pull ? 'Updating' : 'Installing').
                                      \ ' plugins ('.len(s:update.bar).'/'.total.')')
                                call s:progress_bar(2, s:update.bar, total)
                                call s:switch_out()
                              endif
                            endfunction
                            
    1              0.000001 function! s:logpos(name)
                              let max = line('$')
                              for i in range(4, max > 4 ? max : 4)
                                if getline(i) =~# '^[-+x*] '.a:name.':'
                                  for j in range(i + 1, max > 5 ? max : 5)
                                    if getline(j) !~ '^ '
                                      return [i, j - 1]
                                    endif
                                  endfor
                                  return [i, i]
                                endif
                              endfor
                              return [0, 0]
                            endfunction
                            
    1              0.000001 function! s:log(bullet, name, lines)
                              if s:switch_in()
                                let [b, e] = s:logpos(a:name)
                                if b > 0
                                  silent execute printf('%d,%d d _', b, e)
                                  if b > winheight('.')
                                    let b = 4
                                  endif
                                else
                                  let b = 4
                                endif
                                " FIXME For some reason, nomodifiable is set after :d in vim8
                                setlocal modifiable
                                call append(b - 1, s:format_message(a:bullet, a:name, a:lines))
                                call s:switch_out()
                              endif
                            endfunction
                            
    1              0.000001 function! s:update_vim()
                              let s:jobs = {}
                            
                              call s:bar()
                              call s:tick()
                            endfunction
                            
    1              0.000001 function! s:tick()
                              let pull = s:update.pull
                              let prog = s:progress_opt(s:nvim || s:vim8)
                            while 1 " Without TCO, Vim stack is bound to explode
                              if empty(s:update.todo)
                                if empty(s:jobs) && !s:update.fin
                                  call s:update_finish()
                                  let s:update.fin = 1
                                endif
                                return
                              endif
                            
                              let name = keys(s:update.todo)[0]
                              let spec = remove(s:update.todo, name)
                              let new  = empty(globpath(spec.dir, '.git', 1))
                            
                              call s:log(new ? '+' : '*', name, pull ? 'Updating ...' : 'Installing ...')
                              redraw
                            
                              let has_tag = has_key(spec, 'tag')
                              if !new
                                let [error, _] = s:git_validate(spec, 0)
                                if empty(error)
                                  if pull
                                    let cmd = s:git_version_requirement(2) ? ['git', '-c', 'credential.helper=', 'fetch'] : ['git', 'fetch']
                                    if has_tag && !empty(globpath(spec.dir, '.git/shallow'))
                                      call extend(cmd, ['--depth', '99999999'])
                                    endif
                                    if !empty(prog)
                                      call add(cmd, prog)
                                    endif
                                    call s:spawn(name, cmd, { 'dir': spec.dir })
                                  else
                                    let s:jobs[name] = { 'running': 0, 'lines': ['Already installed'], 'error': 0 }
                                  endif
                                else
                                  let s:jobs[name] = { 'running': 0, 'lines': s:lines(error), 'error': 1 }
                                endif
                              else
                                let cmd = ['git', 'clone']
                                if !has_tag
                                  call extend(cmd, s:clone_opt)
                                endif
                                if !empty(prog)
                                  call add(cmd, prog)
                                endif
                                call s:spawn(name, extend(cmd, [spec.uri, s:trim(spec.dir)]), { 'new': 1 })
                              endif
                            
                              if !s:jobs[name].running
                                call s:reap(name)
                              endif
                              if len(s:jobs) >= s:update.threads
                                break
                              endif
                            endwhile
                            endfunction
                            
    1              0.000001 function! s:update_python()
                            let py_exe = has('python') ? 'python' : 'python3'
                            execute py_exe "<< EOF"
                            import datetime
                            import functools
                            import os
                            try:
                              import queue
                            except ImportError:
                              import Queue as queue
                            import random
                            import re
                            import shutil
                            import signal
                            import subprocess
                            import tempfile
                            import threading as thr
                            import time
                            import traceback
                            import vim
                            
                            G_NVIM = vim.eval("has('nvim')") == '1'
                            G_PULL = vim.eval('s:update.pull') == '1'
                            G_RETRIES = int(vim.eval('get(g:, "plug_retries", 2)')) + 1
                            G_TIMEOUT = int(vim.eval('get(g:, "plug_timeout", 60)'))
                            G_CLONE_OPT = ' '.join(vim.eval('s:clone_opt'))
                            G_PROGRESS = vim.eval('s:progress_opt(1)')
                            G_LOG_PROB = 1.0 / int(vim.eval('s:update.threads'))
                            G_STOP = thr.Event()
                            G_IS_WIN = vim.eval('s:is_win') == '1'
                            
                            class PlugError(Exception):
                              def __init__(self, msg):
                                self.msg = msg
                            class CmdTimedOut(PlugError):
                              pass
                            class CmdFailed(PlugError):
                              pass
                            class InvalidURI(PlugError):
                              pass
                            class Action(object):
                              INSTALL, UPDATE, ERROR, DONE = ['+', '*', 'x', '-']
                            
                            class Buffer(object):
                              def __init__(self, lock, num_plugs, is_pull):
                                self.bar = ''
                                self.event = 'Updating' if is_pull else 'Installing'
                                self.lock = lock
                                self.maxy = int(vim.eval('winheight(".")'))
                                self.num_plugs = num_plugs
                            
                              def __where(self, name):
                                """ Find first line with name in current buffer. Return line num. """
                                found, lnum = False, 0
                                matcher = re.compile('^[-+x*] {0}:'.format(name))
                                for line in vim.current.buffer:
                                  if matcher.search(line) is not None:
                                    found = True
                                    break
                                  lnum += 1
                            
                                if not found:
                                  lnum = -1
                                return lnum
                            
                              def header(self):
                                curbuf = vim.current.buffer
                                curbuf[0] = self.event + ' plugins ({0}/{1})'.format(len(self.bar), self.num_plugs)
                            
                                num_spaces = self.num_plugs - len(self.bar)
                                curbuf[1] = '[{0}{1}]'.format(self.bar, num_spaces * ' ')
                            
                                with self.lock:
                                  vim.command('normal! 2G')
                                  vim.command('redraw')
                            
                              def write(self, action, name, lines):
                                first, rest = lines[0], lines[1:]
                                msg = ['{0} {1}{2}{3}'.format(action, name, ': ' if first else '', first)]
                                msg.extend(['    ' + line for line in rest])
                            
                                try:
                                  if action == Action.ERROR:
                                    self.bar += 'x'
                                    vim.command("call add(s:update.errors, '{0}')".format(name))
                                  elif action == Action.DONE:
                                    self.bar += '='
                            
                                  curbuf = vim.current.buffer
                                  lnum = self.__where(name)
                                  if lnum != -1: # Found matching line num
                                    del curbuf[lnum]
                                    if lnum > self.maxy and action in set([Action.INSTALL, Action.UPDATE]):
                                      lnum = 3
                                  else:
                                    lnum = 3
                                  curbuf.append(msg, lnum)
                            
                                  self.header()
                                except vim.error:
                                  pass
                            
                            class Command(object):
                              CD = 'cd /d' if G_IS_WIN else 'cd'
                            
                              def __init__(self, cmd, cmd_dir=None, timeout=60, cb=None, clean=None):
                                self.cmd = cmd
                                if cmd_dir:
                                  self.cmd = '{0} {1} && {2}'.format(Command.CD, cmd_dir, self.cmd)
                                self.timeout = timeout
                                self.callback = cb if cb else (lambda msg: None)
                                self.clean = clean if clean else (lambda: None)
                                self.proc = None
                            
                              @property
                              def alive(self):
                                """ Returns true only if command still running. """
                                return self.proc and self.proc.poll() is None
                            
                              def execute(self, ntries=3):
                                """ Execute the command with ntries if CmdTimedOut.
                                    Returns the output of the command if no Exception.
                                """
                                attempt, finished, limit = 0, False, self.timeout
                            
                                while not finished:
                                  try:
                                    attempt += 1
                                    result = self.try_command()
                                    finished = True
                                    return result
                                  except CmdTimedOut:
                                    if attempt != ntries:
                                      self.notify_retry()
                                      self.timeout += limit
                                    else:
                                      raise
                            
                              def notify_retry(self):
                                """ Retry required for command, notify user. """
                                for count in range(3, 0, -1):
                                  if G_STOP.is_set():
                                    raise KeyboardInterrupt
                                  msg = 'Timeout. Will retry in {0} second{1} ...'.format(
                                        count, 's' if count != 1 else '')
                                  self.callback([msg])
                                  time.sleep(1)
                                self.callback(['Retrying ...'])
                            
                              def try_command(self):
                                """ Execute a cmd & poll for callback. Returns list of output.
                                    Raises CmdFailed   -> return code for Popen isn't 0
                                    Raises CmdTimedOut -> command exceeded timeout without new output
                                """
                                first_line = True
                            
                                try:
                                  tfile = tempfile.NamedTemporaryFile(mode='w+b')
                                  preexec_fn = not G_IS_WIN and os.setsid or None
                                  self.proc = subprocess.Popen(self.cmd, stdout=tfile,
                                                               stderr=subprocess.STDOUT,
                                                               stdin=subprocess.PIPE, shell=True,
                                                               preexec_fn=preexec_fn)
                                  thrd = thr.Thread(target=(lambda proc: proc.wait()), args=(self.proc,))
                                  thrd.start()
                            
                                  thread_not_started = True
                                  while thread_not_started:
                                    try:
                                      thrd.join(0.1)
                                      thread_not_started = False
                                    except RuntimeError:
                                      pass
                            
                                  while self.alive:
                                    if G_STOP.is_set():
                                      raise KeyboardInterrupt
                            
                                    if first_line or random.random() < G_LOG_PROB:
                                      first_line = False
                                      line = '' if G_IS_WIN else nonblock_read(tfile.name)
                                      if line:
                                        self.callback([line])
                            
                                    time_diff = time.time() - os.path.getmtime(tfile.name)
                                    if time_diff > self.timeout:
                                      raise CmdTimedOut(['Timeout!'])
                            
                                    thrd.join(0.5)
                            
                                  tfile.seek(0)
                                  result = [line.decode('utf-8', 'replace').rstrip() for line in tfile]
                            
                                  if self.proc.returncode != 0:
                                    raise CmdFailed([''] + result)
                            
                                  return result
                                except:
                                  self.terminate()
                                  raise
                            
                              def terminate(self):
                                """ Terminate process and cleanup. """
                                if self.alive:
                                  if G_IS_WIN:
                                    os.kill(self.proc.pid, signal.SIGINT)
                                  else:
                                    os.killpg(self.proc.pid, signal.SIGTERM)
                                self.clean()
                            
                            class Plugin(object):
                              def __init__(self, name, args, buf_q, lock):
                                self.name = name
                                self.args = args
                                self.buf_q = buf_q
                                self.lock = lock
                                self.tag = args.get('tag', 0)
                            
                              def manage(self):
                                try:
                                  if os.path.exists(self.args['dir']):
                                    self.update()
                                  else:
                                    self.install()
                                    with self.lock:
                                      thread_vim_command("let s:update.new['{0}'] = 1".format(self.name))
                                except PlugError as exc:
                                  self.write(Action.ERROR, self.name, exc.msg)
                                except KeyboardInterrupt:
                                  G_STOP.set()
                                  self.write(Action.ERROR, self.name, ['Interrupted!'])
                                except:
                                  # Any exception except those above print stack trace
                                  msg = 'Trace:\n{0}'.format(traceback.format_exc().rstrip())
                                  self.write(Action.ERROR, self.name, msg.split('\n'))
                                  raise
                            
                              def install(self):
                                target = self.args['dir']
                                if target[-1] == '\\':
                                  target = target[0:-1]
                            
                                def clean(target):
                                  def _clean():
                                    try:
                                      shutil.rmtree(target)
                                    except OSError:
                                      pass
                                  return _clean
                            
                                self.write(Action.INSTALL, self.name, ['Installing ...'])
                                callback = functools.partial(self.write, Action.INSTALL, self.name)
                                cmd = 'git clone {0} {1} {2} {3} 2>&1'.format(
                                      '' if self.tag else G_CLONE_OPT, G_PROGRESS, self.args['uri'],
                                      esc(target))
                                com = Command(cmd, None, G_TIMEOUT, callback, clean(target))
                                result = com.execute(G_RETRIES)
                                self.write(Action.DONE, self.name, result[-1:])
                            
                              def repo_uri(self):
                                cmd = 'git rev-parse --abbrev-ref HEAD 2>&1 && git config -f .git/config remote.origin.url'
                                command = Command(cmd, self.args['dir'], G_TIMEOUT,)
                                result = command.execute(G_RETRIES)
                                return result[-1]
                            
                              def update(self):
                                actual_uri = self.repo_uri()
                                expect_uri = self.args['uri']
                                regex = re.compile(r'^(?:\w+://)?(?:[^@/]*@)?([^:/]*(?::[0-9]*)?)[:/](.*?)(?:\.git)?/?$')
                                ma = regex.match(actual_uri)
                                mb = regex.match(expect_uri)
                                if ma is None or mb is None or ma.groups() != mb.groups():
                                  msg = ['',
                                         'Invalid URI: {0}'.format(actual_uri),
                                         'Expected     {0}'.format(expect_uri),
                                         'PlugClean required.']
                                  raise InvalidURI(msg)
                            
                                if G_PULL:
                                  self.write(Action.UPDATE, self.name, ['Updating ...'])
                                  callback = functools.partial(self.write, Action.UPDATE, self.name)
                                  fetch_opt = '--depth 99999999' if self.tag and os.path.isfile(os.path.join(self.args['dir'], '.git/shallow')) else ''
                                  cmd = 'git fetch {0} {1} 2>&1'.format(fetch_opt, G_PROGRESS)
                                  com = Command(cmd, self.args['dir'], G_TIMEOUT, callback)
                                  result = com.execute(G_RETRIES)
                                  self.write(Action.DONE, self.name, result[-1:])
                                else:
                                  self.write(Action.DONE, self.name, ['Already installed'])
                            
                              def write(self, action, name, msg):
                                self.buf_q.put((action, name, msg))
                            
                            class PlugThread(thr.Thread):
                              def __init__(self, tname, args):
                                super(PlugThread, self).__init__()
                                self.tname = tname
                                self.args = args
                            
                              def run(self):
                                thr.current_thread().name = self.tname
                                buf_q, work_q, lock = self.args
                            
                                try:
                                  while not G_STOP.is_set():
                                    name, args = work_q.get_nowait()
                                    plug = Plugin(name, args, buf_q, lock)
                                    plug.manage()
                                    work_q.task_done()
                                except queue.Empty:
                                  pass
                            
                            class RefreshThread(thr.Thread):
                              def __init__(self, lock):
                                super(RefreshThread, self).__init__()
                                self.lock = lock
                                self.running = True
                            
                              def run(self):
                                while self.running:
                                  with self.lock:
                                    thread_vim_command('noautocmd normal! a')
                                  time.sleep(0.33)
                            
                              def stop(self):
                                self.running = False
                            
                            if G_NVIM:
                              def thread_vim_command(cmd):
                                vim.session.threadsafe_call(lambda: vim.command(cmd))
                            else:
                              def thread_vim_command(cmd):
                                vim.command(cmd)
                            
                            def esc(name):
                              return '"' + name.replace('"', '\"') + '"'
                            
                            def nonblock_read(fname):
                              """ Read a file with nonblock flag. Return the last line. """
                              fread = os.open(fname, os.O_RDONLY | os.O_NONBLOCK)
                              buf = os.read(fread, 100000).decode('utf-8', 'replace')
                              os.close(fread)
                            
                              line = buf.rstrip('\r\n')
                              left = max(line.rfind('\r'), line.rfind('\n'))
                              if left != -1:
                                left += 1
                                line = line[left:]
                            
                              return line
                            
                            def main():
                              thr.current_thread().name = 'main'
                              nthreads = int(vim.eval('s:update.threads'))
                              plugs = vim.eval('s:update.todo')
                              mac_gui = vim.eval('s:mac_gui') == '1'
                            
                              lock = thr.Lock()
                              buf = Buffer(lock, len(plugs), G_PULL)
                              buf_q, work_q = queue.Queue(), queue.Queue()
                              for work in plugs.items():
                                work_q.put(work)
                            
                              start_cnt = thr.active_count()
                              for num in range(nthreads):
                                tname = 'PlugT-{0:02}'.format(num)
                                thread = PlugThread(tname, (buf_q, work_q, lock))
                                thread.start()
                              if mac_gui:
                                rthread = RefreshThread(lock)
                                rthread.start()
                            
                              while not buf_q.empty() or thr.active_count() != start_cnt:
                                try:
                                  action, name, msg = buf_q.get(True, 0.25)
                                  buf.write(action, name, ['OK'] if not msg else msg)
                                  buf_q.task_done()
                                except queue.Empty:
                                  pass
                                except KeyboardInterrupt:
                                  G_STOP.set()
                            
                              if mac_gui:
                                rthread.stop()
                                rthread.join()
                            
                            main()
                            EOF
                            endfunction
                            
    1              0.000001 function! s:update_ruby()
                              ruby << EOF
                              module PlugStream
                                SEP = ["\r", "\n", nil]
                                def get_line
                                  buffer = ''
                                  loop do
                                    char = readchar rescue return
                                    if SEP.include? char.chr
                                      buffer << $/
                                      break
                                    else
                                      buffer << char
                                    end
                                  end
                                  buffer
                                end
                              end unless defined?(PlugStream)
                            
                              def esc arg
                                %["#{arg.gsub('"', '\"')}"]
                              end
                            
                              def killall pid
                                pids = [pid]
                                if /mswin|mingw|bccwin/ =~ RUBY_PLATFORM
                                  pids.each { |pid| Process.kill 'INT', pid.to_i rescue nil }
                                else
                                  unless `which pgrep 2> /dev/null`.empty?
                                    children = pids
                                    until children.empty?
                                      children = children.map { |pid|
                                        `pgrep -P #{pid}`.lines.map { |l| l.chomp }
                                      }.flatten
                                      pids += children
                                    end
                                  end
                                  pids.each { |pid| Process.kill 'TERM', pid.to_i rescue nil }
                                end
                              end
                            
                              def compare_git_uri a, b
                                regex = %r{^(?:\w+://)?(?:[^@/]*@)?([^:/]*(?::[0-9]*)?)[:/](.*?)(?:\.git)?/?$}
                                regex.match(a).to_a.drop(1) == regex.match(b).to_a.drop(1)
                              end
                            
                              require 'thread'
                              require 'fileutils'
                              require 'timeout'
                              running = true
                              iswin = VIM::evaluate('s:is_win').to_i == 1
                              pull  = VIM::evaluate('s:update.pull').to_i == 1
                              base  = VIM::evaluate('g:plug_home')
                              all   = VIM::evaluate('s:update.todo')
                              limit = VIM::evaluate('get(g:, "plug_timeout", 60)')
                              tries = VIM::evaluate('get(g:, "plug_retries", 2)') + 1
                              nthr  = VIM::evaluate('s:update.threads').to_i
                              maxy  = VIM::evaluate('winheight(".")').to_i
                              vim7  = VIM::evaluate('v:version').to_i <= 703 && RUBY_PLATFORM =~ /darwin/
                              cd    = iswin ? 'cd /d' : 'cd'
                              tot   = VIM::evaluate('len(s:update.todo)') || 0
                              bar   = ''
                              skip  = 'Already installed'
                              mtx   = Mutex.new
                              take1 = proc { mtx.synchronize { running && all.shift } }
                              logh  = proc {
                                cnt = bar.length
                                $curbuf[1] = "#{pull ? 'Updating' : 'Installing'} plugins (#{cnt}/#{tot})"
                                $curbuf[2] = '[' + bar.ljust(tot) + ']'
                                VIM::command('normal! 2G')
                                VIM::command('redraw')
                              }
                              where = proc { |name| (1..($curbuf.length)).find { |l| $curbuf[l] =~ /^[-+x*] #{name}:/ } }
                              log   = proc { |name, result, type|
                                mtx.synchronize do
                                  ing  = ![true, false].include?(type)
                                  bar += type ? '=' : 'x' unless ing
                                  b = case type
                                      when :install  then '+' when :update then '*'
                                      when true, nil then '-' else
                                        VIM::command("call add(s:update.errors, '#{name}')")
                                        'x'
                                      end
                                  result =
                                    if type || type.nil?
                                      ["#{b} #{name}: #{result.lines.to_a.last || 'OK'}"]
                                    elsif result =~ /^Interrupted|^Timeout/
                                      ["#{b} #{name}: #{result}"]
                                    else
                                      ["#{b} #{name}"] + result.lines.map { |l| "    " << l }
                                    end
                                  if lnum = where.call(name)
                                    $curbuf.delete lnum
                                    lnum = 4 if ing && lnum > maxy
                                  end
                                  result.each_with_index do |line, offset|
                                    $curbuf.append((lnum || 4) - 1 + offset, line.gsub(/\e\[./, '').chomp)
                                  end
                                  logh.call
                                end
                              }
                              bt = proc { |cmd, name, type, cleanup|
                                tried = timeout = 0
                                begin
                                  tried += 1
                                  timeout += limit
                                  fd = nil
                                  data = ''
                                  if iswin
                                    Timeout::timeout(timeout) do
                                      tmp = VIM::evaluate('tempname()')
                                      system("(#{cmd}) > #{tmp}")
                                      data = File.read(tmp).chomp
                                      File.unlink tmp rescue nil
                                    end
                                  else
                                    fd = IO.popen(cmd).extend(PlugStream)
                                    first_line = true
                                    log_prob = 1.0 / nthr
                                    while line = Timeout::timeout(timeout) { fd.get_line }
                                      data << line
                                      log.call name, line.chomp, type if name && (first_line || rand < log_prob)
                                      first_line = false
                                    end
                                    fd.close
                                  end
                                  [$? == 0, data.chomp]
                                rescue Timeout::Error, Interrupt => e
                                  if fd && !fd.closed?
                                    killall fd.pid
                                    fd.close
                                  end
                                  cleanup.call if cleanup
                                  if e.is_a?(Timeout::Error) && tried < tries
                                    3.downto(1) do |countdown|
                                      s = countdown > 1 ? 's' : ''
                                      log.call name, "Timeout. Will retry in #{countdown} second#{s} ...", type
                                      sleep 1
                                    end
                                    log.call name, 'Retrying ...', type
                                    retry
                                  end
                                  [false, e.is_a?(Interrupt) ? "Interrupted!" : "Timeout!"]
                                end
                              }
                              main = Thread.current
                              threads = []
                              watcher = Thread.new {
                                if vim7
                                  while VIM::evaluate('getchar(1)')
                                    sleep 0.1
                                  end
                                else
                                  require 'io/console' # >= Ruby 1.9
                                  nil until IO.console.getch == 3.chr
                                end
                                mtx.synchronize do
                                  running = false
                                  threads.each { |t| t.raise Interrupt } unless vim7
                                end
                                threads.each { |t| t.join rescue nil }
                                main.kill
                              }
                              refresh = Thread.new {
                                while true
                                  mtx.synchronize do
                                    break unless running
                                    VIM::command('noautocmd normal! a')
                                  end
                                  sleep 0.2
                                end
                              } if VIM::evaluate('s:mac_gui') == 1
                            
                              clone_opt = VIM::evaluate('s:clone_opt').join(' ')
                              progress = VIM::evaluate('s:progress_opt(1)')
                              nthr.times do
                                mtx.synchronize do
                                  threads << Thread.new {
                                    while pair = take1.call
                                      name = pair.first
                                      dir, uri, tag = pair.last.values_at *%w[dir uri tag]
                                      exists = File.directory? dir
                                      ok, result =
                                        if exists
                                          chdir = "#{cd} #{iswin ? dir : esc(dir)}"
                                          ret, data = bt.call "#{chdir} && git rev-parse --abbrev-ref HEAD 2>&1 && git config -f .git/config remote.origin.url", nil, nil, nil
                                          current_uri = data.lines.to_a.last
                                          if !ret
                                            if data =~ /^Interrupted|^Timeout/
                                              [false, data]
                                            else
                                              [false, [data.chomp, "PlugClean required."].join($/)]
                                            end
                                          elsif !compare_git_uri(current_uri, uri)
                                            [false, ["Invalid URI: #{current_uri}",
                                                     "Expected:    #{uri}",
                                                     "PlugClean required."].join($/)]
                                          else
                                            if pull
                                              log.call name, 'Updating ...', :update
                                              fetch_opt = (tag && File.exist?(File.join(dir, '.git/shallow'))) ? '--depth 99999999' : ''
                                              bt.call "#{chdir} && git fetch #{fetch_opt} #{progress} 2>&1", name, :update, nil
                                            else
                                              [true, skip]
                                            end
                                          end
                                        else
                                          d = esc dir.sub(%r{[\\/]+$}, '')
                                          log.call name, 'Installing ...', :install
                                          bt.call "git clone #{clone_opt unless tag} #{progress} #{uri} #{d} 2>&1", name, :install, proc {
                                            FileUtils.rm_rf dir
                                          }
                                        end
                                      mtx.synchronize { VIM::command("let s:update.new['#{name}'] = 1") } if !exists && ok
                                      log.call name, result, ok
                                    end
                                  } if running
                                end
                              end
                              threads.each { |t| t.join rescue nil }
                              logh.call
                              refresh.kill if refresh
                              watcher.kill
                            EOF
                            endfunction
                            
    1              0.000001 function! s:shellesc_cmd(arg, script)
                              let escaped = substitute('"'.a:arg.'"', '[&|<>()@^!"]', '^&', 'g')
                              return substitute(escaped, '%', (a:script ? '%' : '^') . '&', 'g')
                            endfunction
                            
    1              0.000001 function! s:shellesc_ps1(arg)
                              return "'".substitute(escape(a:arg, '\"'), "'", "''", 'g')."'"
                            endfunction
                            
    1              0.000001 function! s:shellesc_sh(arg)
                              return "'".substitute(a:arg, "'", "'\\\\''", 'g')."'"
                            endfunction
                            
                            " Escape the shell argument based on the shell.
                            " Vim and Neovim's shellescape() are insufficient.
                            " 1. shellslash determines whether to use single/double quotes.
                            "    Double-quote escaping is fragile for cmd.exe.
                            " 2. It does not work for powershell.
                            " 3. It does not work for *sh shells if the command is executed
                            "    via cmd.exe (ie. cmd.exe /c sh -c command command_args)
                            " 4. It does not support batchfile syntax.
                            "
                            " Accepts an optional dictionary with the following keys:
                            " - shell: same as Vim/Neovim 'shell' option.
                            "          If unset, fallback to 'cmd.exe' on Windows or 'sh'.
                            " - script: If truthy and shell is cmd.exe, escape for batchfile syntax.
    1              0.000001 function! plug#shellescape(arg, ...)
                              if a:arg =~# '^[A-Za-z0-9_/:.-]\+$'
                                return a:arg
                              endif
                              let opts = a:0 > 0 && type(a:1) == s:TYPE.dict ? a:1 : {}
                              let shell = get(opts, 'shell', s:is_win ? 'cmd.exe' : 'sh')
                              let script = get(opts, 'script', 1)
                              if shell =~# 'cmd\(\.exe\)\?$'
                                return s:shellesc_cmd(a:arg, script)
                              elseif s:is_powershell(shell)
                                return s:shellesc_ps1(a:arg)
                              endif
                              return s:shellesc_sh(a:arg)
                            endfunction
                            
    1              0.000001 function! s:glob_dir(path)
                              return map(filter(s:glob(a:path, '**'), 'isdirectory(v:val)'), 's:dirpath(v:val)')
                            endfunction
                            
    1              0.000001 function! s:progress_bar(line, bar, total)
                              call setline(a:line, '[' . s:lpad(a:bar, a:total) . ']')
                            endfunction
                            
    1              0.000001 function! s:compare_git_uri(a, b)
                              " See `git help clone'
                              " https:// [user@] github.com[:port] / junegunn/vim-plug [.git]
                              "          [git@]  github.com[:port] : junegunn/vim-plug [.git]
                              " file://                            / junegunn/vim-plug        [/]
                              "                                    / junegunn/vim-plug        [/]
                              let pat = '^\%(\w\+://\)\='.'\%([^@/]*@\)\='.'\([^:/]*\%(:[0-9]*\)\=\)'.'[:/]'.'\(.\{-}\)'.'\%(\.git\)\=/\?$'
                              let ma = matchlist(a:a, pat)
                              let mb = matchlist(a:b, pat)
                              return ma[1:2] ==# mb[1:2]
                            endfunction
                            
    1              0.000001 function! s:format_message(bullet, name, message)
                              if a:bullet != 'x'
                                return [printf('%s %s: %s', a:bullet, a:name, s:lastline(a:message))]
                              else
                                let lines = map(s:lines(a:message), '"    ".v:val')
                                return extend([printf('x %s:', a:name)], lines)
                              endif
                            endfunction
                            
    1              0.000001 function! s:with_cd(cmd, dir, ...)
                              let script = a:0 > 0 ? a:1 : 1
                              return printf('cd%s %s && %s', s:is_win ? ' /d' : '', plug#shellescape(a:dir, {'script': script}), a:cmd)
                            endfunction
                            
    1              0.000001 function! s:system(cmd, ...)
                              let batchfile = ''
                              try
                                let [sh, shellcmdflag, shrd] = s:chsh(1)
                                if type(a:cmd) == s:TYPE.list
                                  " Neovim's system() supports list argument to bypass the shell
                                  " but it cannot set the working directory for the command.
                                  " Assume that the command does not rely on the shell.
                                  if has('nvim') && a:0 == 0
                                    return system(a:cmd)
                                  endif
                                  let cmd = join(map(copy(a:cmd), 'plug#shellescape(v:val, {"shell": &shell, "script": 0})'))
                                  if s:is_powershell(&shell)
                                    let cmd = '& ' . cmd
                                  endif
                                else
                                  let cmd = a:cmd
                                endif
                                if a:0 > 0
                                  let cmd = s:with_cd(cmd, a:1, type(a:cmd) != s:TYPE.list)
                                endif
                                if s:is_win && type(a:cmd) != s:TYPE.list
                                  let [batchfile, cmd] = s:batchfile(cmd)
                                endif
                                return system(cmd)
                              finally
                                let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                                if s:is_win && filereadable(batchfile)
                                  call delete(batchfile)
                                endif
                              endtry
                            endfunction
                            
    1              0.000001 function! s:system_chomp(...)
                              let ret = call('s:system', a:000)
                              return v:shell_error ? '' : substitute(ret, '\n$', '', '')
                            endfunction
                            
    1              0.000001 function! s:git_validate(spec, check_branch)
                              let err = ''
                              if isdirectory(a:spec.dir)
                                let result = [s:git_local_branch(a:spec.dir), s:git_origin_url(a:spec.dir)]
                                let remote = result[-1]
                                if empty(remote)
                                  let err = join([remote, 'PlugClean required.'], "\n")
                                elseif !s:compare_git_uri(remote, a:spec.uri)
                                  let err = join(['Invalid URI: '.remote,
                                                \ 'Expected:    '.a:spec.uri,
                                                \ 'PlugClean required.'], "\n")
                                elseif a:check_branch && has_key(a:spec, 'commit')
                                  let sha = s:git_revision(a:spec.dir)
                                  if empty(sha)
                                    let err = join(add(result, 'PlugClean required.'), "\n")
                                  elseif !s:hash_match(sha, a:spec.commit)
                                    let err = join([printf('Invalid HEAD (expected: %s, actual: %s)',
                                                          \ a:spec.commit[:6], sha[:6]),
                                                  \ 'PlugUpdate required.'], "\n")
                                  endif
                                elseif a:check_branch
                                  let current_branch = result[0]
                                  " Check tag
                                  let origin_branch = s:git_origin_branch(a:spec)
                                  if has_key(a:spec, 'tag')
                                    let tag = s:system_chomp('git describe --exact-match --tags HEAD 2>&1', a:spec.dir)
                                    if a:spec.tag !=# tag && a:spec.tag !~ '\*'
                                      let err = printf('Invalid tag: %s (expected: %s). Try PlugUpdate.',
                                            \ (empty(tag) ? 'N/A' : tag), a:spec.tag)
                                    endif
                                  " Check branch
                                  elseif origin_branch !=# current_branch
                                    let err = printf('Invalid branch: %s (expected: %s). Try PlugUpdate.',
                                          \ current_branch, origin_branch)
                                  endif
                                  if empty(err)
                                    let [ahead, behind] = split(s:lastline(s:system([
                                    \ 'git', 'rev-list', '--count', '--left-right',
                                    \ printf('HEAD...origin/%s', origin_branch)
                                    \ ], a:spec.dir)), '\t')
                                    if !v:shell_error && ahead
                                      if behind
                                        " Only mention PlugClean if diverged, otherwise it's likely to be
                                        " pushable (and probably not that messed up).
                                        let err = printf(
                                              \ "Diverged from origin/%s (%d commit(s) ahead and %d commit(s) behind!\n"
                                              \ .'Backup local changes and run PlugClean and PlugUpdate to reinstall it.', origin_branch, ahead, behind)
                                      else
                                        let err = printf("Ahead of origin/%s by %d commit(s).\n"
                                              \ .'Cannot update until local changes are pushed.',
                                              \ origin_branch, ahead)
                                      endif
                                    endif
                                  endif
                                endif
                              else
                                let err = 'Not found'
                              endif
                              return [err, err =~# 'PlugClean']
                            endfunction
                            
    1              0.000001 function! s:rm_rf(dir)
                              if isdirectory(a:dir)
                                return s:system(s:is_win
                                \ ? 'rmdir /S /Q '.plug#shellescape(a:dir)
                                \ : ['rm', '-rf', a:dir])
                              endif
                            endfunction
                            
    1              0.000001 function! s:clean(force)
                              call s:prepare()
                              call append(0, 'Searching for invalid plugins in '.g:plug_home)
                              call append(1, '')
                            
                              " List of valid directories
                              let dirs = []
                              let errs = {}
                              let [cnt, total] = [0, len(g:plugs)]
                              for [name, spec] in items(g:plugs)
                                if !s:is_managed(name)
                                  call add(dirs, spec.dir)
                                else
                                  let [err, clean] = s:git_validate(spec, 1)
                                  if clean
                                    let errs[spec.dir] = s:lines(err)[0]
                                  else
                                    call add(dirs, spec.dir)
                                  endif
                                endif
                                let cnt += 1
                                call s:progress_bar(2, repeat('=', cnt), total)
                                normal! 2G
                                redraw
                              endfor
                            
                              let allowed = {}
                              for dir in dirs
                                let allowed[s:dirpath(s:plug_fnamemodify(dir, ':h:h'))] = 1
                                let allowed[dir] = 1
                                for child in s:glob_dir(dir)
                                  let allowed[child] = 1
                                endfor
                              endfor
                            
                              let todo = []
                              let found = sort(s:glob_dir(g:plug_home))
                              while !empty(found)
                                let f = remove(found, 0)
                                if !has_key(allowed, f) && isdirectory(f)
                                  call add(todo, f)
                                  call append(line('$'), '- ' . f)
                                  if has_key(errs, f)
                                    call append(line('$'), '    ' . errs[f])
                                  endif
                                  let found = filter(found, 'stridx(v:val, f) != 0')
                                end
                              endwhile
                            
                              4
                              redraw
                              if empty(todo)
                                call append(line('$'), 'Already clean.')
                              else
                                let s:clean_count = 0
                                call append(3, ['Directories to delete:', ''])
                                redraw!
                                if a:force || s:ask_no_interrupt('Delete all directories?')
                                  call s:delete([6, line('$')], 1)
                                else
                                  call setline(4, 'Cancelled.')
                                  nnoremap <silent> <buffer> d :set opfunc=<sid>delete_op<cr>g@
                                  nmap     <silent> <buffer> dd d_
                                  xnoremap <silent> <buffer> d :<c-u>call <sid>delete_op(visualmode(), 1)<cr>
                                  echo 'Delete the lines (d{motion}) to delete the corresponding directories'
                                endif
                              endif
                              4
                              setlocal nomodifiable
                            endfunction
                            
    1              0.000001 function! s:delete_op(type, ...)
                              call s:delete(a:0 ? [line("'<"), line("'>")] : [line("'["), line("']")], 0)
                            endfunction
                            
    1              0.000001 function! s:delete(range, force)
                              let [l1, l2] = a:range
                              let force = a:force
                              let err_count = 0
                              while l1 <= l2
                                let line = getline(l1)
                                if line =~ '^- ' && isdirectory(line[2:])
                                  execute l1
                                  redraw!
                                  let answer = force ? 1 : s:ask('Delete '.line[2:].'?', 1)
                                  let force = force || answer > 1
                                  if answer
                                    let err = s:rm_rf(line[2:])
                                    setlocal modifiable
                                    if empty(err)
                                      call setline(l1, '~'.line[1:])
                                      let s:clean_count += 1
                                    else
                                      delete _
                                      call append(l1 - 1, s:format_message('x', line[1:], err))
                                      let l2 += len(s:lines(err))
                                      let err_count += 1
                                    endif
                                    let msg = printf('Removed %d directories.', s:clean_count)
                                    if err_count > 0
                                      let msg .= printf(' Failed to remove %d directories.', err_count)
                                    endif
                                    call setline(4, msg)
                                    setlocal nomodifiable
                                  endif
                                endif
                                let l1 += 1
                              endwhile
                            endfunction
                            
    1              0.000001 function! s:upgrade()
                              echo 'Downloading the latest version of vim-plug'
                              redraw
                              let tmp = s:plug_tempname()
                              let new = tmp . '/plug.vim'
                            
                              try
                                let out = s:system(['git', 'clone', '--depth', '1', s:plug_src, tmp])
                                if v:shell_error
                                  return s:err('Error upgrading vim-plug: '. out)
                                endif
                            
                                if readfile(s:me) ==# readfile(new)
                                  echo 'vim-plug is already up-to-date'
                                  return 0
                                else
                                  call rename(s:me, s:me . '.old')
                                  call rename(new, s:me)
                                  unlet g:loaded_plug
                                  echo 'vim-plug has been upgraded'
                                  return 1
                                endif
                              finally
                                silent! call s:rm_rf(tmp)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:upgrade_specs()
                              for spec in values(g:plugs)
                                let spec.frozen = get(spec, 'frozen', 0)
                              endfor
                            endfunction
                            
    1              0.000001 function! s:status()
                              call s:prepare()
                              call append(0, 'Checking plugins')
                              call append(1, '')
                            
                              let ecnt = 0
                              let unloaded = 0
                              let [cnt, total] = [0, len(g:plugs)]
                              for [name, spec] in items(g:plugs)
                                let is_dir = isdirectory(spec.dir)
                                if has_key(spec, 'uri')
                                  if is_dir
                                    let [err, _] = s:git_validate(spec, 1)
                                    let [valid, msg] = [empty(err), empty(err) ? 'OK' : err]
                                  else
                                    let [valid, msg] = [0, 'Not found. Try PlugInstall.']
                                  endif
                                else
                                  if is_dir
                                    let [valid, msg] = [1, 'OK']
                                  else
                                    let [valid, msg] = [0, 'Not found.']
                                  endif
                                endif
                                let cnt += 1
                                let ecnt += !valid
                                " `s:loaded` entry can be missing if PlugUpgraded
                                if is_dir && get(s:loaded, name, -1) == 0
                                  let unloaded = 1
                                  let msg .= ' (not loaded)'
                                endif
                                call s:progress_bar(2, repeat('=', cnt), total)
                                call append(3, s:format_message(valid ? '-' : 'x', name, msg))
                                normal! 2G
                                redraw
                              endfor
                              call setline(1, 'Finished. '.ecnt.' error(s).')
                              normal! gg
                              setlocal nomodifiable
                              if unloaded
                                echo "Press 'L' on each line to load plugin, or 'U' to update"
                                nnoremap <silent> <buffer> L :call <SID>status_load(line('.'))<cr>
                                xnoremap <silent> <buffer> L :call <SID>status_load(line('.'))<cr>
                              end
                            endfunction
                            
    1              0.000001 function! s:extract_name(str, prefix, suffix)
                              return matchstr(a:str, '^'.a:prefix.' \zs[^:]\+\ze:.*'.a:suffix.'$')
                            endfunction
                            
    1              0.000001 function! s:status_load(lnum)
                              let line = getline(a:lnum)
                              let name = s:extract_name(line, '-', '(not loaded)')
                              if !empty(name)
                                call plug#load(name)
                                setlocal modifiable
                                call setline(a:lnum, substitute(line, ' (not loaded)$', '', ''))
                                setlocal nomodifiable
                              endif
                            endfunction
                            
    1              0.000001 function! s:status_update() range
                              let lines = getline(a:firstline, a:lastline)
                              let names = filter(map(lines, 's:extract_name(v:val, "[x-]", "")'), '!empty(v:val)')
                              if !empty(names)
                                echo
                                execute 'PlugUpdate' join(names)
                              endif
                            endfunction
                            
    1              0.000001 function! s:is_preview_window_open()
                              silent! wincmd P
                              if &previewwindow
                                wincmd p
                                return 1
                              endif
                            endfunction
                            
    1              0.000001 function! s:find_name(lnum)
                              for lnum in reverse(range(1, a:lnum))
                                let line = getline(lnum)
                                if empty(line)
                                  return ''
                                endif
                                let name = s:extract_name(line, '-', '')
                                if !empty(name)
                                  return name
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000001 function! s:preview_commit()
                              if b:plug_preview < 0
                                let b:plug_preview = !s:is_preview_window_open()
                              endif
                            
                              let sha = matchstr(getline('.'), '^  \X*\zs[0-9a-f]\{7,9}')
                              if empty(sha)
                                return
                              endif
                            
                              let name = s:find_name(line('.'))
                              if empty(name) || !has_key(g:plugs, name) || !isdirectory(g:plugs[name].dir)
                                return
                              endif
                            
                              if exists('g:plug_pwindow') && !s:is_preview_window_open()
                                execute g:plug_pwindow
                                execute 'e' sha
                              else
                                execute 'pedit' sha
                                wincmd P
                              endif
                              setlocal previewwindow filetype=git buftype=nofile nobuflisted modifiable
                              let batchfile = ''
                              try
                                let [sh, shellcmdflag, shrd] = s:chsh(1)
                                let cmd = 'cd '.plug#shellescape(g:plugs[name].dir).' && git show --no-color --pretty=medium '.sha
                                if s:is_win
                                  let [batchfile, cmd] = s:batchfile(cmd)
                                endif
                                execute 'silent %!' cmd
                              finally
                                let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                                if s:is_win && filereadable(batchfile)
                                  call delete(batchfile)
                                endif
                              endtry
                              setlocal nomodifiable
                              nnoremap <silent> <buffer> q :q<cr>
                              wincmd p
                            endfunction
                            
    1              0.000001 function! s:section(flags)
                              call search('\(^[x-] \)\@<=[^:]\+:', a:flags)
                            endfunction
                            
    1              0.000001 function! s:format_git_log(line)
                              let indent = '  '
                              let tokens = split(a:line, nr2char(1))
                              if len(tokens) != 5
                                return indent.substitute(a:line, '\s*$', '', '')
                              endif
                              let [graph, sha, refs, subject, date] = tokens
                              let tag = matchstr(refs, 'tag: [^,)]\+')
                              let tag = empty(tag) ? ' ' : ' ('.tag.') '
                              return printf('%s%s%s%s%s (%s)', indent, graph, sha, tag, subject, date)
                            endfunction
                            
    1              0.000001 function! s:append_ul(lnum, text)
                              call append(a:lnum, ['', a:text, repeat('-', len(a:text))])
                            endfunction
                            
    1              0.000001 function! s:diff()
                              call s:prepare()
                              call append(0, ['Collecting changes ...', ''])
                              let cnts = [0, 0]
                              let bar = ''
                              let total = filter(copy(g:plugs), 's:is_managed(v:key) && isdirectory(v:val.dir)')
                              call s:progress_bar(2, bar, len(total))
                              for origin in [1, 0]
                                let plugs = reverse(sort(items(filter(copy(total), (origin ? '' : '!').'(has_key(v:val, "commit") || has_key(v:val, "tag"))'))))
                                if empty(plugs)
                                  continue
                                endif
                                call s:append_ul(2, origin ? 'Pending updates:' : 'Last update:')
                                for [k, v] in plugs
                                  let branch = s:git_origin_branch(v)
                                  if len(branch)
                                    let range = origin ? '..origin/'.branch : 'HEAD@{1}..'
                                    let cmd = ['git', 'log', '--graph', '--color=never']
                                    if s:git_version_requirement(2, 10, 0)
                                      call add(cmd, '--no-show-signature')
                                    endif
                                    call extend(cmd, ['--pretty=format:%x01%h%x01%d%x01%s%x01%cr', range])
                                    if has_key(v, 'rtp')
                                      call extend(cmd, ['--', v.rtp])
                                    endif
                                    let diff = s:system_chomp(cmd, v.dir)
                                    if !empty(diff)
                                      let ref = has_key(v, 'tag') ? (' (tag: '.v.tag.')') : has_key(v, 'commit') ? (' '.v.commit) : ''
                                      call append(5, extend(['', '- '.k.':'.ref], map(s:lines(diff), 's:format_git_log(v:val)')))
                                      let cnts[origin] += 1
                                    endif
                                  endif
                                  let bar .= '='
                                  call s:progress_bar(2, bar, len(total))
                                  normal! 2G
                                  redraw
                                endfor
                                if !cnts[origin]
                                  call append(5, ['', 'N/A'])
                                endif
                              endfor
                              call setline(1, printf('%d plugin(s) updated.', cnts[0])
                                    \ . (cnts[1] ? printf(' %d plugin(s) have pending updates.', cnts[1]) : ''))
                            
                              if cnts[0] || cnts[1]
                                nnoremap <silent> <buffer> <plug>(plug-preview) :silent! call <SID>preview_commit()<cr>
                                if empty(maparg("\<cr>", 'n'))
                                  nmap <buffer> <cr> <plug>(plug-preview)
                                endif
                                if empty(maparg('o', 'n'))
                                  nmap <buffer> o <plug>(plug-preview)
                                endif
                              endif
                              if cnts[0]
                                nnoremap <silent> <buffer> X :call <SID>revert()<cr>
                                echo "Press 'X' on each block to revert the update"
                              endif
                              normal! gg
                              setlocal nomodifiable
                            endfunction
                            
    1              0.000001 function! s:revert()
                              if search('^Pending updates', 'bnW')
                                return
                              endif
                            
                              let name = s:find_name(line('.'))
                              if empty(name) || !has_key(g:plugs, name) ||
                                \ input(printf('Revert the update of %s? (y/N) ', name)) !~? '^y'
                                return
                              endif
                            
                              call s:system('git reset --hard HEAD@{1} && git checkout '.plug#shellescape(g:plugs[name].branch).' --', g:plugs[name].dir)
                              setlocal modifiable
                              normal! "_dap
                              setlocal nomodifiable
                              echo 'Reverted'
                            endfunction
                            
    1              0.000001 function! s:snapshot(force, ...) abort
                              call s:prepare()
                              setf vim
                              call append(0, ['" Generated by vim-plug',
                                            \ '" '.strftime("%c"),
                                            \ '" :source this file in vim to restore the snapshot',
                                            \ '" or execute: vim -S snapshot.vim',
                                            \ '', '', 'PlugUpdate!'])
                              1
                              let anchor = line('$') - 3
                              let names = sort(keys(filter(copy(g:plugs),
                                    \'has_key(v:val, "uri") && !has_key(v:val, "commit") && isdirectory(v:val.dir)')))
                              for name in reverse(names)
                                let sha = s:git_revision(g:plugs[name].dir)
                                if !empty(sha)
                                  call append(anchor, printf("silent! let g:plugs['%s'].commit = '%s'", name, sha))
                                  redraw
                                endif
                              endfor
                            
                              if a:0 > 0
                                let fn = s:plug_expand(a:1)
                                if filereadable(fn) && !(a:force || s:ask(a:1.' already exists. Overwrite?'))
                                  return
                                endif
                                call writefile(getline(1, '$'), fn)
                                echo 'Saved as '.a:1
                                silent execute 'e' s:esc(fn)
                                setf vim
                              endif
                            endfunction
                            
    1              0.000001 function! s:split_rtp()
                              return split(&rtp, '\\\@<!,')
                            endfunction
                            
    1   0.000060   0.000014 let s:first_rtp = s:escrtp(get(s:split_rtp(), 0, ''))
    1   0.000032   0.000008 let s:last_rtp  = s:escrtp(get(s:split_rtp(), -1, ''))
                            
    1              0.000001 if exists('g:plugs')
                              let g:plugs_order = get(g:, 'plugs_order', keys(g:plugs))
                              call s:upgrade_specs()
                              call s:define_commands()
    1              0.000001 endif
                            
    1              0.000005 let &cpo = s:cpo_save
    1              0.000016 unlet s:cpo_save

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-polyglot/filetype.vim
Sourced 2 times
Total time: 6445.724576
 Self time: 6445.700121

count  total (s)   self (s)
    2              0.000756 call polyglot#init#init()

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim
Sourced 1 time
Total time:   0.024438
 Self time:   0.013503

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Adam Stankiewicz <sheerun@sher.pl>
                            " URL: https://github.com/sheerun/vim-polyglot
                            
                            " Listen very carefully, I will say this only once
    1              0.000004 if exists("did_load_polyglot")
                              finish
    1              0.000001 endif
                            
                            " Switch to compatible mode for the time being
    1              0.000005 let s:cpo_save = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000001 let did_load_polyglot = 1
                            
    1              0.000001 let g:polyglot_initialized = 0
                            
    1              0.000002 func! polyglot#init#init()
                              " A no-op as sourcing this file is enough
                            endfunc
                            
    1              0.000001 func! polyglot#init#is_disabled(caller, name, path)
                              if !g:polyglot_initialized
                                if a:path[0:7] == "autoload"
                                  let g:polyglot_initialized = 1
                            
                                  for p in globpath(&rtp, a:path, 0, 1)
                                    if p != a:caller
                                      exe "source " . p
                                    endif
                                  endfor
                                endif
                              endif
                            
                              return has_key(g:polyglot_is_disabled, a:name)
                            endfunc
                            
    1              0.000002 let g:polyglot_is_disabled = {}
    1              0.000001 let s:new_polyglot_disabled = []
                            
    1              0.000002 if exists('g:polyglot_disabled')
                              for pkg in g:polyglot_disabled
                                let base = split(pkg, '\.')
                                if len(base) > 0
                                  let g:polyglot_is_disabled[pkg] = 1
                                  call add(s:new_polyglot_disabled, base[0])
                                endif
                              endfor
    1              0.000000 else
    1              0.000001   let g:polyglot_disabled_not_set = 1
    1              0.000000 endif
                            
    1              0.000001 func! PolyglotVerify()
                              if exists("g:polyglot_disabled_not_set")
                                if exists("g:polyglot_disabled")
                                  echohl WarningMsg
                                  echo "vim-polyglot: g:polyglot_disabled should be defined before loading vim-polyglot"
                                  echohl None
                                endif
                            
                                unlet g:polyglot_disabled_not_set
                              endif
                            endfun
                            
    1              0.000005 au VimEnter * call PolyglotVerify()
                            
    1              0.000003 function! s:SetDefault(name, value)
                              if !exists(a:name)
                                let {a:name} = a:value
                              endif
                            endfunction
                            
    1   0.000014   0.000008 call s:SetDefault('g:markdown_enable_spell_checking', 0)
    1   0.000007   0.000004 call s:SetDefault('g:markdown_enable_input_abbreviations', 0)
    1   0.000006   0.000003 call s:SetDefault('g:markdown_enable_mappings', 0)
                            
                            " Enable jsx syntax by default
    1   0.000006   0.000003 call s:SetDefault('g:jsx_ext_required', 0)
                            
                            " Needed for sql highlighting
    1   0.000006   0.000003 call s:SetDefault('g:javascript_sql_dialect', 'sql')
                            
                            " Enable jsdoc highlighting by default
    1   0.000006   0.000003 call s:SetDefault('g:javascript_plugin_jsdoc', 1)
                            
                            " Make csv loading faster
    1   0.000005   0.000002 call s:SetDefault('g:csv_start', 1)
    1   0.000005   0.000002 call s:SetDefault('g:csv_end', 2)
    1   0.000005   0.000003 call s:SetDefault('g:csv_default_delim', ',')
                            
                            " Disable json concealing by default
    1   0.000006   0.000003 call s:SetDefault('g:vim_json_syntax_conceal', 0)
                            
    1   0.000005   0.000003 call s:SetDefault('g:filetype_euphoria', 'elixir')
                            
    1              0.000001 if !exists('g:python_highlight_all')
    1   0.000005   0.000003   call s:SetDefault('g:python_highlight_builtins', 1)
    1   0.000005   0.000003   call s:SetDefault('g:python_highlight_builtin_objs', 1)
    1   0.000006   0.000003   call s:SetDefault('g:python_highlight_builtin_types', 1)
    1   0.000007   0.000004   call s:SetDefault('g:python_highlight_builtin_funcs', 1)
    1   0.000006   0.000003   call s:SetDefault('g:python_highlight_builtin_funcs_kwarg', 1)
    1   0.000005   0.000003   call s:SetDefault('g:python_highlight_exceptions', 1)
    1   0.000005   0.000003   call s:SetDefault('g:python_highlight_string_formatting', 1)
    1   0.000005   0.000003   call s:SetDefault('g:python_highlight_string_format', 1)
    1   0.000005   0.000003   call s:SetDefault('g:python_highlight_string_templates', 1)
    1   0.000005   0.000003   call s:SetDefault('g:python_highlight_indent_errors', 1)
    1   0.000006   0.000003   call s:SetDefault('g:python_highlight_space_errors', 1)
    1   0.000005   0.000003   call s:SetDefault('g:python_highlight_doctests', 1)
    1   0.000006   0.000003   call s:SetDefault('g:python_highlight_func_calls', 1)
    1   0.000005   0.000003   call s:SetDefault('g:python_highlight_class_vars', 1)
    1   0.000005   0.000003   call s:SetDefault('g:python_highlight_operators', 1)
    1   0.000006   0.000003   call s:SetDefault('g:python_highlight_file_headers_as_comments', 1)
    1   0.000005   0.000003   call s:SetDefault('g:python_slow_sync', 1)
    1              0.000000 endif
                            
                            " Some variables are needed for haxe loading
                            
                            " We need it because scripts.vim in vim uses "set ft=" which cannot be
                            " overridden with setf (and we can't use set ft= so our scripts.vim work)
    1              0.000001 func! s:Setf(ft)
                              if &filetype !~# '\<'.a:ft.'\>'
                                let &filetype = a:ft
                              endif
                            endfunc
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
                            " When using this, the entry should probably be further down below with the
                            " other StarSetf() calls.
    1              0.000001 func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
    1              0.000002 augroup polyglot-observer | augroup END
                            
    1              0.000001 if exists('s:cpo_save')
                              " Restore 'cpoptions'
    1              0.000004   let &cpo = s:cpo_save
    1              0.000002   unlet s:cpo_save
    1              0.000000 endif
                            
                            " Load user-defined filetype.vim and oter plugins ftdetect first
                            " This is to use polyglot-defined ftdetect always as fallback to user settings
    1              0.000001 augroup filetypedetect
    1   0.009884   0.000727   runtime! filetype.vim
    1   0.003609   0.002750   runtime! ftdetect/*.vim
    1              0.000001 augroup END
                            
                            
    1              0.000001 augroup filetypedetect
                            
                            " Switch to compatible mode for the time being
    1              0.000006 let s:cpo_save = &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000004 if !has_key(g:polyglot_is_disabled, 'ftdetect')
                            
                            " It can happen vim filetype.vim loads first, then we need a reset
    1              0.000002 if exists("did_load_filetypes")
    1              0.000493   au! filetypedetect
    1              0.000001 endif
                            
                            " Prevent filetype.vim of vim from loading again
    1              0.000002 let did_load_filetypes = 1
                            
                            
                            " DO NOT EDIT CODE BELOW, IT IS GENERATED WITH MAKEFILE
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'org')
    1              0.000219   au BufNewFile,BufRead *.org setf org
    1              0.000001 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'mermaid')
    1              0.000006   au BufNewFile,BufRead *.mermaid,*.mm,*.mmd setf mermaid
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'openscad')
    1              0.000003   au BufNewFile,BufRead *.scad setf openscad
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'nftables')
    1              0.000005   au BufNewFile,BufRead *.nft,*/nftables.conf setf nftables
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'just')
    1              0.000004   au BufNewFile,BufRead *.just,justfile setf just
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sway')
    1              0.000009   au BufNewFile,BufRead *.sway.config,*.swayconfig,*sway/config,swayconfig setf swayconfig
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hjson')
    1              0.000003   au BufNewFile,BufRead *.hjson setf hjson
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gleam')
    1              0.000002   au BufNewFile,BufRead *.gleam setf gleam
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jsonc')
    1              0.000024   au BufNewFile,BufRead *.cjson,*.jsonc,{.,}babelrc,{.,}eslintrc.json,{.,}jshintrc,{.,}jslintrc,{.,}mocharc.json,coc-settings.json,coffeelint.json,jsconfig.json,tsconfig.json setf jsonc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mint')
    1              0.000002   au BufNewFile,BufRead *.mint setf mint
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'context')
    1              0.000005   au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi setf context
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xpm2')
    1              0.000002   au BufNewFile,BufRead *.xpm2 setf xpm2
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xpm')
    1              0.000007   au! BufNewFile,BufRead,BufWritePost *.pm call polyglot#detect#Pm()
    1              0.000003   au BufNewFile,BufRead *.xpm setf xpm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xf86conf')
    1              0.000009   au BufNewFile,BufRead */xorg.conf.d/*.conf,xorg.conf,xorg.conf-4 setf xf86conf
    1              0.000003   au BufNewFile,BufRead XF86Config-4* call s:StarSetf('xf86conf')
    1              0.000003   au BufNewFile,BufRead XF86Config* call s:StarSetf('xf86conf')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'text')
    1              0.000004   au BufNewFile,BufRead *.text,README setf text
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'svn')
    1              0.000003   au BufNewFile,BufRead svn-commit*.tmp setf svn
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'logcheck')
    1              0.000004   au BufNewFile,BufRead */etc/logcheck/*.d*/* call s:StarSetf('logcheck')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'fvwm')
    1              0.000003   au BufNewFile,BufRead */.fvwm/* call s:StarSetf('fvwm')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'crontab')
    1              0.000003   au BufNewFile,BufRead crontab setf crontab
    1              0.000003   au BufNewFile,BufRead crontab.* call s:StarSetf('crontab')
    1              0.000003   au BufNewFile,BufRead */etc/cron.d/* call s:StarSetf('crontab')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'bzr')
    1              0.000003   au BufNewFile,BufRead bzr_log.* call s:StarSetf('bzr')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'asteriskvm')
    1              0.000005   au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'asterisk')
    1              0.000003   au BufNewFile,BufRead *asterisk/*.conf* call s:StarSetf('asterisk')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'apachestyle')
    1              0.000003   au BufNewFile,BufRead proftpd.conf* call s:StarSetf('apachestyle')
    1              0.000004   au BufNewFile,BufRead */etc/proftpd/conf.*/* call s:StarSetf('apachestyle')
    1              0.000004   au BufNewFile,BufRead */etc/proftpd/*.conf* call s:StarSetf('apachestyle')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'z8a')
    1              0.000003   au BufNewFile,BufRead *.z8a setf z8a
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'zimbu')
    1              0.000002   au BufNewFile,BufRead *.zu setf zimbu
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'yacc')
    1              0.000005   au BufNewFile,BufRead *.y++,*.yxx,*.yy setf yacc
    1              0.000000 endif
                            
    1              0.000004 if !has_key(g:polyglot_is_disabled, 'xslt')
    1              0.000004   au BufNewFile,BufRead *.xsl,*.xslt setf xslt
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xsd')
    1              0.000002   au BufNewFile,BufRead *.xsd setf xsd
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xquery')
    1              0.000008   au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy setf xquery
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xmodmap')
    1              0.000003   au BufNewFile,BufRead *Xmodmap setf xmodmap
    1              0.000003   au BufNewFile,BufRead *xmodmap* call s:StarSetf('xmodmap')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xmath')
    1              0.000004   au BufNewFile,BufRead *.msc,*.msf setf xmath
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xdefaults')
    1              0.000011   au BufNewFile,BufRead *.ad,{.,}Xdefaults,{.,}Xpdefaults,{.,}Xresources,xdm-config setf xdefaults
    1              0.000003   au BufNewFile,BufRead Xresources* call s:StarSetf('xdefaults')
    1              0.000003   au BufNewFile,BufRead */app-defaults/* call s:StarSetf('xdefaults')
    1              0.000003   au BufNewFile,BufRead */Xresources/* call s:StarSetf('xdefaults')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xinetd')
    1              0.000003   au BufNewFile,BufRead */etc/xinetd.conf setf xinetd
    1              0.000003   au BufNewFile,BufRead */etc/xinetd.d/* call s:StarSetf('xinetd')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xhtml')
    1              0.000004   au BufNewFile,BufRead *.xht,*.xhtml setf xhtml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'wsh')
    1              0.000003   au BufNewFile,BufRead *.ws[fc] setf wsh
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cvs')
    1              0.000003   au BufNewFile,BufRead cvs\d\+ setf cvs
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cvsrc')
    1              0.000003   au BufNewFile,BufRead {.,}cvsrc setf cvsrc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'wvdial')
    1              0.000005   au BufNewFile,BufRead {.,}wvdialrc,wvdial.conf setf wvdial
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'wsml')
    1              0.000002   au BufNewFile,BufRead *.wsml setf wsml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'winbatch')
    1              0.000002   au BufNewFile,BufRead *.wbt setf winbatch
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'wml')
    1              0.000002   au BufNewFile,BufRead *.wml setf wml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'wget')
    1              0.000005   au BufNewFile,BufRead {.,}wgetrc,wgetrc setf wget
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'webmacro')
    1              0.000002   au BufNewFile,BufRead *.wm setf webmacro
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'wast')
    1              0.000004   au BufNewFile,BufRead *.wast,*.wat setf wast
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'vroom')
    1              0.000002   au BufNewFile,BufRead *.vroom setf vroom
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'vrml')
    1              0.000002   au BufNewFile,BufRead *.wrl setf vrml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'vgrindefs')
    1              0.000003   au BufNewFile,BufRead vgrindefs setf vgrindefs
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'viminfo')
    1              0.000005   au BufNewFile,BufRead {.,}viminfo,_viminfo setf viminfo
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'vim')
    1              0.000007   au BufNewFile,BufRead *.vba,*.vim,{.,}exrc,_exrc setf vim
    1              0.000003   au BufNewFile,BufRead *vimrc* call s:StarSetf('vim')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'vhdl')
    1              0.000008   au BufNewFile,BufRead *.hdl,*.vbe,*.vhd,*.vhdl,*.vho,*.vst setf vhdl
    1              0.000003   au BufNewFile,BufRead *.vhdl_[0-9]* call s:StarSetf('vhdl')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'systemverilog')
    1              0.000003   au BufNewFile,BufRead *.sv,*.svh setf systemverilog
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'verilogams')
    1              0.000004   au BufNewFile,BufRead *.va,*.vams setf verilogams
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'verilog')
    1              0.000002   au BufNewFile,BufRead *.v setf verilog
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'vera')
    1              0.000004   au BufNewFile,BufRead *.vr,*.vrh,*.vri setf vera
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'upstart')
    1              0.000025   au BufNewFile,BufRead */.config/upstart/*.conf,*/.config/upstart/*.override,*/.init/*.conf,*/.init/*.override,*/etc/init/*.conf,*/etc/init/*.override,*/usr/share/upstart/*.conf,*/usr/share/upstart/*.override setf upstart
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'updatedb')
    1              0.000003   au BufNewFile,BufRead */etc/updatedb.conf setf updatedb
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'uc')
    1              0.000002   au BufNewFile,BufRead *.uc setf uc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'udevperm')
    1              0.000006   au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'udevconf')
    1              0.000003   au BufNewFile,BufRead */etc/udev/udev.conf setf udevconf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'uil')
    1              0.000005   au BufNewFile,BufRead *.uil,*.uit setf uil
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tsscl')
    1              0.000002   au BufNewFile,BufRead *.tsscl setf tsscl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tssop')
    1              0.000002   au BufNewFile,BufRead *.tssop setf tssop
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tssgm')
    1              0.000002   au BufNewFile,BufRead *.tssgm setf tssgm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'trustees')
    1              0.000003   au BufNewFile,BufRead trustees.conf setf trustees
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'treetop')
    1              0.000003   au BufNewFile,BufRead *.treetop setf treetop
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tpp')
    1              0.000002   au BufNewFile,BufRead *.tpp setf tpp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tidy')
    1              0.000007   au BufNewFile,BufRead {.,}tidyrc,tidy.conf,tidyrc setf tidy
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'texmf')
    1              0.000003   au BufNewFile,BufRead texmf.cnf setf texmf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'texinfo')
    1              0.000005   au BufNewFile,BufRead *.texi,*.texinfo,*.txi setf texinfo
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tex')
    1              0.000007   au BufNewFile,BufRead *.bbl,*.dtx,*.latex,*.ltx,*.sty setf tex
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'terminfo')
    1              0.000002   au BufNewFile,BufRead *.ti setf terminfo
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'teraterm')
    1              0.000002   au BufNewFile,BufRead *.ttl setf teraterm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tsalt')
    1              0.000002   au BufNewFile,BufRead *.slt setf tsalt
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tli')
    1              0.000002   au BufNewFile,BufRead *.tli setf tli
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tcl')
    1              0.000008   au BufNewFile,BufRead *.itcl,*.itk,*.jacl,*.tcl,*.tk setf tcl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'taskedit')
    1              0.000002   au BufNewFile,BufRead *.task setf taskedit
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'taskdata')
    1              0.000005   au BufNewFile,BufRead {pending,completed,undo}.data setf taskdata
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tak')
    1              0.000002   au BufNewFile,BufRead *.tak setf tak
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tags')
    1              0.000003   au BufNewFile,BufRead tags setf tags
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sudoers')
    1              0.000005   au BufNewFile,BufRead */etc/sudoers,sudoers.tmp setf sudoers
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sdc')
    1              0.000002   au BufNewFile,BufRead *.sdc setf sdc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sysctl')
    1              0.000006   au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf setf sysctl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sil')
    1              0.000002   au BufNewFile,BufRead *.sil setf sil
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'swiftgyb')
    1              0.000003   au BufNewFile,BufRead *.swift.gyb setf swiftgyb
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'voscm')
    1              0.000002   au BufNewFile,BufRead *.cm setf voscm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sml')
    1              0.000002   au BufNewFile,BufRead *.sml setf sml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'stp')
    1              0.000002   au BufNewFile,BufRead *.stp setf stp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'smcl')
    1              0.000005   au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl setf smcl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'stata')
    1              0.000006   au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata setf stata
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sshdconfig')
    1              0.000006   au BufNewFile,BufRead */etc/ssh/sshd_config.d/*.conf,sshd_config setf sshdconfig
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sshconfig')
    1              0.000008   au BufNewFile,BufRead */.ssh/config,*/etc/ssh/ssh_config.d/*.conf,ssh_config setf sshconfig
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sqr')
    1              0.000004   au BufNewFile,BufRead *.sqi,*.sqr setf sqr
    1              0.000003 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sqlj')
    1              0.000002   au BufNewFile,BufRead *.sqlj setf sqlj
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'squid')
    1              0.000003   au BufNewFile,BufRead squid.conf setf squid
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'spice')
    1              0.000004   au BufNewFile,BufRead *.sp,*.spice setf spice
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'slice')
    1              0.000002   au BufNewFile,BufRead *.ice setf slice
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'spup')
    1              0.000006   au BufNewFile,BufRead *.spd,*.spdata,*.speedup setf spup
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hog')
    1              0.000006   au BufNewFile,BufRead *.hog,snort.conf,vision.conf setf hog
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mib')
    1              0.000003   au BufNewFile,BufRead *.mib,*.my setf mib
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'snobol4')
    1              0.000003   au BufNewFile,BufRead *.sno,*.spt setf snobol4
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'smith')
    1              0.000004   au BufNewFile,BufRead *.smith,*.smt setf smith
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'st')
    1              0.000002   au BufNewFile,BufRead *.st setf st
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'slrnsc')
    1              0.000002   au BufNewFile,BufRead *.score setf slrnsc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'slrnrc')
    1              0.000003   au BufNewFile,BufRead {.,}slrnrc setf slrnrc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'skill')
    1              0.000005   au BufNewFile,BufRead *.cdf,*.il,*.ils setf skill
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sisu')
    1              0.000013   au BufNewFile,BufRead *.-sst,*.-sst.meta,*._sst,*._sst.meta,*.ssi,*.ssm,*.sst,*.sst.meta setf sisu
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sinda')
    1              0.000004   au BufNewFile,BufRead *.s85,*.sin setf sinda
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'simula')
    1              0.000002   au BufNewFile,BufRead *.sim setf simula
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'screen')
    1              0.000005   au BufNewFile,BufRead {.,}screenrc,screenrc setf screen
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'scheme')
    1              0.000003   au BufNewFile,BufRead *.scm,*.ss setf scheme
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'catalog')
    1              0.000003   au BufNewFile,BufRead catalog setf catalog
    1              0.000003   au BufNewFile,BufRead sgml.catalog* call s:StarSetf('catalog')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'setserial')
    1              0.000003   au BufNewFile,BufRead */etc/serial.conf setf setserial
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'slpspi')
    1              0.000003   au BufNewFile,BufRead */etc/slp.spi setf slpspi
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'spyce')
    1              0.000004   au BufNewFile,BufRead *.spi,*.spy setf spyce
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'slpreg')
    1              0.000003   au BufNewFile,BufRead */etc/slp.reg setf slpreg
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'slpconf')
    1              0.000003   au BufNewFile,BufRead */etc/slp.conf setf slpconf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'services')
    1              0.000003   au BufNewFile,BufRead */etc/services setf services
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sm')
    1              0.000003   au BufNewFile,BufRead sendmail.cf setf sm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sieve')
    1              0.000004   au BufNewFile,BufRead *.sieve,*.siv setf sieve
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sdl')
    1              0.000004   au BufNewFile,BufRead *.pr,*.sdl setf sdl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sd')
    1              0.000002   au BufNewFile,BufRead *.sd setf sd
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'scilab')
    1              0.000003   au BufNewFile,BufRead *.sce,*.sci setf scilab
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sbt')
    1              0.000002   au BufNewFile,BufRead *.sbt setf sbt
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sather')
    1              0.000002   au BufNewFile,BufRead *.sa setf sather
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sass')
    1              0.000002   au BufNewFile,BufRead *.sass setf sass
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sas')
    1              0.000002   au BufNewFile,BufRead *.sas setf sas
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'samba')
    1              0.000003   au BufNewFile,BufRead smb.conf setf samba
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'slang')
    1              0.000002   au BufNewFile,BufRead *.sl setf slang
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rtf')
    1              0.000002   au BufNewFile,BufRead *.rtf setf rtf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rpcgen')
    1              0.000002   au BufNewFile,BufRead *.x setf rpcgen
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'robots')
    1              0.000003   au BufNewFile,BufRead robots.txt setf robots
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rpl')
    1              0.000002   au BufNewFile,BufRead *.rpl setf rpl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rng')
    1              0.000002   au BufNewFile,BufRead *.rng setf rng
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rnc')
    1              0.000002   au BufNewFile,BufRead *.rnc setf rnc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'resolv')
    1              0.000003   au BufNewFile,BufRead resolv.conf setf resolv
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'remind')
    1              0.000006   au BufNewFile,BufRead *.rem,*.remind,{.,}reminders setf remind
    1              0.000003   au BufNewFile,BufRead .reminders* call s:StarSetf('remind')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rrst')
    1              0.000004   au BufNewFile,BufRead *.rrst,*.srst setf rrst
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rmd')
    1              0.000004   au BufNewFile,BufRead *.rmd,*.smd setf rmd
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rnoweb')
    1              0.000003   au BufNewFile,BufRead *.rnw,*.snw setf rnoweb
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'rexx')
    1              0.000014   au BufNewFile,BufRead *.jrexx,*.orx,*.rex,*.rexx,*.rexxj,*.rxj,*.rxo,*.testGroup,*.testUnit setf rexx
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rego')
    1              0.000002   au BufNewFile,BufRead *.rego setf rego
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rib')
    1              0.000002   au BufNewFile,BufRead *.rib setf rib
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'readline')
    1              0.000005   au BufNewFile,BufRead {.,}inputrc,inputrc setf readline
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rcs')
    1              0.000002   au BufNewFile,BufRead *\,v setf rcs
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ratpoison')
    1              0.000006   au BufNewFile,BufRead {.,}ratpoisonrc,ratpoisonrc setf ratpoison
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'radiance')
    1              0.000003   au BufNewFile,BufRead *.mat,*.rad setf radiance
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pyrex')
    1              0.000003   au BufNewFile,BufRead *.pxd,*.pyx setf pyrex
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'protocols')
    1              0.000003   au BufNewFile,BufRead */etc/protocols setf protocols
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'promela')
    1              0.000002   au BufNewFile,BufRead *.pml setf promela
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'psf')
    1              0.000002   au BufNewFile,BufRead *.psf setf psf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'procmail')
    1              0.000005   au BufNewFile,BufRead {.,}procmail,{.,}procmailrc setf procmail
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'privoxy')
    1              0.000003   au BufNewFile,BufRead *.action setf privoxy
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'obj')
    1              0.000002   au BufNewFile,BufRead *.obj setf obj
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ppwiz')
    1              0.000003   au BufNewFile,BufRead *.ih,*.it setf ppwiz
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pccts')
    1              0.000002   au BufNewFile,BufRead *.g setf pccts
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'povini')
    1              0.000003   au BufNewFile,BufRead {.,}povrayrc setf povini
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pov')
    1              0.000002   au BufNewFile,BufRead *.pov setf pov
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ppd')
    1              0.000002   au BufNewFile,BufRead *.ppd setf ppd
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'postscr')
    1              0.000010   au BufNewFile,BufRead *.afm,*.ai,*.eps,*.epsf,*.epsi,*.pfa,*.ps setf postscr
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pfmain')
    1              0.000003   au BufNewFile,BufRead main.cf setf pfmain
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'po')
    1              0.000003   au BufNewFile,BufRead *.po,*.pot setf po
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'plp')
    1              0.000002   au BufNewFile,BufRead *.plp setf plp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'plsql')
    1              0.000004   au BufNewFile,BufRead *.pls,*.plsql setf plsql
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'plm')
    1              0.000005   au BufNewFile,BufRead *.p36,*.pac,*.plm setf plm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pli')
    1              0.000003   au BufNewFile,BufRead *.pl1,*.pli setf pli
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pine')
    1              0.000008   au BufNewFile,BufRead {.,}pinerc,{.,}pinercex,pinerc,pinercex setf pine
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pilrc')
    1              0.000002   au BufNewFile,BufRead *.rcp setf pilrc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pinfo')
    1              0.000005   au BufNewFile,BufRead */.pinforc,*/etc/pinforc setf pinfo
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cmod')
    1              0.000002   au BufNewFile,BufRead *.cmod setf cmod
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pike')
    1              0.000004   au BufNewFile,BufRead *.pike,*.pmod setf pike
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pdf')
    1              0.000002   au BufNewFile,BufRead *.pdf setf pdf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pascal')
    1              0.000006   au BufNewFile,BufRead *.dpr,*.lpr,*.pas,*.pp setf pascal
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'passwd')
    1              0.000019   au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'papp')
    1              0.000005   au BufNewFile,BufRead *.papp,*.pxml,*.pxsl setf papp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pamenv')
    1              0.000006   au BufNewFile,BufRead {.,}pam_environment,pam_env.conf setf pamenv
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pamconf')
    1              0.000003   au BufNewFile,BufRead */etc/pam.conf setf pamconf
    1              0.000003   au BufNewFile,BufRead */etc/pam.d/* call s:StarSetf('pamconf')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pf')
    1              0.000003   au BufNewFile,BufRead pf.conf setf pf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ora')
    1              0.000003   au BufNewFile,BufRead *.ora setf ora
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'opl')
    1              0.000003   au BufNewFile,BufRead *.[Oo][Pp][Ll] setf opl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'openroad')
    1              0.000002   au BufNewFile,BufRead *.or setf openroad
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'omnimark')
    1              0.000004   au BufNewFile,BufRead *.xin,*.xom setf omnimark
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'occam')
    1              0.000002   au BufNewFile,BufRead *.occ setf occam
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'nsis')
    1              0.000003   au BufNewFile,BufRead *.nsh,*.nsi setf nsis
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'nqc')
    1              0.000002   au BufNewFile,BufRead *.nqc setf nqc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'nroff')
    1              0.000026   au BufNewFile,BufRead *.1,*.1in,*.1m,*.1x,*.2,*.3,*.3in,*.3m,*.3p,*.3pm,*.3qt,*.3x,*.4,*.5,*.6,*.7,*.8,*.9,*.man,*.mdoc setf nroff
    1              0.000020   au BufNewFile,BufRead *.mom,*.nr,*.roff,*.tmac,*.tr setf nroff
    1              0.000005   au BufNewFile,BufRead tmac.* call s:StarSetf('nroff')
    1              0.000001 endif
                            
    1              0.000003 if !has_key(g:polyglot_is_disabled, 'ncf')
    1              0.000003   au BufNewFile,BufRead *.ncf setf ncf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ninja')
    1              0.000002   au BufNewFile,BufRead *.ninja setf ninja
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'netrc')
    1              0.000003   au BufNewFile,BufRead {.,}netrc setf netrc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'neomuttrc')
    1              0.000003   au BufNewFile,BufRead Neomuttrc setf neomuttrc
    1              0.000003   au BufNewFile,BufRead neomuttrc* call s:StarSetf('neomuttrc')
    1              0.000003   au BufNewFile,BufRead Neomuttrc* call s:StarSetf('neomuttrc')
    1              0.000003   au BufNewFile,BufRead .neomuttrc* call s:StarSetf('neomuttrc')
    1              0.000004   au BufNewFile,BufRead */.neomutt/neomuttrc* call s:StarSetf('neomuttrc')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'natural')
    1              0.000003   au BufNewFile,BufRead *.NS[ACGLMNPS] setf natural
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'nanorc')
    1              0.000005   au BufNewFile,BufRead *.nanorc,*/etc/nanorc setf nanorc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'n1ql')
    1              0.000004   au BufNewFile,BufRead *.n1ql,*.nql setf n1ql
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mush')
    1              0.000002   au BufNewFile,BufRead *.mush setf mush
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mupad')
    1              0.000002   au BufNewFile,BufRead *.mu setf mupad
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'muttrc')
    1              0.000003   au BufNewFile,BufRead Mutt{ng,}rc setf muttrc
    1              0.000003   au BufNewFile,BufRead mutt{ng,}rc* call s:StarSetf('muttrc')
    1              0.000003   au BufNewFile,BufRead Mutt{ng,}rc* call s:StarSetf('muttrc')
    1              0.000003   au BufNewFile,BufRead .mutt{ng,}rc* call s:StarSetf('muttrc')
    1              0.000003   au BufNewFile,BufRead */etc/Muttrc.d/* call s:StarSetf('muttrc')
    1              0.000004   au BufNewFile,BufRead */.mutt{ng,}/mutt{ng,}rc* call s:StarSetf('muttrc')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'msql')
    1              0.000002   au BufNewFile,BufRead *.msql setf msql
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mrxvtrc')
    1              0.000005   au BufNewFile,BufRead {.,}mrxvtrc,mrxvtrc setf mrxvtrc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'srec')
    1              0.000008   au BufNewFile,BufRead *.mot,*.s19,*.s28,*.s37,*.srec setf srec
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mplayerconf')
    1              0.000005   au BufNewFile,BufRead */.mplayer/config,mplayer.conf setf mplayerconf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'modconf')
    1              0.000008   au BufNewFile,BufRead */etc/conf.modules,*/etc/modules,*/etc/modules.conf setf modconf
    1              0.000003   au BufNewFile,BufRead */etc/modprobe.* call s:StarSetf('modconf')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'moo')
    1              0.000002   au BufNewFile,BufRead *.moo setf moo
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'monk')
    1              0.000006   au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc setf monk
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'modula3')
    1              0.000003   au BufNewFile,BufRead *.[mi][3g] setf modula3
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'modula2')
    1              0.000006   au BufNewFile,BufRead *.DEF,*.MOD,*.m2,*.mi setf modula2
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mmp')
    1              0.000002   au BufNewFile,BufRead *.mmp setf mmp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mix')
    1              0.000004   au BufNewFile,BufRead *.mix,*.mixal setf mix
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mgl')
    1              0.000002   au BufNewFile,BufRead *.mgl setf mgl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mp')
    1              0.000002   au BufNewFile,BufRead *.mp setf mp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mf')
    1              0.000002   au BufNewFile,BufRead *.mf setf mf
    1              0.000000 endif
                            
    1              0.000003 if !has_key(g:polyglot_is_disabled, 'messages')
    1              0.000015   au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hgcommit')
    1              0.000004   au BufNewFile,BufRead hg-editor-*.txt setf hgcommit
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mel')
    1              0.000002   au BufNewFile,BufRead *.mel setf mel
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'maple')
    1              0.000005   au BufNewFile,BufRead *.mpl,*.mv,*.mws setf maple
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'manconf')
    1              0.000005   au BufNewFile,BufRead */etc/man.conf,man.config setf manconf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mallard')
    1              0.000003   au BufNewFile,BufRead *.page setf mallard
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ist')
    1              0.000004   au BufNewFile,BufRead *.ist,*.mst setf ist
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mailcap')
    1              0.000005   au BufNewFile,BufRead {.,}mailcap,mailcap setf mailcap
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mailaliases')
    1              0.000005   au BufNewFile,BufRead */etc/aliases,*/etc/mail/aliases setf mailaliases
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mail')
    1              0.000045   au BufNewFile,BufRead *.eml,{.,}article,{.,}article.\d\+,{.,}followup,{.,}letter,{.,}letter.\d\+,/tmp/SLRN[0-9A-Z.]\+,ae\d\+.txt,mutt[[:alnum:]_-]\\\{6\},mutt{ng,}-*-\w\+,neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},pico.\d\+,snd.\d\+,{neo,}mutt[[:alnum:]._-]\\\{6\} setf mail
    1              0.000003   au BufNewFile,BufRead reportbug-* call s:StarSetf('mail')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mgp')
    1              0.000002   au BufNewFile,BufRead *.mgp setf mgp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lss')
    1              0.000002   au BufNewFile,BufRead *.lss setf lss
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lsl')
    1              0.000004   au BufNewFile,BufRead *.lsl setf lsl
    1              0.000002 endif
                            
    1              0.000004 if !has_key(g:polyglot_is_disabled, 'lout')
    1              0.000008   au BufNewFile,BufRead *.lou,*.lout setf lout
    1              0.000001 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'lotos')
    1              0.000007   au BufNewFile,BufRead *.lot,*.lotos setf lotos
    1              0.000001 endif
                            
    1              0.000003 if !has_key(g:polyglot_is_disabled, 'logtalk')
    1              0.000005   au BufNewFile,BufRead *.lgt setf logtalk
    1              0.000001 endif
                            
    1              0.000003 if !has_key(g:polyglot_is_disabled, 'logindefs')
    1              0.000004   au BufNewFile,BufRead */etc/login.defs setf logindefs
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'loginaccess')
    1              0.000004   au BufNewFile,BufRead */etc/login.access setf loginaccess
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'litestep')
    1              0.000004   au BufNewFile,BufRead */LiteStep/*/*.rc setf litestep
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lite')
    1              0.000004   au BufNewFile,BufRead *.lite,*.lt setf lite
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'liquid')
    1              0.000003   au BufNewFile,BufRead *.liquid setf liquid
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lisp')
    1              0.000015   au BufNewFile,BufRead *.cl,*.el,*.lisp,*.lsp,{.,}emacs,{.,}sawfishrc,{.,}sbclrc,sbclrc setf lisp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lilo')
    1              0.000003   au BufNewFile,BufRead lilo.conf setf lilo
    1              0.000003   au BufNewFile,BufRead lilo.conf* call s:StarSetf('lilo')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lifelines')
    1              0.000002   au BufNewFile,BufRead *.ll setf lifelines
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lftp')
    1              0.000006   au BufNewFile,BufRead *lftp/rc,{.,}lftprc,lftp.conf setf lftp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sensors')
    1              0.000006   au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf setf sensors
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'libao')
    1              0.000005   au BufNewFile,BufRead */.libao,*/etc/libao.conf setf libao
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lex')
    1              0.000006   au BufNewFile,BufRead *.l,*.l++,*.lex,*.lxx setf lex
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ld')
    1              0.000002   au BufNewFile,BufRead *.ld setf ld
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ldif')
    1              0.000002   au BufNewFile,BufRead *.ldif setf ldif
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lprolog')
    1              0.000002   au BufNewFile,BufRead *.sig setf lprolog
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'limits')
    1              0.000055   au BufNewFile,BufRead */etc/*limits.conf,*/etc/*limits.d/*.conf,*/etc/limits setf limits
    1              0.000001 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'latte')
    1              0.000004   au BufNewFile,BufRead *.latte,*.lte setf latte
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lace')
    1              0.000004   au BufNewFile,BufRead *.ACE,*.ace setf lace
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'kconfig')
    1              0.000007   au BufNewFile,BufRead Kconfig,Kconfig.debug setf kconfig
    1              0.000003   au BufNewFile,BufRead Kconfig.* call s:StarSetf('kconfig')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'kscript')
    1              0.000002   au BufNewFile,BufRead *.ks setf kscript
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'kivy')
    1              0.000002   au BufNewFile,BufRead *.kv setf kivy
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'kwt')
    1              0.000002   au BufNewFile,BufRead *.k setf kwt
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'kix')
    1              0.000002   au BufNewFile,BufRead *.kix setf kix
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jovial')
    1              0.000006   au BufNewFile,BufRead *.j73,*.jov,*.jovial setf jovial
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jgraph')
    1              0.000002   au BufNewFile,BufRead *.jgr setf jgraph
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jess')
    1              0.000002   au BufNewFile,BufRead *.clp setf jess
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jproperties')
    1              0.000008   au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_?? setf jproperties
    1              0.000003   au BufNewFile,BufRead *.properties_??_??_* call s:StarSetf('jproperties')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jsp')
    1              0.000002   au BufNewFile,BufRead *.jsp setf jsp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'javacc')
    1              0.000004   au BufNewFile,BufRead *.jj,*.jjt setf javacc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'java')
    1              0.000003   au BufNewFile,BufRead *.jav,*.java setf java
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jam')
    1              0.000004   au BufNewFile,BufRead *.jpl,*.jpr setf jam
    1              0.000003   au BufNewFile,BufRead Prl*.* call s:StarSetf('jam')
    1              0.000002   au BufNewFile,BufRead JAM*.* call s:StarSetf('jam')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jal')
    1              0.000003   au BufNewFile,BufRead *.JAL,*.jal setf jal
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'j')
    1              0.000002   au BufNewFile,BufRead *.ijs setf j
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'iss')
    1              0.000002   au BufNewFile,BufRead *.iss setf iss
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'inittab')
    1              0.000003   au BufNewFile,BufRead inittab setf inittab
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'fgl')
    1              0.000005   au BufNewFile,BufRead *.4gh,*.4gl,*.m4gl setf fgl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ipfilter')
    1              0.000007   au BufNewFile,BufRead ipf.conf,ipf.rules,ipf6.conf setf ipfilter
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'usw2kagtlog')
    1              0.000008   au BufNewFile,BufRead *.usw2kagt.log\c,usw2kagt.*.log\c,usw2kagt.log\c setf usw2kagtlog
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'usserverlog')
    1              0.000007   au BufNewFile,BufRead *.usserver.log\c,usserver.*.log\c,usserver.log\c setf usserverlog
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'upstreaminstalllog')
    1              0.000009   au BufNewFile,BufRead *.upstreaminstall.log\c,upstreaminstall.*.log\c,upstreaminstall.log\c setf upstreaminstalllog
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'upstreamlog')
    1              0.000012   au BufNewFile,BufRead *.upstream.log\c,UPSTREAM-*.log\c,fdrupstream.log,upstream.*.log\c,upstream.log\c setf upstreamlog
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'upstreamdat')
    1              0.000007   au BufNewFile,BufRead *.upstream.dat\c,upstream.*.dat\c,upstream.dat\c setf upstreamdat
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'initng')
    1              0.000005   au BufNewFile,BufRead *.ii,*/etc/initng/*/*.i setf initng
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'inform')
    1              0.000004   au BufNewFile,BufRead *.INF,*.inf setf inform
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'indent')
    1              0.000005   au BufNewFile,BufRead {.,}indent.pro,indentrc setf indent
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'icemenu')
    1              0.000003   au BufNewFile,BufRead */.icewm/menu setf icemenu
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'msidl')
    1              0.000003   au BufNewFile,BufRead *.mof,*.odl setf msidl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'icon')
    1              0.000002   au BufNewFile,BufRead *.icn setf icon
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hb')
    1              0.000002   au BufNewFile,BufRead *.hb setf hb
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hostsaccess')
    1              0.000005   au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny setf hostsaccess
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hostconf')
    1              0.000003   au BufNewFile,BufRead */etc/host.conf setf hostconf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'template')
    1              0.000002   au BufNewFile,BufRead *.tmpl setf template
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'htmlm4')
    1              0.000003   au BufNewFile,BufRead *.html.m4 setf htmlm4
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tilde')
    1              0.000002   au BufNewFile,BufRead *.t.html setf tilde
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hollywood')
    1              0.000002   au BufNewFile,BufRead *.hws setf hollywood
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hex')
    1              0.000004   au BufNewFile,BufRead *.h32,*.hex setf hex
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hercules')
    1              0.000007   au BufNewFile,BufRead *.errsum,*.ev,*.sum,*.vc setf hercules
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hastepreproc')
    1              0.000002   au BufNewFile,BufRead *.htpp setf hastepreproc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'haste')
    1              0.000002   au BufNewFile,BufRead *.ht setf haste
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'chaskell')
    1              0.000002   au BufNewFile,BufRead *.chs setf chaskell
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lhaskell')
    1              0.000002   au BufNewFile,BufRead *.lhs setf lhaskell
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gtkrc')
    1              0.000004   au BufNewFile,BufRead {.,}gtkrc,gtkrc setf gtkrc
    1              0.000003   au BufNewFile,BufRead gtkrc* call s:StarSetf('gtkrc')
    1              0.000003   au BufNewFile,BufRead .gtkrc* call s:StarSetf('gtkrc')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'group')
    1              0.000020   au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak setf group
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gsp')
    1              0.000003   au BufNewFile,BufRead *.gsp setf gsp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gretl')
    1              0.000002   au BufNewFile,BufRead *.gretl setf gretl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'grads')
    1              0.000002   au BufNewFile,BufRead *.gs setf grads
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gitolite')
    1              0.000003   au BufNewFile,BufRead gitolite.conf setf gitolite
    1              0.000004   au BufNewFile,BufRead */gitolite-admin/conf/* call s:StarSetf('gitolite')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gnash')
    1              0.000009   au BufNewFile,BufRead {.,}gnashpluginrc,{.,}gnashrc,gnashpluginrc,gnashrc setf gnash
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gpg')
    1              0.000009   au BufNewFile,BufRead */.gnupg/gpg.conf,*/.gnupg/options,*/usr/*/gnupg/options.skel setf gpg
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gp')
    1              0.000004   au BufNewFile,BufRead *.gp,{.,}gprc setf gp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gkrellmrc')
    1              0.000005   au BufNewFile,BufRead gkrellmrc,gkrellmrc_? setf gkrellmrc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gedcom')
    1              0.000004   au BufNewFile,BufRead *.ged,lltxxxxx.txt setf gedcom
    1              0.000003   au BufNewFile,BufRead */tmp/lltmp* call s:StarSetf('gedcom')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gdmo')
    1              0.000004   au BufNewFile,BufRead *.gdmo,*.mo setf gdmo
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gdb')
    1              0.000003   au BufNewFile,BufRead {.,}gdbinit setf gdb
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'fstab')
    1              0.000004   au BufNewFile,BufRead fstab,mtab setf fstab
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'framescript')
    1              0.000002   au BufNewFile,BufRead *.fsl setf framescript
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'fortran')
    1              0.000014   au BufNewFile,BufRead *.f,*.f03,*.f08,*.f77,*.f90,*.f95,*.for,*.fortran,*.fpp,*.ftn setf fortran
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'reva')
    1              0.000002   au BufNewFile,BufRead *.frt setf reva
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'focexec')
    1              0.000004   au BufNewFile,BufRead *.fex,*.focexec setf focexec
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'fetchmail')
    1              0.000004   au BufNewFile,BufRead {.,}fetchmailrc setf fetchmail
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'fan')
    1              0.000003   au BufNewFile,BufRead *.fan,*.fwt setf fan
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'falcon')
    1              0.000002   au BufNewFile,BufRead *.fal setf falcon
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'exports')
    1              0.000003   au BufNewFile,BufRead exports setf exports
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'expect')
    1              0.000002   au BufNewFile,BufRead *.exp setf expect
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'exim')
    1              0.000003   au BufNewFile,BufRead exim.conf setf exim
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'csc')
    1              0.000002   au BufNewFile,BufRead *.csc setf csc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'esterel')
    1              0.000002   au BufNewFile,BufRead *.strl setf esterel
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'esqlc')
    1              0.000003   au BufNewFile,BufRead *.EC,*.ec setf esqlc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'esmtprc')
    1              0.000002   au BufNewFile,BufRead *esmtprc setf esmtprc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'elmfilt')
    1              0.000003   au BufNewFile,BufRead filter-rules setf elmfilt
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'elinks')
    1              0.000003   au BufNewFile,BufRead elinks.conf setf elinks
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ecd')
    1              0.000002   au BufNewFile,BufRead *.ecd setf ecd
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'edif')
    1              0.000003   au BufNewFile,BufRead *.ed\(f\|if\|o\) setf edif
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dts')
    1              0.000003   au BufNewFile,BufRead *.dts,*.dtsi setf dts
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dtd')
    1              0.000002   au BufNewFile,BufRead *.dtd setf dtd
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dsl')
    1              0.000002   au BufNewFile,BufRead *.dsl setf dsl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'datascript')
    1              0.000002   au BufNewFile,BufRead *.ds setf datascript
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dracula')
    1              0.000006   au BufNewFile,BufRead *.drac,*.drc,*lpe,*lvs setf dracula
    1              0.000002   au BufNewFile,BufRead drac.* call s:StarSetf('dracula')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'def')
    1              0.000002   au BufNewFile,BufRead *.def setf def
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dylan')
    1              0.000002   au BufNewFile,BufRead *.dylan setf dylan
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dylanintr')
    1              0.000002   au BufNewFile,BufRead *.intr setf dylanintr
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dylanlid')
    1              0.000002   au BufNewFile,BufRead *.lid setf dylanlid
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dot')
    1              0.000004   au BufNewFile,BufRead *.dot,*.gv setf dot
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dircolors')
    1              0.000008   au BufNewFile,BufRead */etc/DIR_COLORS,{.,}dir_colors,{.,}dircolors setf dircolors
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'diff')
    1              0.000003   au BufNewFile,BufRead *.diff,*.rej setf diff
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dictdconf')
    1              0.000003   au BufNewFile,BufRead dictd.conf setf dictdconf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dictconf')
    1              0.000004   au BufNewFile,BufRead {.,}dictrc,dict.conf setf dictconf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'desktop')
    1              0.000004   au BufNewFile,BufRead *.desktop,*.directory setf desktop
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'desc')
    1              0.000002   au BufNewFile,BufRead *.desc setf desc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dnsmasq')
    1              0.000003   au BufNewFile,BufRead */etc/dnsmasq.conf setf dnsmasq
    1              0.000003   au BufNewFile,BufRead */etc/dnsmasq.d/* call s:StarSetf('dnsmasq')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'denyhosts')
    1              0.000003   au BufNewFile,BufRead denyhosts.conf setf denyhosts
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'debsources')
    1              0.000007   au BufNewFile,BufRead */etc/apt/sources.list,*/etc/apt/sources.list.d/*.list setf debsources
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'debcopyright')
    1              0.000003   au BufNewFile,BufRead */debian/copyright setf debcopyright
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'debcontrol')
    1              0.000003   au BufNewFile,BufRead */debian/control setf debcontrol
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cuplsim')
    1              0.000002   au BufNewFile,BufRead *.si setf cuplsim
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cupl')
    1              0.000002   au BufNewFile,BufRead *.pld setf cupl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'csp')
    1              0.000003   au BufNewFile,BufRead *.csp,*.fdr setf csp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'quake')
    1              0.000008   au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg,*quake[1-3]/*.cfg setf quake
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lynx')
    1              0.000003   au BufNewFile,BufRead lynx.cfg setf lynx
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'eterm')
    1              0.000003   au BufNewFile,BufRead *Eterm/*.cfg setf eterm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dcd')
    1              0.000002   au BufNewFile,BufRead *.dcd setf dcd
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dockerfile')
    1              0.000010   au BufNewFile,BufRead *.Dockerfile,*.dock,Containerfile,Dockerfile,dockerfile setf dockerfile
    1              0.000003   au BufNewFile,BufRead Dockerfile* call s:StarSetf('dockerfile')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cuda')
    1              0.000004   au BufNewFile,BufRead *.cu,*.cuh setf cuda
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'config')
    1              0.000006   au BufNewFile,BufRead Pipfile,configure.ac,configure.in setf config
    1              0.000003   au BufNewFile,BufRead /etc/hostname.* call s:StarSetf('config')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cf')
    1              0.000005   au BufNewFile,BufRead *.cfc,*.cfi,*.cfm setf cf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'coco')
    1              0.000002   au BufNewFile,BufRead *.atg setf coco
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'cobol')
    1              0.000004   au BufNewFile,BufRead *.cbl,*.cob,*.lib setf cobol
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cmusrc')
    1              0.000010   au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme},*/cmus/{rc,*.theme} setf cmusrc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cl')
    1              0.000002   au BufNewFile,BufRead *.eni setf cl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'clean')
    1              0.000004   au BufNewFile,BufRead *.dcl,*.icl setf clean
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'chordpro')
    1              0.000009   au BufNewFile,BufRead *.cho,*.chopro,*.chordpro,*.crd,*.crdpro setf chordpro
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'chill')
    1              0.000002   au BufNewFile,BufRead *..ch setf chill
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'debchangelog')
    1              0.000012   au BufNewFile,BufRead */debian/changelog,NEWS.Debian,NEWS.dch,changelog.Debian,changelog.dch setf debchangelog
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cterm')
    1              0.000002   au BufNewFile,BufRead *.con setf cterm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'css')
    1              0.000002   au BufNewFile,BufRead *.css setf css
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ch')
    1              0.000002   au BufNewFile,BufRead *.chf setf ch
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cynpp')
    1              0.000002   au BufNewFile,BufRead *.cyn setf cynpp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'crm')
    1              0.000002   au BufNewFile,BufRead *.crm setf crm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'conaryrecipe')
    1              0.000002   au BufNewFile,BufRead *.recipe setf conaryrecipe
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cdl')
    1              0.000002   au BufNewFile,BufRead *.cdl setf cdl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'chaiscript')
    1              0.000002   au BufNewFile,BufRead *.chai setf chaiscript
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cdrdaoconf')
    1              0.000011   au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/default/cdrdao,*/etc/defaults/cdrdao,{.,}cdrdao setf cdrdaoconf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cdrtoc')
    1              0.000002   au BufNewFile,BufRead *.toc setf cdrtoc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cabal')
    1              0.000002   au BufNewFile,BufRead *.cabal setf cabal
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'csdl')
    1              0.000002   au BufNewFile,BufRead *.csdl setf csdl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cs')
    1              0.000002   au BufNewFile,BufRead *.cs setf cs
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'calendar')
    1              0.000003   au BufNewFile,BufRead calendar setf calendar
    1              0.000004   au BufNewFile,BufRead */share/calendar/calendar.* call s:StarSetf('calendar')
    1              0.000005   au BufNewFile,BufRead */share/calendar/*/calendar.* call s:StarSetf('calendar')
    1              0.000003   au BufNewFile,BufRead */.calendar/* call s:StarSetf('calendar')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lpc')
    1              0.000004   au BufNewFile,BufRead *.lpc,*.ulpc setf lpc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'bsdl')
    1              0.000004   au BufNewFile,BufRead *.bsdl,*bsd setf bsdl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'blank')
    1              0.000002   au BufNewFile,BufRead *.bl setf blank
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'bindzone')
    1              0.000003   au BufNewFile,BufRead named.root setf bindzone
    1              0.000003   au BufNewFile,BufRead */named/db.* call s:StarSetf('bindzone')
    1              0.000003   au BufNewFile,BufRead */bind/db.* call s:StarSetf('bindzone')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'named')
    1              0.000008   au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key setf named
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'bst')
    1              0.000002   au BufNewFile,BufRead *.bst setf bst
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'bib')
    1              0.000002   au BufNewFile,BufRead *.bib setf bib
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'bdf')
    1              0.000002   au BufNewFile,BufRead *.bdf setf bdf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'bc')
    1              0.000002   au BufNewFile,BufRead *.bc setf bc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dosbatch')
    1              0.000003   au BufNewFile,BufRead *.bat,*.sys setf dosbatch
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hamster')
    1              0.000003   au BufNewFile,BufRead *.hsc,*.hsm setf hamster
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'freebasic')
    1              0.000003   au BufNewFile,BufRead *.bi,*.fb setf freebasic
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ibasic')
    1              0.000003   au BufNewFile,BufRead *.iba,*.ibi setf ibasic
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'b')
    1              0.000004   au BufNewFile,BufRead *.imp,*.mch,*.ref setf b
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sql')
    1              0.000024   au BufNewFile,BufRead *.bdy,*.ddl,*.fnc,*.pck,*.pkb,*.pks,*.plb,*.pls,*.plsql,*.prc,*.spc,*.sql,*.tpb,*.tps,*.trg,*.tyb,*.tyc,*.typ,*.vw setf sql
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gitignore')
    1              0.000008   au BufNewFile,BufRead *.git/info/exclude,*/.config/git/ignore,{.,}gitignore setf gitignore
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'prolog')
    1              0.000044   au! BufNewFile,BufRead,BufWritePost *.pl call polyglot#detect#Pl()
    1              0.000006   au BufNewFile,BufRead *.pdb,*.pro,*.prolog,*.yap setf prolog
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'bzl')
    1              0.000014   au BufNewFile,BufRead *.BUILD,*.bazel,*.bzl,BUCK,BUILD,BUILD.bazel,Tiltfile,WORKSPACE setf bzl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'odin')
    1              0.000002   au BufNewFile,BufRead *.odin setf odin
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dosini')
    1              0.000023   au BufNewFile,BufRead *.dof,*.ini,*.lektorproject,*.prefs,*.pro,*.properties,*/etc/pacman.conf,*/etc/yum.conf,{.,}editorconfig,{.,}flake8,{.,}npmrc,buildozer.spec setf dosini
    1              0.000003   au BufNewFile,BufRead php.ini-* call s:StarSetf('dosini')
    1              0.000004   au BufNewFile,BufRead */etc/yum.repos.d/* call s:StarSetf('dosini')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'spec')
    1              0.000002   au BufNewFile,BufRead *.spec setf spec
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'visual-basic')
    1              0.000031   au! BufNewFile,BufRead,BufWritePost *.bas call polyglot#detect#Bas()
    1              0.000011   au BufNewFile,BufRead *.cls,*.ctl,*.dsm,*.frm,*.frx,*.sba,*.vba,*.vbs setf vb
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'basic')
    1              0.000003   au BufNewFile,BufRead *.basic setf basic
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'trasys')
    1              0.000026   au! BufNewFile,BufRead,BufWritePost *.inp call polyglot#detect#Inp()
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'zig')
    1              0.000002   au BufNewFile,BufRead *.zir setf zir
    1              0.000003   au BufNewFile,BufRead *.zig,*.zir setf zig
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'zephir')
    1              0.000002   au BufNewFile,BufRead *.zep setf zephir
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'help')
    1              0.000007   au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt setf help
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'helm')
    1              0.000006   au BufNewFile,BufRead */templates/*.tpl,*/templates/*.yaml setf helm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'smarty')
    1              0.000002   au BufNewFile,BufRead *.tpl setf smarty
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ansible')
    1              0.000020   au BufNewFile,BufRead handlers.*.y{a,}ml,local.y{a,}ml,main.y{a,}ml,playbook.y{a,}ml,requirements.y{a,}ml,roles.*.y{a,}ml,site.y{a,}ml,tasks.*.y{a,}ml setf yaml.ansible
    1              0.000003   au BufNewFile,BufRead host_vars/* call s:StarSetf('yaml.ansible')
    1              0.000003   au BufNewFile,BufRead group_vars/* call s:StarSetf('yaml.ansible')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xsl')
    1              0.000004   au BufNewFile,BufRead *.xsl,*.xslt setf xsl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'xdc')
    1              0.000002   au BufNewFile,BufRead *.xdc setf xdc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'vue')
    1              0.000004   au BufNewFile,BufRead *.vue,*.wpy setf vue
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'vmasm')
    1              0.000002   au BufNewFile,BufRead *.mar setf vmasm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'velocity')
    1              0.000002   au BufNewFile,BufRead *.vm setf velocity
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'vcl')
    1              0.000002   au BufNewFile,BufRead *.vcl setf vcl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'vbnet')
    1              0.000004   au BufNewFile,BufRead *.vb,*.vbhtml setf vbnet
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'vala')
    1              0.000006   au BufNewFile,BufRead *.vala,*.valadoc,*.vapi setf vala
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'v')
    1              0.000005   au BufNewFile,BufRead *.v,*.vsh,*.vv setf vlang
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'unison')
    1              0.000003   au BufNewFile,BufRead *.u,*.uu setf unison
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'typescript')
    1              0.000002   au BufNewFile,BufRead *.ts setf typescript
    1              0.000002   au BufNewFile,BufRead *.tsx setf typescriptreact
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'twig')
    1              0.000002   au BufNewFile,BufRead *.twig setf html.twig
    1              0.000003   au BufNewFile,BufRead *.xml.twig setf xml.twig
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tutor')
    1              0.000002   au BufNewFile,BufRead *.tutor setf tutor
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tptp')
    1              0.000004   au BufNewFile,BufRead *.ax,*.p,*.tptp setf tptp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'toml')
    1              0.000015   au BufNewFile,BufRead *.toml,*/.cargo/config,*/.cargo/credentials,Cargo.lock,Gopkg.lock,Pipfile,poetry.lock setf toml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tmux')
    1              0.000003   au BufNewFile,BufRead {.,}tmux*.conf setf tmux
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'thrift')
    1              0.000003   au BufNewFile,BufRead *.thrift setf thrift
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'textile')
    1              0.000003   au BufNewFile,BufRead *.textile setf textile
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'terraform')
    1              0.000004   au BufNewFile,BufRead *.tf,*.tfvars setf terraform
    1              0.000012   au BufNewFile,BufRead *.hcl,*.nomad,*.workflow,{.,}terraformrc,Appfile,terraform.rc setf hcl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tf')
    1              0.000006   au BufNewFile,BufRead *.tf,{.,}tfrc,tfrc setf tf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'systemd')
    1              0.000026   au BufNewFile,BufRead *.automount,*.dnssd,*.link,*.mount,*.netdev,*.network,*.nspawn,*.path,*.service,*.slice,*.socket,*.swap,*.target,*.timer,*/systemd/*.conf setf systemd
    1              0.000002   au BufNewFile,BufRead *.#* call s:StarSetf('systemd')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sxhkd')
    1              0.000004   au BufNewFile,BufRead *.sxhkdrc,sxhkdrc setf sxhkdrc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'swift')
    1              0.000002   au BufNewFile,BufRead *.swift setf swift
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'svg')
    1              0.000002   au BufNewFile,BufRead *.svg setf svg
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'svelte')
    1              0.000002   au BufNewFile,BufRead *.svelte setf svelte
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'stylus')
    1              0.000004   au BufNewFile,BufRead *.styl,*.stylus setf stylus
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'solidity')
    1              0.000002   au BufNewFile,BufRead *.sol setf solidity
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'smt2')
    1              0.000004   au BufNewFile,BufRead *.smt,*.smt2 setf smt2
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'slime')
    1              0.000002   au BufNewFile,BufRead *.slime setf slime
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'slim')
    1              0.000002   au BufNewFile,BufRead *.slim setf slim
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sh')
    1              0.000064   au BufNewFile,BufRead *.bash,*.bats,*.cgi,*.command,*.env,*.fcgi,*.ksh,*.sh,*.sh.in,*.tmux,*.tool,*/etc/udev/cdsymlinks.conf,{.,}bash_aliases,{.,}bash_history,{.,}bash_logout,{.,}bash_profile,{.,}bashrc,{.,}cshrc,{.,}env,{.,}env.example,{.,}flaskenv,{.,}kshrc,{.,}login,{.,}profile,9fs,PKGBUILD,bash_aliases,bash_logout,bash_profile,bashrc,cshrc,gradlew,kshrc,login,man,profile setf sh
    1              0.000016   au BufNewFile,BufRead *.zsh,*/etc/zprofile,{.,}zfbfmarks,{.,}zlogin,{.,}zlogout,{.,}zprofile,{.,}zshenv,{.,}zshrc setf zsh
    1              0.000003   au BufNewFile,BufRead .zsh* call s:StarSetf('zsh')
    1              0.000003   au BufNewFile,BufRead .zlog* call s:StarSetf('zsh')
    1              0.000003   au BufNewFile,BufRead .zcompdump* call s:StarSetf('zsh')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'scss')
    1              0.000002   au BufNewFile,BufRead *.scss setf scss
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'scala')
    1              0.000005   au BufNewFile,BufRead *.kojo,*.sc,*.scala setf scala
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rust')
    1              0.000004   au BufNewFile,BufRead *.rs,*.rs.in setf rust
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'brewfile')
    1              0.000002   au BufNewFile,BufRead Brewfile setf brewfile
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rspec')
    1              0.000003   au BufNewFile,BufRead *_spec.rb set ft=ruby syntax=rspec
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'ruby')
    1              0.000091   au BufNewFile,BufRead *.axlsx,*.builder,*.cap,*.eye,*.fcgi,*.gemspec,*.god,*.jbuilder,*.mspec,*.opal,*.pluginspec,*.podspec,*.prawn,*.rabl,*.rake,*.rant,*.rb,*.rbi,*.rbuild,*.rbw,*.rbx,*.rjs,*.ru,*.ruby,*.rxml,*.spec,*.thor,*.watchr,{.,}Brewfile,{.,}Guardfile,{.,}autotest,{.,}irbrc,{.,}pryrc,{.,}simplecov,Appraisals,Berksfile,Buildfile,Capfile,Cheffile,Dangerfile,Deliverfile,Fastfile,Gemfile,Guardfile,Jarfile,KitchenSink,Mavenfile,Podfile,Puppetfile,Rakefile,Routefile,Snapfile,Thorfile,Vagrantfile,[Rr]antfile,buildfile,vagrantfile setf ruby
    1              0.000003   au BufNewFile,BufRead [Rr]akefile* call s:StarSetf('ruby')
    1              0.000006   au BufNewFile,BufRead *.erb,*.erb.deface,*.rhtml setf eruby
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'rst')
    1              0.000007   au BufNewFile,BufRead *.rest,*.rest.txt,*.rst,*.rst.txt setf rst
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'reason')
    1              0.000032   au! BufNewFile,BufRead,BufWritePost *.re call polyglot#detect#Re()
    1              0.000002   au BufNewFile,BufRead *.rei setf reason
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'razor')
    1              0.000004   au BufNewFile,BufRead *.cshtml,*.razor setf razor
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'raml')
    1              0.000004   au BufNewFile,BufRead *.raml setf raml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ragel')
    1              0.000002   au BufNewFile,BufRead *.rl setf ragel
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'racket')
    1              0.000006   au BufNewFile,BufRead *.rkt,*.rktd,*.rktl,*.scrbl setf racket
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'r-lang')
    1              0.000010   au BufNewFile,BufRead *.S,*.r,*.rsx,*.s,{.,}Rprofile,expr-dist setf r
    1              0.000002   au BufNewFile,BufRead *.rd setf rhelp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'qml')
    1              0.000004   au BufNewFile,BufRead *.qbs,*.qml setf qml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'qmake')
    1              0.000003   au BufNewFile,BufRead *.pri,*.pro setf qmake
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'requirements')
    1              0.000011   au BufNewFile,BufRead *.pip,*require.{txt,in},*requirements.{txt,in},constraints.{txt,in} setf requirements
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'python')
    1              0.000040   au BufNewFile,BufRead *.cgi,*.fcgi,*.gyp,*.gypi,*.lmi,*.ptl,*.py,*.py3,*.pyde,*.pyi,*.pyp,*.pyt,*.pyw,*.rpy,*.smk,*.spec,*.tac,*.wsgi,*.xpy,{.,}gclient,{.,}pythonrc,{.,}pythonstartup,DEPS,SConscript,SConstruct,Snakefile,wscript setf python
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'purescript')
    1              0.000002   au BufNewFile,BufRead *.purs setf purescript
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'puppet')
    1              0.000004   au BufNewFile,BufRead *.pp,Modulefile setf puppet
    1              0.000002   au BufNewFile,BufRead *.epp setf embeddedpuppet
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pug')
    1              0.000004   au BufNewFile,BufRead *.jade,*.pug setf pug
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'protobuf')
    1              0.000002   au BufNewFile,BufRead *.proto setf proto
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'powershell')
    1              0.000006   au BufNewFile,BufRead *.ps1,*.psd1,*.psm1,*.pssc setf ps1
    1              0.000002   au BufNewFile,BufRead *.ps1xml setf ps1xml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pony')
    1              0.000002   au BufNewFile,BufRead *.pony setf pony
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'plantuml')
    1              0.000008   au BufNewFile,BufRead *.iuml,*.plantuml,*.pu,*.puml,*.uml setf plantuml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pest')
    1              0.000002   au BufNewFile,BufRead *.pest setf pest
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'blade')
    1              0.000004   au BufNewFile,BufRead *.blade,*.blade.php setf blade
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'php')
    1              0.000024   au BufNewFile,BufRead *.aw,*.ctp,*.fcgi,*.inc,*.php,*.php3,*.php4,*.php5,*.php9,*.phps,*.phpt,*.phtml,{.,}php,{.,}php_cs,{.,}php_cs.dist,Phakefile setf php
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cql')
    1              0.000002   au BufNewFile,BufRead *.cql setf cql
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'pgsql')
    1              0.000003   au BufNewFile,BufRead *.pgsql let b:sql_type_override='pgsql' | set ft=sql
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'opencl')
    1              0.000004   au BufNewFile,BufRead *.cl,*.opencl setf opencl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'octave')
    1              0.000031   au! BufNewFile,BufRead,BufWritePost *.m call polyglot#detect#M()
    1              0.000003   au BufNewFile,BufRead *.oct setf octave
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ocaml')
    1              0.000020   au BufNewFile,BufRead *.eliom,*.eliomi,*.ml,*.ml.cppo,*.ml4,*.mli,*.mli.cppo,*.mlip,*.mll,*.mlp,*.mlt,*.mly,{.,}ocamlinit setf ocaml
    1              0.000008   au BufNewFile,BufRead *.om,OMakefile,OMakeroot,OMakeroot.in setf omake
    1              0.000006   au BufNewFile,BufRead *.opam,*.opam.template,opam setf opam
    1              0.000003   au BufNewFile,BufRead _oasis setf oasis
    1              0.000008   au BufNewFile,BufRead dune,dune-project,dune-workspace,jbuild setf dune
    1              0.000002   au BufNewFile,BufRead _tags setf ocamlbuild_tags
    1              0.000002   au BufNewFile,BufRead *.ocp setf ocpbuild
    1              0.000002   au BufNewFile,BufRead *.root setf ocpbuildroot
    1              0.000002   au BufNewFile,BufRead *.sexp setf sexplib
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'objc')
    1              0.000114   au! BufNewFile,BufRead,BufWritePost *.m call polyglot#detect#M()
    1              0.000031   au! BufNewFile,BufRead,BufWritePost *.h call polyglot#detect#H()
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'nix')
    1              0.000002   au BufNewFile,BufRead *.nix setf nix
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'nim')
    1              0.000010   au BufNewFile,BufRead *.nim,*.nim.cfg,*.nimble,*.nimrod,*.nims,nim.cfg setf nim
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'nginx')
    1              0.000014   au BufNewFile,BufRead *.nginx,*.nginxconf,*.vhost,*/nginx/*.conf,*nginx.conf,nginx*.conf,nginx.conf setf nginx
    1              0.000005   au BufNewFile,BufRead */usr/local/nginx/conf/* call s:StarSetf('nginx')
    1              0.000003   au BufNewFile,BufRead */etc/nginx/* call s:StarSetf('nginx')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'murphi')
    1              0.000113   au! BufNewFile,BufRead,BufWritePost *.m call polyglot#detect#M()
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'moonscript')
    1              0.000003   au BufNewFile,BufRead *.moon setf moon
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'meson')
    1              0.000005   au BufNewFile,BufRead meson.build,meson_options.txt setf meson
    1              0.000002   au BufNewFile,BufRead *.wrap setf dosini
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mdx')
    1              0.000002   au BufNewFile,BufRead *.mdx setf markdown.mdx
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mathematica')
    1              0.000113   au! BufNewFile,BufRead,BufWritePost *.m call polyglot#detect#M()
    1              0.000014   au BufNewFile,BufRead *.cdf,*.ma,*.mathematica,*.mma,*.mt,*.nb,*.nbp,*.wl,*.wls,*.wlt setf mma
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mako')
    1              0.000004   au BufNewFile,BufRead *.mako,*.mao setf mako
    1              0.000003   au BufReadPre *.*.mao execute "do BufRead filetypedetect " . expand("<afile>:r") | let b:mako_outer_lang = &filetype
    1              0.000002   au BufNewFile *.*.mao execute "do BufNewFile filetypedetect " . expand("<afile>:r") | let b:mako_outer_lang = &filetype
    1              0.000002   au BufReadPre *.*.mako execute "do BufRead filetypedetect " . expand("<afile>:r") | let b:mako_outer_lang = &filetype
    1              0.000002   au BufNewFile *.*.mako execute "do BufNewFile filetypedetect " . expand("<afile>:r") | let b:mako_outer_lang = &filetype
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'm4')
    1              0.000004   au BufNewFile,BufRead *.at,*.m4 setf m4
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lua')
    1              0.000015   au BufNewFile,BufRead *.fcgi,*.lua,*.nse,*.p8,*.pd_lua,*.rbxs,*.rockspec,*.wlua,{.,}luacheckrc setf lua
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'log')
    1              0.000006   au BufNewFile,BufRead *.LOG,*.log,*_LOG,*_log setf log
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'llvm')
    1              0.000002   au BufNewFile,BufRead *.ll setf llvm
    1              0.000002   au BufNewFile,BufRead *.td setf tablegen
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'livescript')
    1              0.000005   au BufNewFile,BufRead *._ls,*.ls,Slakefile setf ls
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'lilypond')
    1              0.000003   au BufNewFile,BufRead *.ily,*.ly setf lilypond
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'less')
    1              0.000002   au BufNewFile,BufRead *.less setf less
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ledger')
    1              0.000005   au BufNewFile,BufRead *.journal,*.ldg,*.ledger setf ledger
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'kotlin')
    1              0.000004   au BufNewFile,BufRead *.kt,*.ktm,*.kts setf kotlin
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'julia')
    1              0.000002   au BufNewFile,BufRead *.jl setf julia
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jst')
    1              0.000006   au BufNewFile,BufRead *.ect,*.ejs,*.ejs.t,*.jst setf jst
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'tads')
    1              0.000032   au! BufNewFile,BufRead,BufWritePost *.t call polyglot#detect#T()
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'raku')
    1              0.000116   au! BufNewFile,BufRead,BufWritePost *.t call polyglot#detect#T()
    1              0.000120   au! BufNewFile,BufRead,BufWritePost *.pm call polyglot#detect#Pm()
    1              0.000118   au! BufNewFile,BufRead,BufWritePost *.pl call polyglot#detect#Pl()
    1              0.000021   au BufNewFile,BufRead *.6pl,*.6pm,*.nqp,*.p6,*.p6l,*.p6m,*.pl6,*.pm6,*.pod6,*.raku,*.rakudoc,*.rakumod,*.rakutest,*.t6 setf raku
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'perl')
    1              0.000119   au! BufNewFile,BufRead,BufWritePost *.t call polyglot#detect#T()
    1              0.000119   au! BufNewFile,BufRead,BufWritePost *.pm call polyglot#detect#Pm()
    1              0.000120   au! BufNewFile,BufRead,BufWritePost *.pl call polyglot#detect#Pl()
    1              0.000023   au BufNewFile,BufRead *.al,*.cgi,*.fcgi,*.perl,*.ph,*.plx,*.psgi,{.,}gitolite.rc,Makefile.PL,Rexfile,ack,cpanfile,example.gitolite.rc setf perl
    1              0.000003   au BufNewFile,BufRead *.pod setf pod
    1              0.000006   au BufNewFile,BufRead *.comp,*.mason,*.mhtml setf mason
    1              0.000039   au! BufNewFile,BufRead,BufWritePost *.tt2 call polyglot#detect#Tt2()
    1              0.000124   au! BufNewFile,BufRead,BufWritePost *.tt2 call polyglot#detect#Tt2()
    1              0.000002   au BufNewFile,BufRead *.xs setf xs
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'rc')
    1              0.000004   au BufNewFile,BufRead *.rc,*.rch setf rc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jsonnet')
    1              0.000004   au BufNewFile,BufRead *.jsonnet,*.libsonnet setf jsonnet
    1              0.000000 endif
                            
    1              0.000003 if !has_key(g:polyglot_is_disabled, 'json')
    1              0.000068   au BufNewFile,BufRead *.JSON-tmLanguage,*.avsc,*.geojson,*.gltf,*.har,*.ice,*.json,*.jsonl,*.jsonp,*.mcmeta,*.template,*.tfstate,*.tfstate.backup,*.topojson,*.webapp,*.webmanifest,*.yy,*.yyp,{.,}arcconfig,{.,}auto-changelog,{.,}c8rc,{.,}htmlhintrc,{.,}imgbotconfig,{.,}nycrc,{.,}tern-config,{.,}tern-project,{.,}watchmanconfig,Pipfile.lock,composer.lock,mcmod.info setf json
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'json5')
    1              0.000002   au BufNewFile,BufRead *.json5 setf json5
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jq')
    1              0.000004   au BufNewFile,BufRead *.jq,{.,}jqrc setf jq
    1              0.000004   au BufNewFile,BufRead .jqrc* call s:StarSetf('jq')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'htmldjango')
    1              0.000006   au BufNewFile,BufRead *.j2,*.jinja,*.jinja2 setf htmldjango
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jenkins')
    1              0.000008   au BufNewFile,BufRead *.Jenkinsfile,*.jenkinsfile,Jenkinsfile setf Jenkinsfile
    1              0.000003   au BufNewFile,BufRead Jenkinsfile* call s:StarSetf('Jenkinsfile')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ion')
    1              0.000010   au BufNewFile,BufRead *.ion,~/.config/ion/initrc setf ion
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'idris2')
    1              0.000041   au! BufNewFile,BufRead,BufWritePost *.idr call polyglot#detect#Idr()
    1              0.000005   au BufNewFile,BufRead *.ipkg,idris-response setf idris2
    1              0.000036   au! BufNewFile,BufRead,BufWritePost *.lidr call polyglot#detect#Lidr()
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'idris')
    1              0.000125   au! BufNewFile,BufRead,BufWritePost *.lidr call polyglot#detect#Lidr()
    1              0.000130   au! BufNewFile,BufRead,BufWritePost *.idr call polyglot#detect#Idr()
    1              0.000003   au BufNewFile,BufRead idris-response setf idris
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'icalendar')
    1              0.000002   au BufNewFile,BufRead *.ics setf icalendar
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'hive')
    1              0.000006   au BufNewFile,BufRead *.hql,*.q,*.ql setf hive
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'haxe')
    1              0.000004   au BufNewFile,BufRead *.hx,*.hxsl setf haxe
    1              0.000002   au BufNewFile,BufRead *.hxml setf hxml
    1              0.000002   au BufNewFile,BufRead *.hss setf hss
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'haskell')
    1              0.000008   au BufNewFile,BufRead *.bpk,*.hs,*.hs-boot,*.hsc,*.hsig setf haskell
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'haproxy')
    1              0.000003   au BufNewFile,BufRead haproxy*.conf* call s:StarSetf('haproxy')
    1              0.000003   au BufNewFile,BufRead haproxy*.cfg* call s:StarSetf('haproxy')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'handlebars')
    1              0.000007   au BufNewFile,BufRead *.hjs,*.hogan,*.hulk,*.mustache setf html.mustache
    1              0.000007   au BufNewFile,BufRead *.handlebars,*.hb,*.hbs,*.hdbs setf html.handlebars
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'haml')
    1              0.000007   au BufNewFile,BufRead *.haml,*.haml.deface,*.hamlbars,*.hamlc setf haml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'grub')
    1              0.000009   au BufNewFile,BufRead */boot/grub/grub.conf,*/boot/grub/menu.lst,*/etc/grub.conf setf grub
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'groovy')
    1              0.000011   au BufNewFile,BufRead *.gradle,*.groovy,*.grt,*.gtpl,*.gvy,Jenkinsfile setf groovy
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'graphql')
    1              0.000005   au BufNewFile,BufRead *.gql,*.graphql,*.graphqls setf graphql
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'jsx')
    1              0.000003   au BufNewFile,BufRead *.jsx setf javascriptreact
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'javascript')
    1              0.000038   au! BufNewFile,BufRead,BufWritePost *.frag call polyglot#detect#Frag()
    1              0.000042   au BufNewFile,BufRead *._js,*.bones,*.cjs,*.es,*.es6,*.gs,*.jake,*.javascript,*.js,*.jsb,*.jscad,*.jsfl,*.jsm,*.jss,*.jsx,*.mjs,*.njs,*.pac,*.sjs,*.ssjs,*.xsjs,*.xsjslib,Jakefile setf javascript
    1              0.000002   au BufNewFile,BufRead *.flow setf flow
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'go')
    1              0.000002   au BufNewFile,BufRead *.go setf go
    1              0.000002   au BufNewFile,BufRead go.mod setf gomod
    1              0.000002   au BufNewFile,BufRead *.tmpl setf gohtmltmpl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gnuplot')
    1              0.000012   au BufNewFile,BufRead *.gnu,*.gnuplot,*.gp,*.gpi,*.p,*.plot,*.plt setf gnuplot
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gmpl')
    1              0.000002   au BufNewFile,BufRead *.mod setf gmpl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'glsl')
    1              0.000040   au! BufNewFile,BufRead,BufWritePost *.fs call polyglot#detect#Fs()
    1              0.000135   au! BufNewFile,BufRead,BufWritePost *.frag call polyglot#detect#Frag()
    1              0.000035   au BufNewFile,BufRead *.comp,*.fp,*.frg,*.fsh,*.fshader,*.geo,*.geom,*.glsl,*.glslf,*.glslv,*.gs,*.gshader,*.rchit,*.rmiss,*.shader,*.tesc,*.tese,*.vert,*.vrx,*.vsh,*.vshader setf glsl
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'git')
    1              0.000020   au BufNewFile,BufRead *.gitconfig,*.git/config,*.git/modules/*/config,*/.config/git/config,*/git/config,{.,}gitconfig,{.,}gitmodules setf gitconfig
    1              0.000003   au BufNewFile,BufRead */{.,}gitconfig.d/* call s:StarSetf('gitconfig')
    1              0.000003   au BufNewFile,BufRead git-rebase-todo setf gitrebase
    1              0.000005   au BufNewFile,BufRead .gitsendemail.* call s:StarSetf('gitsendemail')
    1              0.000008   au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG setf gitcommit
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'gdscript')
    1              0.000002   au BufNewFile,BufRead *.gd setf gdscript3
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'fsharp')
    1              0.000139   au! BufNewFile,BufRead,BufWritePost *.fs call polyglot#detect#Fs()
    1              0.000004   au BufNewFile,BufRead *.fsi,*.fsx setf fsharp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'forth')
    1              0.000138   au! BufNewFile,BufRead,BufWritePost *.fs call polyglot#detect#Fs()
    1              0.000004   au BufNewFile,BufRead *.ft,*.fth setf forth
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'flatbuffers')
    1              0.000004   au BufNewFile,BufRead *.fbs setf fbs
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'fish')
    1              0.000002   au BufNewFile,BufRead *.fish setf fish
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ferm')
    1              0.000004   au BufNewFile,BufRead *.ferm,ferm.conf setf ferm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'fennel')
    1              0.000004   au BufNewFile,BufRead *.fnl setf fennel
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'erlang')
    1              0.000031   au BufNewFile,BufRead *.app,*.app.src,*.erl,*.es,*.escript,*.hrl,*.xrl,*.yaws,*.yrl,Emakefile,rebar.config,rebar.config.lock,rebar.lock setf erlang
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'emblem')
    1              0.000006   au BufNewFile,BufRead *.em,*.emblem setf emblem
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'emberscript')
    1              0.000004   au BufNewFile,BufRead *.em,*.emberscript setf ember-script
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'elm')
    1              0.000002   au BufNewFile,BufRead *.elm setf elm
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'elixir')
    1              0.000006   au BufNewFile,BufRead *.ex,*.exs,mix.lock setf elixir
    1              0.000009   au BufNewFile,BufRead *.eex,*.html.heex,*.html.leex,*.leex setf eelixir
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'docker-compose')
    1              0.000009   au BufNewFile,BufRead docker-compose*.yaml,docker-compose*.yml setf yaml.docker-compose
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'yaml')
    1              0.000041   au BufNewFile,BufRead *.mir,*.reek,*.rviz,*.sublime-syntax,*.syntax,*.yaml,*.yaml-tmlanguage,*.yaml.sed,*.yml,*.yml.mysql,{.,}clang-format,{.,}clang-tidy,{.,}gemrc,CITATION.cff,fish_history,fish_read_history,glide.lock,yarn.lock setf yaml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'mysql')
    1              0.000002   au BufNewFile,BufRead *.mysql setf mysql
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'sed')
    1              0.000002   au BufNewFile,BufRead *.sed setf sed
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dlang')
    1              0.000004   au BufNewFile,BufRead *.d,*.di setf d
    1              0.000002   au BufNewFile,BufRead *.lst setf dcov
    1              0.000002   au BufNewFile,BufRead *.dd setf dd
    1              0.000002   au BufNewFile,BufRead *.ddoc setf ddoc
    1              0.000003   au BufNewFile,BufRead *.sdl setf dsdl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dhall')
    1              0.000002   au BufNewFile,BufRead *.dhall setf dhall
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'dart')
    1              0.000003   au BufNewFile,BufRead *.dart,*.drt setf dart
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cue')
    1              0.000003   au BufNewFile,BufRead *.cue setf cuesheet
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cucumber')
    1              0.000004   au BufNewFile,BufRead *.feature,*.story setf cucumber
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'crystal')
    1              0.000006   au BufNewFile,BufRead *.cr,Projectfile setf crystal
    1              0.000002   au BufNewFile,BufRead *.ecr setf ecrystal
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cryptol')
    1              0.000007   au BufNewFile,BufRead *.cry,*.cyl,*.lcry,*.lcyl setf cryptol
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'coffee-script')
    1              0.000015   au BufNewFile,BufRead *._coffee,*.cake,*.cjsx,*.coffee,*.coffeekup,*.cson,*.iced,Cakefile setf coffee
    1              0.000004   au BufNewFile,BufRead *.coffee.md,*.litcoffee setf litcoffee
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'markdown')
    1              0.000019   au BufNewFile,BufRead *.markdown,*.md,*.mdown,*.mdwn,*.mkd,*.mkdn,*.mkdown,*.ronn,*.scd,*.workbook,contents.lr setf markdown
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cmake')
    1              0.000008   au BufNewFile,BufRead *.cmake,*.cmake.in,CMakeLists.txt setf cmake
    1              0.000000 endif
                            
    1              0.000003 if !has_key(g:polyglot_is_disabled, 'clojure')
    1              0.000027   au BufNewFile,BufRead *.boot,*.cl2,*.clj,*.cljc,*.cljs,*.cljs.hl,*.cljscm,*.cljx,*.edn,*.hic,build.boot,profile.boot,riemann.config setf clojure
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'carp')
    1              0.000002   au BufNewFile,BufRead *.carp setf carp
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'caddyfile')
    1              0.000002   au BufNewFile,BufRead Caddyfile setf caddyfile
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'awk')
    1              0.000005   au BufNewFile,BufRead *.awk,*.gawk setf awk
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ave')
    1              0.000002   au BufNewFile,BufRead *.ave setf ave
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'autoit')
    1              0.000002   au BufNewFile,BufRead *.au3 setf autoit
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'atlas')
    1              0.000008   au BufNewFile,BufRead *.as,*.atl setf atlas
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'aspperl')
    1              0.000046   au! BufNewFile,BufRead,BufWritePost *.asp call polyglot#detect#Asp()
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'aspvbs')
    1              0.000152   au! BufNewFile,BufRead,BufWritePost *.asp call polyglot#detect#Asp()
    1              0.000046   au! BufNewFile,BufRead,BufWritePost *.asa call polyglot#detect#Asa()
    1              0.000001 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'asn')
    1              0.000005   au BufNewFile,BufRead *.asn,*.asn1 setf asn
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'automake')
    1              0.000008   au BufNewFile,BufRead GNUmakefile.am,[mM]akefile.am setf automake
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'elf')
    1              0.000002   au BufNewFile,BufRead *.am setf elf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'make')
    1              0.000007   au BufNewFile,BufRead *.dsp,*.mak,*.mk,*[mM]akefile setf make
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'autohotkey')
    1              0.000003   au BufNewFile,BufRead *.ahk,*.ahkl setf autohotkey
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'asciidoc')
    1              0.000006   au BufNewFile,BufRead *.adoc,*.asc,*.asciidoc setf asciidoc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'art')
    1              0.000002   au BufNewFile,BufRead *.art setf art
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'arduino')
    1              0.000005   au BufNewFile,BufRead *.ino,*.pde setf arduino
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'c/c++')
    1              0.000149   au! BufNewFile,BufRead,BufWritePost *.h call polyglot#detect#H()
    1              0.000027   au BufNewFile,BufRead *.c++,*.cc,*.cp,*.cpp,*.cxx,*.h++,*.hh,*.hpp,*.hxx,*.inc,*.inl,*.ipp,*.ixx,*.moc,*.tcc,*.tlh,*.tpp setf cpp
    1              0.000150   au! BufNewFile,BufRead,BufWritePost *.h call polyglot#detect#H()
    1              0.000011   au BufNewFile,BufRead *.c,*.cats,*.idc,*.qc,*enlightenment/*.cfg setf c
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'arch')
    1              0.000007   au BufNewFile,BufRead {.,}arch-inventory,=tagging-method setf arch
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'aptconf')
    1              0.000011   au BufNewFile,BufRead */.aptitude/config,*/etc/apt/apt.conf.d/*.conf,apt.conf setf aptconf
    1              0.000004   au BufNewFile,BufRead */etc/apt/apt.conf.d/[^.]* call s:StarSetf('aptconf')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'applescript')
    1              0.000006   au BufNewFile,BufRead *.applescript,*.scpt setf applescript
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'apiblueprint')
    1              0.000002   au BufNewFile,BufRead *.apib setf apiblueprint
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'apache')
    1              0.000010   au BufNewFile,BufRead */etc/apache2/sites-*/*.com,*/etc/httpd/*.conf,{.,}htaccess setf apache
    1              0.000004   au BufNewFile,BufRead srm.conf* call s:StarSetf('apache')
    1              0.000003   au BufNewFile,BufRead httpd.conf* call s:StarSetf('apache')
    1              0.000004   au BufNewFile,BufRead apache2.conf* call s:StarSetf('apache')
    1              0.000002   au BufNewFile,BufRead apache.conf* call s:StarSetf('apache')
    1              0.000003   au BufNewFile,BufRead access.conf* call s:StarSetf('apache')
    1              0.000006   au BufNewFile,BufRead */etc/httpd/conf.d/*.conf* call s:StarSetf('apache')
    1              0.000004   au BufNewFile,BufRead */etc/apache2/sites-*/* call s:StarSetf('apache')
    1              0.000003   au BufNewFile,BufRead */etc/apache2/mods-*/* call s:StarSetf('apache')
    1              0.000009   au BufNewFile,BufRead */etc/apache2/conf.*/* call s:StarSetf('apache')
    1              0.000003   au BufNewFile,BufRead */etc/apache2/*.conf* call s:StarSetf('apache')
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ant')
    1              0.000003   au BufNewFile,BufRead build.xml setf ant
    1              0.000000 endif
                            
    1              0.000005 if !has_key(g:polyglot_is_disabled, 'xml')
    1              0.000208   au BufNewFile,BufRead *.adml,*.admx,*.ant,*.axml,*.builds,*.ccproj,*.ccxml,*.cdxml,*.clixml,*.cproject,*.cscfg,*.csdef,*.csl,*.csproj,*.csproj.user,*.ct,*.depproj,*.dita,*.ditamap,*.ditaval,*.dll.config,*.dotsettings,*.filters,*.fsproj,*.fxml,*.glade,*.gml,*.gmx,*.grxml,*.gst,*.hzp,*.iml,*.ivy,*.jelly,*.jsproj,*.kml,*.launch,*.mdpolicy,*.mjml,*.mod,*.mxml,*.natvis,*.ncl,*.ndproj,*.nproj,*.nuspec,*.odd,*.osm,*.pkgproj,*.pluginspec,*.proj,*.props,*.psc1,*.pt,*.rdf,*.res,*.resx,*.rss,*.sch,*.scxml,*.sfproj,*.shproj,*.srdf,*.storyboard,*.sublime-snippet,*.targets,*.tml,*.tpm,*.ui,*.urdf,*.ux,*.vbproj,*.vcxproj,*.vsixmanifest,*.vssettings,*.vstemplate,*.vxml,*.wixproj,*.workflow,*.wpl,*.wsdl,*.wsf,*.wxi,*.wxl,*.wxs,*.x3d,*.xacro,*.xaml,*.xib,*.xlf,*.xliff,*.xmi,*.xml,*.xml.dist,*.xmp,*.xproj,*.xsd,*.xspec,*.xul,*.zcml,*/etc/blkid.tab,*/etc/blkid.tab.old,*/etc/xdg/menus/*.menu,*fglrxrc,{.,}classpath,{.,}cproject,{.,}project,App.config,NuGet.config,Settings.StyleCop,Web.Debug.config,Web.Release.config,Web.config,
    1              0.000001 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'csv')
    1              0.000005   au BufNewFile,BufRead *.csv,*.tab,*.tsv setf csv
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ampl')
                              " AMPL
    1              0.000002   au BufNewFile,BufRead *.run setf ampl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'aml')
    1              0.000002   au BufNewFile,BufRead *.aml setf aml
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'alsaconf')
    1              0.000010   au BufNewFile,BufRead */etc/asound.conf,*/usr/share/alsa/alsa.conf,{.,}asoundrc setf alsaconf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'conf')
    1              0.000010   au BufNewFile,BufRead *.conf,*/etc/hosts,auto.master,config setf conf
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'master')
    1              0.000004   au BufNewFile,BufRead *.mas,*.master setf master
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'aidl')
                              " AIDL
    1              0.000002   au BufNewFile,BufRead *.aidl setf aidl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ahdl')
                              " AHDL
    1              0.000002   au BufNewFile,BufRead *.tdf setf ahdl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'ada')
                              " Ada (83, 9X, 95)
    1              0.000011   au BufNewFile,BufRead *.ada,*.ada_m,*.adb,*.adc,*.ads,*.gpr setf ada
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'acpiasl')
    1              0.000003   au BufNewFile,BufRead *.asl,*.dsl setf asl
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'acedb')
                              " AceDB
    1              0.000002   au BufNewFile,BufRead *.wrm setf acedb
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'abel')
                              " ABEL
    1              0.000003   au BufNewFile,BufRead *.abl setf abel
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'abc')
                              " ABC music notation
    1              0.000002   au BufNewFile,BufRead *.abc setf abc
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'abaqus')
    1              0.000179   au! BufNewFile,BufRead,BufWritePost *.inp call polyglot#detect#Inp()
    1              0.000001 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'abap')
                              " ABAB/4
    1              0.000002   au BufNewFile,BufRead *.abap setf abap
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'aap')
                              " A-A-P recipe
    1              0.000002   au BufNewFile,BufRead *.aap setf aap
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'a65')
                              " XA65 MOS6510 cross assembler
    1              0.000004   au BufNewFile,BufRead *.a65 setf a65
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'a2ps')
    1              0.000011   au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,{.,}a2psrc,a2psrc setf a2ps
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, 'cfg')
    1              0.000005   au BufNewFile,BufRead *.cfg,*.hgrc,*hgrc setf cfg
    1              0.000000 endif
                            
    1              0.000001 if !has_key(g:polyglot_is_disabled, '8th')
                              " 8th (Firth-derivative)
    1              0.000003   au BufNewFile,BufRead *.8th setf 8th
    1              0.000000 endif
                            
                            
                            " DO NOT EDIT CODE ABOVE, IT IS GENERATED WITH MAKEFILE
                            
    1              0.000003 let s:detect_func = 'shebang#Detect'
                            
    1              0.000004 func! s:PolyglotObserve(fn)
                              call function("polyglot#" . a:fn)
                            endfunc
                            
    1              0.000001 func! s:Observe()
                              augroup polyglot-observer
                                au!
                                au CursorHold,CursorHoldI <buffer> if (&ft == "" || &ft == "conf") | call s:PolyglotObserve(s:detect_func) | endif
                              augroup END
                            endfunc
                            
    1              0.000006 au BufNewFile,BufRead,StdinReadPost,BufWritePost * if (&ft == "" || &ft == "conf") && expand("<afile>:e") == "" |
                              \ call polyglot#shebang#Detect() | endif
                            
    1              0.000002 au BufWinEnter * if &ft == "" && expand("<afile>:e") == "" |
                              \ call s:Observe() | endif
                            
    1              0.000001 au BufWritePost * au! polyglot-observer
                            
    1              0.000001 augroup END
                            
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'sensible')
                              " Use 2-spaces tab indentation by default
    1              0.000003   if &tabstop == 8
    1              0.000003     let &tabstop = 2
    1              0.000000   endif
                            
                              " Set shiftwidth to proper value as users often mix it with tabstop
    1              0.000001   if &shiftwidth > &tabstop
    1              0.000001     let &shiftwidth = &tabstop
    1              0.000000   endif
                            
                              " Use utf-8 encoding by default
    1              0.000004   set encoding=utf-8
                            
                              " Reload unchanged files automatically.
    1              0.000001   set autoread
                            
                              " This is needed to avoid swapfile warning when auto-reloading
    1              0.000002   set shortmess+=A
                            
                              " Avoids swapfiles in current directory
    1              0.000005   if &directory =~# '^\.,'
                                if !empty($HOME)
                                  if has('win32')
                                    let &directory = expand('$HOME/vimfiles') . '//,' . &directory
                                  else
                                    let &directory = expand('$HOME/.vim') . '//,' . &directory
                                  endif
                                endif
                                if !empty($XDG_DATA_HOME)
                                  let &directory = expand('$XDG_DATA_HOME') . '//,' . &directory
                                endif
                                if has('macunix')
                                  let &directory = expand('$HOME/Library/Autosave Information') . '//,' . &directory
                                endif
    1              0.000000   endif
                            
                              " Autoindent when starting new line, or using `o` or `O`.
    1              0.000001   set autoindent
    1              0.000000 endif
                            
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'autoindent')
                              " Code below re-implements sleuth for vim-polyglot
    1              0.000001   let g:loaded_sleuth = 1
                            
    1              0.000001   let s:default_shiftwidth = &shiftwidth
                            
    1              0.000001   func! s:get_shiftwidth(indents) abort
                                let shiftwidth = 0
                                let max_count = 0
                                let final_counts = {}
                                for [indent, indent_count] in items(a:indents)
                                  let indent_count = indent_count * 1.5
                                  for [indent2, indent2_count] in items(a:indents)
                                    if indent2 > indent && indent2 % indent == 0
                                      let indent_count = indent_count + indent2_count
                                    endif
                                  endfor
                                  let final_counts[indent] = indent_count
                                endfor
                                for [indent, final_count] in items(final_counts)
                                  if final_count > max_count
                                    let shiftwidth = indent
                                    let max_count = final_count
                                  endif
                                endfor
                                return shiftwidth
                              endfunc
                            
    1              0.000001   func! s:guess(lines) abort
                                let options = {}
                                let ccomment = 0
                                let podcomment = 0
                                let triplequote = 0
                                let backtick = 0
                                let xmlcomment = 0
                                let heredoc = ''
                                let minindent = 10
                                let spaces_minus_tabs = 0
                                let lineno = 0
                                let stack = [0]
                                let indents = { '2': 0, '3': 0, '4': 0, '6': 0, '8': 0 }
                            
                                for line in a:lines
                                  let lineno += 1
                            
                                  if line =~# '^\s*$'
                                    continue
                                  endif
                            
                                  if line =~# '^\s*/\*'
                                    let ccomment = 1
                                  endif
                                  if ccomment
                                    if line =~# '\*/'
                                      let ccomment = 0
                                    endif
                                    continue
                                  endif
                            
                                  if line =~# '^=\w'
                                    let podcomment = 1
                                  endif
                                  if podcomment
                                    if line =~# '^=\%(end\|cut\)\>'
                                      let podcomment = 0
                                    endif
                                    continue
                                  endif
                            
                                  if triplequote
                                    if line =~# '^[^"]*"""[^"]*$'
                                      let triplequote = 0
                                    endif
                                    continue
                                  elseif line =~# '^[^"]*"""[^"]*$'
                                    let triplequote = 1
                                  endif
                            
                                  if backtick
                                    if line =~# '^[^`]*`[^`]*$'
                                      let backtick = 0
                                    endif
                                    continue
                                  elseif &filetype ==# 'go' && line =~# '^[^`]*`[^`]*$'
                                    let backtick = 1
                                  endif
                            
                                  if line =~# '^\s*<\!--'
                                    let xmlcomment = 1
                                  endif
                                  if xmlcomment
                                    if line =~# '-->'
                                      let xmlcomment = 0
                                    endif
                                    continue
                                  endif
                            
                                  " This is correct order because both "<<EOF" and "EOF" matches end
                                  if heredoc != ''
                                    if line =~# heredoc
                                      let heredoc = ''
                                    endif
                                    continue
                                  endif
                                  let herematch = matchlist(line, '\C<<\W*\([A-Z]\+\)\s*$')
                                  if len(herematch) > 0
                                    let heredoc = herematch[1] . '$'
                                  endif
                            
                                  if line[0] == "\t"
                                    let spaces_minus_tabs -= 1
                                  else
                                    if line[0] == " "
                                      let spaces_minus_tabs += 1
                                    endif
                                    let indent = len(matchstr(line, '^ *'))
                                    while stack[-1] > indent
                                      call remove(stack, -1)
                                    endwhile
                            
                                    let indent_inc = indent - stack[-1]
                            
                                    if indent_inc == 0 && len(stack) > 1
                                      let indent_inc = indent - stack[-2]
                                    endif
                            
                                    if has_key(indents, indent_inc)
                                      let indents[indent_inc] += 1
                                      let prev_indent = indent
                                    endif
                            
                                    if stack[-1] != indent
                                      call add(stack, indent)
                                    endif
                                  endif
                                endfor
                            
                                if spaces_minus_tabs < 0
                                  setlocal noexpandtab
                                  let &l:shiftwidth=&tabstop
                                  return 1
                                endif
                            
                                let shiftwidth = s:get_shiftwidth(indents)
                            
                                if shiftwidth > 0
                                  setlocal expandtab
                                  let &l:shiftwidth=shiftwidth
                                  try
                                    " Sunchronize tabstop with shiftwidth
                                    let &l:softtabstop = -1
                                  catch /^Vim\%((\a\+)\)\=:E487/
                                    " -1 was not supported before Vim 7.4
                                    let &l:softtabstop = a:num_spaces
                                  endtry
                                  return 1
                                endif
                            
                                return 0
                              endfunc
                            
    1              0.000001   func! s:detect_indent() abort
                                if &buftype ==# 'help'
                                  return
                                endif
                            
                                " Do not autodetect indent if language or user sets it
                                if &l:shiftwidth != s:default_shiftwidth
                                  return
                                endif
                            
                                let b:sleuth_culprit = expand("<afile>:p")
                                if s:guess(getline(1, 128))
                                  return
                                endif
                                if s:guess(getline(1, 1024))
                                  return
                                endif
                                let pattern = polyglot#sleuth#GlobForFiletype(&filetype)
                                if len(pattern) == 0
                                  return
                                endif
                                let pattern = '{' . pattern . ',.git,.svn,.hg}'
                                let dir = expand('%:p:h')
                                let level = 3
                                while isdirectory(dir) && dir !=# fnamemodify(dir, ':h') && level > 0
                                  " Ignore files from homedir and root 
                                  if dir == expand('~') || dir == '/'
                                    unlet b:sleuth_culprit
                                    return
                                  endif
                                  for neighbor in glob(dir . '/' . pattern, 0, 1)[0:level]
                                    let b:sleuth_culprit = neighbor
                                    " Do not consider directories above .git, .svn or .hg
                                    if fnamemodify(neighbor, ":h:t")[0] == "."
                                      let level = 0
                                      continue
                                    endif
                                    if neighbor !=# expand('%:p') && filereadable(neighbor)
                                      if s:guess(readfile(neighbor, '', 32))
                                        return
                                      endif
                                    endif
                                  endfor
                            
                                  let dir = fnamemodify(dir, ':h')
                                  let level -= 1
                                endwhile
                            
                                let b:sleuth_culprit = "default"
                              endfunc
                            
    1              0.000001   set smarttab
                            
    1              0.000001   func! SleuthIndicator() abort
                                let sw = &shiftwidth ? &shiftwidth : &tabstop
                                if &expandtab
                                  return 'sw='.sw
                                elseif &tabstop == sw
                                  return 'ts='.&tabstop
                                else
                                  return 'sw='.sw.',ts='.&tabstop
                                endif
                              endfunc
                            
    1              0.000001   augroup polyglot-sleuth
    1              0.000044     au!
    1              0.000002     au BufEnter * call s:detect_indent()
    1              0.000004     au User Flags call Hoist('buffer', 5, 'SleuthIndicator')
    1              0.000001   augroup END
                            
    1              0.000003   command! -bar -bang Sleuth call s:detect_indent()
    1              0.000000 endif
                            
    1              0.000001 augroup filetypedetect
                            
                            " Ignored extensions
    1              0.000003 if exists("*fnameescape")
    1              0.000036 au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
    1              0.000005 au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
    1              0.000003 au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
                            elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
    1              0.000000 endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
    1              0.000002 if !exists("g:ft_ignore_pat")
                              let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
    1              0.000000 endif
                            
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
    1              0.000003 au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
    1              0.000002 au BufNewFile,BufRead *.btm			call polyglot#ft#FTbtm()
                            
                            " BIND zone
    1              0.000002 au BufNewFile,BufRead *.db			call polyglot#ft#BindzoneCheck('')
                            
                            " C or lpc
    1              0.000002 au BufNewFile,BufRead *.c			call polyglot#ft#FTlpc()
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
    1              0.000002 au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
    1              0.000002 au BufNewFile,BufRead *.h			call polyglot#ft#FTheader()
                            
    1              0.000006 au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
    1              0.000003 au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " Changes for WEB and CWEB or CHILL
    1              0.000003 au BufNewFile,BufRead *.ch			call polyglot#ft#FTchange()
                            
                            " Clever or dtd
    1              0.000003 au BufNewFile,BufRead *.ent			call polyglot#ft#FTent()
                            
                            " Clipper (or FoxPro; could also be eviews)
    1              0.000003 au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
    1              0.000002 au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Euphoria 3 or 4
    1              0.000009 au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call polyglot#ft#EuphoriaCheck()
    1              0.000002 if has("fname_case")
    1              0.000009    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call polyglot#ft#EuphoriaCheck()
    1              0.000000 endif
                            
    1              0.000003 au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
    1              0.000003 au BufNewFile,BufRead copyright
                            	\  if getline(1) =~ '^Format:'
                            	\|   setf debcopyright
                            	\| endif
                            
                            " the D language or dtrace
    1              0.000003 au BufNewFile,BufRead *.d			call polyglot#ft#DtraceCheck()
                            
    1              0.000003 au BufNewFile,BufRead *.patch
                            	\ if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |
                            	\   setf gitsendemail |
                            	\ else |
                            	\   setf diff |
                            	\ endif
                            
                            " Diva (with Skill) or InstallShield
    1              0.000003 au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
    1              0.000002 au BufNewFile,BufRead *.com			call polyglot#ft#BindzoneCheck('dcl')
                            
    1              0.000004 au BufNewFile,BufRead *.edn
                            	\ if getline(1) =~ '^\s*(\s*edif\>' |
                            	\   setf edif |
                            	\ else |
                            	\   setf clojure |
                            	\ endif
                            
                            " Eiffel or Specman or Euphoria
    1              0.000003 au BufNewFile,BufRead *.e,*.E			call polyglot#ft#FTe()
                            
    1              0.000005 if !empty($XDG_CONFIG_HOME)
                              au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config		setf gitconfig
    1              0.000000 endif
                            
    1              0.000004 au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
    1              0.000003 au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
    1              0.000002 if !empty($GNUPGHOME)
                              au BufNewFile,BufRead $GNUPGHOME/options	setf gpg
                              au BufNewFile,BufRead $GNUPGHOME/gpg.conf	setf gpg
    1              0.000000 endif
                            
                            " HTML (.shtml and .stm for server side)
    1              0.000007 au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call polyglot#ft#FThtml()
                            
                            " IDL (Interface Description Language)
    1              0.000004 au BufNewFile,BufRead *.idl			call polyglot#ft#FTidl()
                            
    1              0.000003 au BufNewFile,BufRead indent.pro		call polyglot#ft#ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
    1              0.000002 au BufNewFile,BufRead *.pro			call polyglot#ft#ProtoCheck('idlang')
                            
                            " M4
    1              0.000003 au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " Mathematica, Matlab, Murphi or Objective C
    1              0.000003 au BufNewFile,BufRead *.m			call polyglot#ft#FTm()
                            
                            " MMIX or VMS makefile
    1              0.000002 au BufNewFile,BufRead *.mms			call polyglot#ft#FTmms()
                            
                            " Modsim III (or LambdaProlog)
    1              0.000003 au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Mutt setup files (must be before catch *.rc)
    1              0.000005 au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
    1              0.000003 au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
    1              0.000004 au BufNewFile,BufRead *.[1-9]			call polyglot#ft#FTnroff()
                            
                            " Nroff or Objective C++
    1              0.000002 au BufNewFile,BufRead *.mm			call polyglot#ft#FTmm()
                            
                            " Pacman hooks
    1              0.000003 au BufNewFile,BufRead *.hook
                            	\ if getline(1) == '[Trigger]' |
                            	\   setf dosini |
                            	\ endif
                            
                            " Perl
    1              0.000002 au BufNewFile,BufRead *.pl			call polyglot#ft#FTpl()
                            
                            " Perl, XPM or XPM2
    1              0.000005 au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Povray, PHP or assembly
    1              0.000002 au BufNewFile,BufRead *.inc			call polyglot#ft#FTinc()
                            
                            " Printcap and Termcap
    1              0.000003 au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
    1              0.000003 au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " Progress or CWEB
    1              0.000003 au BufNewFile,BufRead *.w			call polyglot#ft#FTprogress_cweb()
                            
                            " Progress or assembly
    1              0.000002 au BufNewFile,BufRead *.i			call polyglot#ft#FTprogress_asm()
                            
                            " Progress or Pascal
    1              0.000002 au BufNewFile,BufRead *.p			call polyglot#ft#FTprogress_pascal()
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
    1              0.000006 au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Registry for MS-Windows
    1              0.000003 au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Rexx, Rebol or R
    1              0.000003 au BufNewFile,BufRead *.r,*.R				call polyglot#ft#FTr()
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
    1              0.000002 au BufNewFile,BufRead *.mc			call polyglot#ft#McSetf()
                            
                            " SGML
    1              0.000006 au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
    1              0.000007 au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
                            " NOTE: Patterns ending in a star are further down, these have lower priority.
    1              0.000039 au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,bash-fc[-.],*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD call polyglot#ft#SetFileTypeSH("bash")
    1              0.000004 au BufNewFile,BufRead .kshrc,*.ksh call polyglot#ft#SetFileTypeSH("ksh")
    1              0.000008 au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env call polyglot#ft#SetFileTypeSH(getline(1))
                            
                            
                            " Shell script (Arch Linux) or PHP file (Drupal)
    1              0.000004 au BufNewFile,BufRead *.install
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   call polyglot#ft#SetFileTypeSH("bash") |
                            	\ endif
                            
                            " tcsh scripts (patterns ending in a star further below)
    1              0.000008 au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login	call polyglot#ft#SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
                            " (patterns ending in a start further below)
    1              0.000018 au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call polyglot#ft#CSH()
                            
    1              0.000003 au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
                            	\  setf rexx |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " SMIL or XML
    1              0.000004 au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
    1              0.000002 au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
    1              0.000002 au BufNewFile,BufRead *.rules			call polyglot#ft#FTRules()
                            
                            " SQL
    1              0.000002 au BufNewFile,BufRead *.sql			call polyglot#ft#SQL()
                            
                            " Also *.class, but not when it's a Java bytecode file
    1              0.000004 au BufNewFile,BufRead *.class
                            	\ if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
                            
    1              0.000002 au BufNewFile,BufRead *.tex			call polyglot#ft#FTtex()
                            
                            " Virata Config Script File or Drupal module
    1              0.000007 au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
    1              0.000003 au BufNewFile,BufRead *.frm			call polyglot#ft#FTVB("form")
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
    1              0.000003 au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
    1              0.000002 au BufEnter *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
                            
                            " XFree86 config
    1              0.000004 au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
    1              0.000007 au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
    1              0.000007 au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
    1              0.000002 au BufNewFile,BufRead *.ms
                            	\ if !polyglot#ft#FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
    1              0.000002 au BufNewFile,BufRead *.xml			call polyglot#ft#FTxml()
                            
                            " Yacc or racc
    1              0.000002 au BufNewFile,BufRead *.y			call polyglot#ft#FTy()
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
    1              0.000007 au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call polyglot#ft#FThtml()
                            "   zsql (zope sql method)
    1              0.000002 au BufNewFile,BufRead *.zsql			call polyglot#ft#SQL()
                            
    1              0.000001 augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
    1              0.000003 if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
    1              0.000000 endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
    1              0.000001 augroup filetypedetect
    1              0.000003 au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
    1              0.000001 au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache style config files
    1              0.000009 au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*	call s:StarSetf('apachestyle')
    1              0.000003 au BufNewFile,BufRead proftpd.conf*					call s:StarSetf('apachestyle')
                            
                            " More Apache config files
    1              0.000012 au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
    1              0.000017 au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
    1              0.000006 au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
    1              0.000004 au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " BIND zone
    1              0.000006 au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            " Calendar
    1              0.000011 au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
    1              0.000004 au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
    1              0.000008 au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
    1              0.000003 au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
    1              0.000003 au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
    1              0.000004 au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
    1              0.000006 au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
    1              0.000004 au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
    1              0.000003 au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " Git
    1              0.000006 au BufNewFile,BufRead */.gitconfig.d/*,/etc/gitconfig.d/*	call s:StarSetf('gitconfig')
                            
                            " Gitolite
    1              0.000004 au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
                            
                            " GTK RC
    1              0.000004 au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
    1              0.000004 au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
    1              0.000060 au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
    1              0.000004 au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Kconfig
    1              0.000003 au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
    1              0.000003 au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
    1              0.000004 au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
    1              0.000003 au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
    1              0.000003 au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
    1              0.000008 au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
    1              0.000003 au BufNewFile,BufRead reportbug-*		call s:StarSetf('mail')
                            
                            " Modconf
    1              0.000004 au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
    1              0.000003 au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
    1              0.000006 au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
    1              0.000005 au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Neomutt setup file
    1              0.000005 au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*	call s:StarSetf('neomuttrc')
    1              0.000004 au BufNewFile,BufRead neomuttrc*,Neomuttrc*		call s:StarSetf('neomuttrc')
                            
                            " Nroff macros
    1              0.000003 au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " OpenBSD hostname.if
    1              0.000003 au BufNewFile,BufRead /etc/hostname.*		call s:StarSetf('config')
                            
                            " Pam conf
    1              0.000003 au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
    1              0.000003 au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
    1              0.000003 au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
    1              0.000003 au BufRead,BufNewFile *.rdf			call polyglot#ft#Redif()
                            
                            " Remind
    1              0.000003 au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " SGML catalog file
    1              0.000003 au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " Shell scripts ending in a star
    1              0.000017 au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,,PKGBUILD* call polyglot#ft#SetFileTypeSH("bash")
    1              0.000003 au BufNewFile,BufRead .kshrc* call polyglot#ft#SetFileTypeSH("ksh")
    1              0.000004 au BufNewFile,BufRead .profile* call polyglot#ft#SetFileTypeSH(getline(1))
                            
                            " tcsh scripts ending in a star
    1              0.000002 au BufNewFile,BufRead .tcshrc*	call polyglot#ft#SetFileTypeShell("tcsh")
                            
                            " csh scripts ending in a star
    1              0.000004 au BufNewFile,BufRead .login*,.cshrc*  call polyglot#ft#CSH()
                            
                            " VHDL
    1              0.000004 au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
    1              0.000002 au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
    1              0.000004 au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
    1              0.000008 au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
    1              0.000004 au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
    1              0.000004 au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
    1              0.000003 au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
    1              0.000003 au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
    1              0.000006 au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script ending in a star
    1              0.000005 au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
    1              0.000004 au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Help files match *.txt but should have a last line that is a modeline.
    1              0.000004 au BufNewFile,BufRead *.txt
                            	\  if getline('$') !~ 'vim:.*ft=help'
                            	\|   setf text
                            	\| endif
                            
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
    1              0.000001 augroup END
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes. No need to load if everything is enabled
    1              0.000003 if exists("did_load_filetypes") && exists("g:polyglot_disabled")
                              unlet did_load_filetypes
                              runtime! extras/filetype.vim
    1              0.000000 endif
                            
    1              0.000019 let s:runtime = resolve($VIMRUNTIME)
    1              0.000079 let s:base = resolve(expand('<sfile>:p:h:h:h'))
                            
    1              0.000017 func! s:process_rtp(rtp)
                              " Remove vim-polyglot from paths and make everything absolute
                              let rtp = []
                              for path in a:rtp[1:-2]
                                let abspath = resolve(path)
                                if stridx(abspath, s:base) != 0
                                  call add(rtp, abspath)
                                endif
                              endfor
                              let result = [a:rtp[0]]
                              " Then all other stuff (until vimruntime)
                              let i = 0
                              for path in rtp[0:len(rtp)-1]
                                if path == s:runtime
                                  break
                                endif
                                call add(result, path)
                                let i = i + 1
                              endfor
                              " Then vim-polyglot
                              call add(result, s:base)
                              " Then all other files, until after-files
                              while i < len(rtp)
                                let path = rtp[i]
                                if match(path, '[/\\]after$') > -1
                                  break
                                endif
                                call add(result, path)
                                let i = i + 1
                              endwhile
                              " Then vim-polyglot after path
                              call add(result, s:base . '/after')
                              " Then all other after paths
                              while i < len(rtp)
                                let path = rtp[i]
                                call add(result, path)
                                let i = i + 1
                              endwhile
                              " User's after directory is always last
                              call add(result, a:rtp[len(a:rtp)-1])
                              return result
                            endfunc
                            
                            " We want vim-polyglot files to load only as fallback
    1   0.000877   0.000042 let &rtp = join(s:process_rtp(split(&rtp, ',')), ',')
                            
                            " Restore 'cpoptions'
    1              0.000005 let &cpo = s:cpo_save
    1              0.000017 unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/filetype.vim
Sourced 2 times
Total time:   0.009118
 Self time:   0.008057

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2021 Nov 16
                            
                            " Listen very carefully, I will say this only once
    2              0.000006 if exists("did_load_filetypes")
    1              0.000001   finish
    1              0.000000 endif
    1              0.000002 let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000004 let s:cpo_save = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000001 augroup filetypedetect
                            
                            " Ignored extensions
    1              0.000002 if exists("*fnameescape")
    1              0.000031 au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
    1              0.000006 au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
    1              0.000003 au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
                            elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
    1              0.000000 endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
    1              0.000002 if !exists("g:ft_ignore_pat")
    1              0.000002   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
    1              0.000000 endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
                            " When using this, the entry should probably be further down below with the
                            " other StarSetf() calls.
    1              0.000002 func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Vim help file
    1              0.000018 au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt setf help
                            
                            " Abaqus or Trasys
    1              0.000003 au BufNewFile,BufRead *.inp			call dist#ft#Check_inp()
                            
                            " 8th (Firth-derivative)
    1              0.000003 au BufNewFile,BufRead *.8th			setf 8th
                            
                            " A-A-P recipe
    1              0.000002 au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
    1              0.000010 au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
    1              0.000003 au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
    1              0.000002 au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
    1              0.000002 au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
    1              0.000002 au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
    1              0.000005 au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
    1              0.000002 au BufNewFile,BufRead *.gpr			setf ada
                            
                            " AHDL
    1              0.000004 au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AIDL
    1              0.000002 au BufNewFile,BufRead *.aidl			setf aidl
                            
                            " AMPL
    1              0.000002 au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
    1              0.000003 au BufNewFile,BufRead build.xml			setf ant
                            
                            " Arduino
    1              0.000004 au BufNewFile,BufRead *.ino,*.pde		setf arduino
                            
                            " Apache config file
    1              0.000006 au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
    1              0.000006 au BufNewFile,BufRead */etc/apache2/sites-*/*.com		setf apache
                            
                            " XA65 MOS6510 cross assembler
    1              0.000002 au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
    1              0.000002 au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
    1              0.000003 au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
    1              0.000010 au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
    1              0.000002 au BufNewFile,BufRead *.aml			setf aml
                            
                            " APT config file
    1              0.000004 au BufNewFile,BufRead apt.conf		       setf aptconf
    1              0.000003 au BufNewFile,BufRead */.aptitude/config       setf aptconf
    1              0.000012 au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
                            
                            " Arch Inventory file
    1              0.000006 au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
    1              0.000002 au BufNewFile,BufRead *.art			setf art
                            
                            " AsciiDoc
    1              0.000005 au BufNewFile,BufRead *.asciidoc,*.adoc		setf asciidoc
                            
                            " ASN.1
    1              0.000003 au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
    1              0.000004 au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
    1              0.000006 au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before catch *.lst)
    1              0.000010 au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
    1              0.000009 au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call dist#ft#FTasm()
                            
                            " Macro (VAX)
    1              0.000002 au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Atlas
    1              0.000004 au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Atom is based on XML
    1              0.000002 au BufNewFile,BufRead *.atom			setf xml
                            
                            " Autoit v3
    1              0.000002 au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
    1              0.000002 au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
    1              0.000010 au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
    1              0.000002 au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
    1              0.000002 au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
    1              0.000003 au BufNewFile,BufRead *.awk,*.gawk		setf awk
                            
                            " B
    1              0.000005 au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
    1              0.000002 au BufNewFile,BufRead *.bas			call dist#ft#FTVB("basic")
                            
                            " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
    1              0.000006 au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb
                            
                            " IBasic file (similar to QBasic)
    1              0.000004 au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
    1              0.000004 au BufNewFile,BufRead *.fb,*.bi			setf freebasic
                            
                            " Batch file for MSDOS.
    1              0.000004 au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
    1              0.000004 au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
    1              0.000002 au BufNewFile,BufRead *.btm			call dist#ft#FTbtm()
                            
                            " BC calculator
    1              0.000002 au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
    1              0.000003 au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " Beancount
    1              0.000003 au BufNewFile,BufRead *.beancount		setf beancount
                            
                            " BibTeX bibliography database file
    1              0.000002 au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
    1              0.000002 au BufNewFile,BufRead *.bst			setf bst
                            
                            " BIND configuration
                            " sudoedit uses namedXXXX.conf
    1              0.000014 au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key	setf named
                            
                            " BIND zone
    1              0.000003 au BufNewFile,BufRead named.root		setf bindzone
    1              0.000002 au BufNewFile,BufRead *.db			call dist#ft#BindzoneCheck('')
                            
                            " Blank
    1              0.000002 au BufNewFile,BufRead *.bl			setf blank
                            
                            " Blkid cache file
    1              0.000008 au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " BSDL
    1              0.000004 au BufNewFile,BufRead *bsd,*.bsdl		setf bsdl
                            
                            " Bazel (http://bazel.io)
    1              0.000007 autocmd BufRead,BufNewFile *.bzl,*.bazel,WORKSPACE	setf bzl
    1              0.000002 if has("fname_case")
                              " There is another check for BUILD further below.
    1              0.000005   autocmd BufRead,BufNewFile *.BUILD,BUILD		setf bzl
    1              0.000000 endif
                            
                            " C or lpc
    1              0.000002 au BufNewFile,BufRead *.c			call dist#ft#FTlpc()
    1              0.000004 au BufNewFile,BufRead *.lpc,*.ulpc		setf lpc
                            
                            " Calendar
    1              0.000002 au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
    1              0.000002 au BufNewFile,BufRead *.cs			setf cs
                            
                            " CSDL
    1              0.000002 au BufNewFile,BufRead *.csdl			setf csdl
                            
                            " Cabal
    1              0.000003 au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
    1              0.000002 au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
    1              0.000012 au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
    1              0.000004 au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
    1              0.000002 au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Comshare Dimension Definition Language
    1              0.000003 au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
    1              0.000002 au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
    1              0.000002 au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
    1              0.000002 au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
    1              0.000003 au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
    1              0.000003 au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
    1              0.000015 au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
    1              0.000001 if has("fname_case")
    1              0.000004   au BufNewFile,BufRead *.C,*.H setf cpp
    1              0.000000 endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
    1              0.000002 au BufNewFile,BufRead *.h			call dist#ft#FTheader()
                            
                            " Ch (CHscript)
    1              0.000003 au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
    1              0.000002 au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
    1              0.000002 au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
    1              0.000002 au BufNewFile,BufRead *.con			setf cterm
                            
                            " Changelog
    1              0.000015 au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch,*/debian/changelog
                            					\	setf debchangelog
                            
    1              0.000004 au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
    1              0.000003 au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
    1              0.000003 au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
    1              0.000003 au BufNewFile,BufRead *.ch			call dist#ft#FTchange()
                            
                            " ChordPro
    1              0.000009 au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
    1              0.000003 au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
    1              0.000002 au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
    1              0.000003 au BufNewFile,BufRead *.ent			call dist#ft#FTent()
                            
                            " Clipper (or FoxPro; could also be eviews)
    1              0.000003 au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
                            " Clojure
    1              0.000008 au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc		setf clojure
                            
                            " Cmake
    1              0.000007 au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
    1              0.000009 au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
    1              0.000004 au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
    1              0.000007 au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
    1              0.000003 au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
    1              0.000002 au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
    1              0.000014 au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
    1              0.000005 au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " CUDA Compute Unified Device Architecture
    1              0.000004 au BufNewFile,BufRead *.cu,*.cuh		setf cuda
                            
                            " Dockerfilb; Podman uses the same syntax with name Containerfile
    1              0.000008 au BufNewFile,BufRead Containerfile,Dockerfile,*.Dockerfile	setf dockerfile
                            
                            " WildPackets EtherPeek Decoder
    1              0.000002 au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
    1              0.000004 au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
    1              0.000004 au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Elixir or Euphoria
    1              0.000002 au BufNewFile,BufRead *.ex call dist#ft#ExCheck()
                            
                            " Elixir
    1              0.000003 au BufRead,BufNewFile mix.lock,*.exs setf elixir
    1              0.000006 au BufRead,BufNewFile *.eex,*.leex setf eelixir
                            
                            " Euphoria 3 or 4
    1              0.000006 au BufNewFile,BufRead *.eu,*.ew,*.exu,*.exw  call dist#ft#EuphoriaCheck()
    1              0.000001 if has("fname_case")
    1              0.000009    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
    1              0.000000 endif
                            
                            " Lynx config files
    1              0.000002 au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " Modula-3 configuration language (must be before *.cfg and *makefile)
    1              0.000005 au BufNewFile,BufRead *.quake,cm3.cfg		setf m3quake
    1              0.000004 au BufNewFile,BufRead m3makefile,m3overrides	setf m3build
                            
                            " Quake
    1              0.000008 au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
    1              0.000003 au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
    1              0.000002 au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
    1              0.000002 au BufNewFile,BufRead *.cfg			setf cfg
                            
                            " Cucumber
    1              0.000003 au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
    1              0.000003 au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
    1              0.000003 au BufNewFile,BufRead *.pld			setf cupl
    1              0.000002 au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Dart
    1              0.000003 au BufRead,BufNewfile *.dart,*.drt		setf dart
                            
                            " Debian Control
    1              0.000004 au BufNewFile,BufRead */debian/control		setf debcontrol
    1              0.000003 au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Copyright
    1              0.000004 au BufNewFile,BufRead */debian/copyright	setf debcopyright
    1              0.000003 au BufNewFile,BufRead copyright
                            	\  if getline(1) =~ '^Format:'
                            	\|   setf debcopyright
                            	\| endif
                            
                            " Debian Sources.list
    1              0.000005 au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
    1              0.000005 au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
    1              0.000003 au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
    1              0.000003 au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
    1              0.000002 au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
    1              0.000004 au BufNewFile,BufRead *.d			call dist#ft#DtraceCheck()
                            
                            " Desktop files
    1              0.000004 au BufNewFile,BufRead *.desktop,*.directory	setf desktop
                            
                            " Dict config
    1              0.000006 au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
    1              0.000003 au BufNewFile,BufRead dictd*.conf		setf dictdconf
                            
                            " Diff files
    1              0.000003 au BufNewFile,BufRead *.diff,*.rej		setf diff
    1              0.000004 au BufNewFile,BufRead *.patch
                            	\ if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |
                            	\   setf gitsendemail |
                            	\ else |
                            	\   setf diff |
                            	\ endif
                            
                            " Dircolors
    1              0.000009 au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
    1              0.000003 au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
    1              0.000002 au BufNewFile,BufRead *.com			call dist#ft#BindzoneCheck('dcl')
                            
                            " DOT
    1              0.000003 au BufNewFile,BufRead *.dot,*.gv		setf dot
                            
                            " Dune
    1              0.000009 au BufNewFile,BufRead jbuild,dune,dune-project,dune-workspace setf dune
                            
                            " Dylan - lid files
    1              0.000003 au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
    1              0.000003 au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
    1              0.000002 au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
    1              0.000002 au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
    1              0.000007 au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
    1              0.000002 au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl: DSSSL or Structurizr
    1              0.000004 au BufNewFile,BufRead *.dsl
                            	\ if getline(1) =~ '^\s*<\!' |
                            	\   setf dsl |
                            	\ else |
                            	\   setf structurizr |
                            	\ endif
                            
                            " DTD (Document Type Definition for XML)
    1              0.000006 au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " DTS/DSTI (device tree files)
    1              0.000003 au BufNewFile,BufRead *.dts,*.dtsi		setf dts
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
    1              0.000004 au BufNewFile,BufRead *.ed\(f\|if\|o\)		setf edif
    1              0.000004 au BufNewFile,BufRead *.edn
                            	\ if getline(1) =~ '^\s*(\s*edif\>' |
                            	\   setf edif |
                            	\ else |
                            	\   setf clojure |
                            	\ endif
                            
                            " EditorConfig (close enough to dosini)
    1              0.000004 au BufNewFile,BufRead .editorconfig		setf dosini
                            
                            " Embedix Component Description
    1              0.000003 au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman or Euphoria
    1              0.000003 au BufNewFile,BufRead *.e,*.E			call dist#ft#FTe()
                            
                            " Elinks configuration
    1              0.000004 au BufNewFile,BufRead elinks.conf		setf elinks
                            
                            " ERicsson LANGuage; Yaws is erlang too
    1              0.000006 au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm
    1              0.000002 au BufNewFile,BufRead *.elm			setf elm
                            
                            " Elm Filter Rules file
    1              0.000003 au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
    1              0.000002 au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
    1              0.000004 au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
    1              0.000002 au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
    1              0.000002 au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
    1              0.000004 au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
    1              0.000003 au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
    1              0.000002 au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
    1              0.000002 au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
    1              0.000004 au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
    1              0.000002 au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fennel
    1              0.000002 autocmd BufRead,BufNewFile *.fnl		setf fennel
                            
                            " Fetchmail RC file
    1              0.000004 au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " Fish shell
    1              0.000002 au BufNewFile,BufRead *.fish			setf fish
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
    1              0.000005 au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
    1              0.000002 au BufNewFile,BufRead auto.master		setf conf
    1              0.000005 au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
    1              0.000003 au BufNewFile,BufRead *.ft,*.fth		setf forth
                            
                            " Reva Forth
    1              0.000002 au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
    1              0.000003 if has("fname_case")
    1              0.000014   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
    1              0.000001 endif
    1              0.000017 au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
    1              0.000002 au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
    1              0.000004 au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " F# or Forth
    1              0.000003 au BufNewFile,BufRead *.fs			call dist#ft#FTfs()
                            
                            " F#
    1              0.000003 au BufNewFile,BufRead *.fsi,*.fsx		setf fsharp
                            
                            " GDB command files
    1              0.000006 au BufNewFile,BufRead .gdbinit,gdbinit		setf gdb
                            
                            " GDMO
    1              0.000003 au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " Gedcom
    1              0.000005 au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Gemtext
    1              0.000003 au BufNewFile,BufRead *.gmi,*.gemini		setf gemtext
                            
                            " Gift (Moodle)
    1              0.000002 autocmd BufRead,BufNewFile *.gift		setf gift
                            
                            " Git
    1              0.000009 au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG 	setf gitcommit
    1              0.000007 au BufNewFile,BufRead *.git/config,.gitconfig,/etc/gitconfig 	setf gitconfig
    1              0.000003 au BufNewFile,BufRead */.config/git/config			setf gitconfig
    1              0.000007 au BufNewFile,BufRead .gitmodules,*.git/modules/*/config	setf gitconfig
    1              0.000005 if !empty($XDG_CONFIG_HOME)
                              au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config		setf gitconfig
    1              0.000001 endif
    1              0.000004 au BufNewFile,BufRead git-rebase-todo		setf gitrebase
    1              0.000004 au BufRead,BufNewFile .gitsendemail.msg.??????	setf gitsendemail
    1              0.000004 au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
    1              0.000003 au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
    1              0.000005 au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " GP scripts (2.0 and onward)
    1              0.000004 au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
    1              0.000004 au BufNewFile,BufRead */.gnupg/options		setf gpg
    1              0.000003 au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
    1              0.000004 au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
    1              0.000002 if !empty($GNUPGHOME)
                              au BufNewFile,BufRead $GNUPGHOME/options	setf gpg
                              au BufNewFile,BufRead $GNUPGHOME/gpg.conf	setf gpg
    1              0.000000 endif
                            
                            " gnash(1) configuration files
    1              0.000010 au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
    1              0.000003 au BufNewFile,BufRead gitolite.conf		setf gitolite
    1              0.000007 au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl
                            
                            " Gnuplot scripts
    1              0.000003 au BufNewFile,BufRead *.gpi			setf gnuplot
                            
                            " Go (Google)
    1              0.000002 au BufNewFile,BufRead *.go			setf go
    1              0.000004 au BufNewFile,BufRead Gopkg.lock		setf toml
                            
                            " GrADS scripts
    1              0.000002 au BufNewFile,BufRead *.gs			setf grads
                            
                            " Gretl
    1              0.000002 au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
    1              0.000005 au BufNewFile,BufRead *.gradle,*.groovy		setf groovy
                            
                            " GNU Server Pages
    1              0.000002 au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
    1              0.000025 au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
    1              0.000004 au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " Haml
    1              0.000002 au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
    1              0.000003 au BufNewFile,BufRead *.hsm			setf hamster
                            
                            " Haskell
    1              0.000007 au BufNewFile,BufRead *.hs,*.hsc,*.hs-boot,*.hsig setf haskell
    1              0.000002 au BufNewFile,BufRead *.lhs			setf lhaskell
    1              0.000003 au BufNewFile,BufRead *.chs			setf chaskell
    1              0.000003 au BufNewFile,BufRead cabal.project		setf cabalproject
    1              0.000007 au BufNewFile,BufRead $HOME/.cabal/config	setf cabalconfig
    1              0.000003 au BufNewFile,BufRead cabal.config		setf cabalconfig
                            
                            " Haste
    1              0.000002 au BufNewFile,BufRead *.ht			setf haste
    1              0.000003 au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " Hercules
    1              0.000006 au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum	setf hercules
                            
                            " HEX (Intel)
    1              0.000004 au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Hollywood
    1              0.000002 au BufRead,BufNewFile *.hws			setf hollywood
                            
                            " Tilde (must be before HTML)
    1              0.000002 au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
    1              0.000007 au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
                            
                            " HTML with Ruby - eRuby
    1              0.000003 au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
    1              0.000004 au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " Some template.  Used to be HTML Cheetah.
    1              0.000002 au BufNewFile,BufRead *.tmpl			setf template
                            
                            " Host config
    1              0.000003 au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
    1              0.000006 au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
    1              0.000003 au BufNewFile,BufRead *.hb			setf hb
                            
                            " Httest
    1              0.000004 au BufNewFile,BufRead *.htt,*.htb		setf httest
                            
                            " Icon
    1              0.000002 au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
    1              0.000002 au BufNewFile,BufRead *.idl			call dist#ft#FTidl()
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
    1              0.000005 au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
    1              0.000003 au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
    1              0.000003 au BufNewFile,BufRead .indent.pro		setf indent
    1              0.000004 au BufNewFile,BufRead indent.pro		call dist#ft#ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
    1              0.000003 au BufNewFile,BufRead *.pro			call dist#ft#ProtoCheck('idlang')
                            
                            " Indent RC
    1              0.000003 au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
    1              0.000003 au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
    1              0.000007 au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng
                            
                            " Innovation Data Processing
    1              0.000009 au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c	setf upstreamdat
    1              0.000015 au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c	setf upstreamlog
    1              0.000010 au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
    1              0.000009 au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c	setf usserverlog
    1              0.000009 au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c	setf usw2kagtlog
                            
                            " Ipfilter
    1              0.000008 au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
    1              0.000005 au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
    1              0.000004 au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
    1              0.000002 au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
    1              0.000002 au BufNewFile,BufRead *.iss			setf iss
                            
                            " J
    1              0.000002 au BufNewFile,BufRead *.ijs			setf j
                            
                            " JAL
    1              0.000004 au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
    1              0.000003 au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
    1              0.000006 au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
    1              0.000003 au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript, ES module script, CommonJS script
    1              0.000008 au BufNewFile,BufRead *.js,*.javascript,*.es,*.mjs,*.cjs   setf javascript
                            
                            " JavaScript with React
    1              0.000002 au BufNewFile,BufRead *.jsx			setf javascriptreact
                            
                            " Java Server Pages
    1              0.000004 au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
    1              0.000008 au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
                            
                            " Jess
    1              0.000002 au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
    1              0.000002 au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
    1              0.000006 au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " JSON
    1              0.000007 au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest	setf json
                            
                            " JSON Patch (RFC 6902)
    1              0.000002 au BufNewFile,BufRead *.json-patch			setf json
                            
                            " Jupyter Notebook is also json
    1              0.000002 au BufNewFile,BufRead *.ipynb				setf json
                            
                            " Other files that look like json
    1              0.000010 au BufNewFile,BufRead .babelrc,.eslintrc,.prettierrc,.firebaserc  setf json
                            
                            " JSONC
    1              0.000002 au BufNewFile,BufRead *.jsonc			setf jsonc
                            
                            " Julia
    1              0.000002 au BufNewFile,BufRead *.jl			setf julia
                            
                            " Kixtart
    1              0.000003 au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kimwitu[++]
    1              0.000002 au BufNewFile,BufRead *.k			setf kwt
                            
                            " Kivy
    1              0.000002 au BufNewFile,BufRead *.kv			setf kivy
                            
                            " Kotlin
    1              0.000005 au BufNewFile,BufRead *.kt,*.ktm,*.kts		setf kotlin
                            
                            " KDE script
    1              0.000002 au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
    1              0.000007 au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
    1              0.000003 au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latte
    1              0.000003 au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
    1              0.000015 au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog (*.mod too, see Modsim)
    1              0.000003 au BufNewFile,BufRead *.sig			setf lprolog
                            
                            " LDAP LDIF
    1              0.000002 au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
    1              0.000002 au BufNewFile,BufRead *.ld			setf ld
                            
                            " Less
    1              0.000002 au BufNewFile,BufRead *.less			setf less
                            
                            " Lex
    1              0.000006 au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex
                            
                            " Libao
    1              0.000006 au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
    1              0.000007 au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
    1              0.000005 au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
    1              0.000002 au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
    1              0.000007 au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp)
                            " *.jl was removed, it's also used for Julia, better skip than guess wrong.
    1              0.000002 if has("fname_case")
    1              0.000013   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.L,.emacs,.sawfishrc setf lisp
                            else
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,.emacs,.sawfishrc setf lisp
    1              0.000000 endif
                            
                            " SBCL implementation of Common Lisp
    1              0.000005 au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
    1              0.000002 au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
    1              0.000003 au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
    1              0.000005 au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
    1              0.000003 au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
    1              0.000003 au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
    1              0.000002 au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
    1              0.000005 au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
    1              0.000003 au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
    1              0.000002 au BufNewFile,BufRead *.lua			setf lua
                            
                            " Luarocks
    1              0.000004 au BufNewFile,BufRead *.rockspec		setf lua
                            
                            " Linden Scripting Language (Second Life)
    1              0.000002 au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
    1              0.000002 au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
    1              0.000003 au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
    1              0.000003 au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
    1              0.000043 au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
    1              0.000006 au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
    1              0.000004 au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
    1              0.000008 au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
    1              0.000004 au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Mallard
    1              0.000002 au BufNewFile,BufRead *.page			setf mallard
                            
                            " Manpage
    1              0.000002 au BufNewFile,BufRead *.man			setf nroff
                            
                            " Man config
    1              0.000005 au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
    1              0.000005 au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
    1              0.000002 au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
    1              0.000011 au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
                            
                            " Mason
    1              0.000005 au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason
                            
                            " Mathematica, Matlab, Murphi, Objective C or Octave
    1              0.000003 au BufNewFile,BufRead *.m			call dist#ft#FTm()
                            
                            " Mathematica notebook
    1              0.000002 au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
    1              0.000002 au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial (hg) commit file
    1              0.000005 au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit
                            
                            " Mercurial config (looks like generic config file)
    1              0.000004 au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Meson Build system config
    1              0.000009 au BufNewFile,BufRead meson.build,meson_options.txt setf meson
    1              0.000002 au BufNewFile,BufRead *.wrap			setf dosini
                            
                            " Messages (logs mostly)
    1              0.000018 au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
    1              0.000004 au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
    1              0.000002 au BufNewFile,BufRead *.mp			setf mp
                            
                            " MGL
    1              0.000002 au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MIX - Knuth assembly
    1              0.000005 au BufNewFile,BufRead *.mix,*.mixal		setf mix
                            
                            " MMIX or VMS makefile
    1              0.000002 au BufNewFile,BufRead *.mms			call dist#ft#FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
    1              0.000002 au BufNewFile,BufRead *.mmp			setf mmp
                            
                            " Modsim III (or LambdaProlog)
    1              0.000004 au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Modula-2  (.md removed in favor of Markdown)
    1              0.000007 au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi	setf modula2
                            
                            " Modula-3 (.m3, .i3, .mg, .ig)
    1              0.000003 au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
    1              0.000008 au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
    1              0.000003 au BufNewFile,BufRead *.moo			setf moo
                            
                            " Modconf
    1              0.000009 au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " MPD is based on XML
    1              0.000002 au BufNewFile,BufRead *.mpd			setf xml
                            
                            " Mplayer config
    1              0.000006 au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Motorola S record
    1              0.000008 au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec	setf srec
                            
                            " Mrxvtrc
    1              0.000005 au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
    1              0.000002 au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
    1              0.000002 au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Mutt setup files (must be before catch *.rc)
    1              0.000006 au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " Tcl Shell RC file
    1              0.000002 au BufNewFile,BufRead tclsh.rc			setf tcl
                            
                            " M$ Resource files
    1              0.000005 au BufNewFile,BufRead *.rc,*.rch		setf rc
                            
                            " MuPAD source
    1              0.000002 au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
    1              0.000002 au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
    1              0.000004 au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " N1QL
    1              0.000005 au BufRead,BufNewfile *.n1ql,*.nql		setf n1ql
                            
                            " Nano
    1              0.000004 au BufNewFile,BufRead */etc/nanorc,*.nanorc	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
    1              0.000003 au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Noemutt setup file
    1              0.000004 au BufNewFile,BufRead Neomuttrc			setf neomuttrc
                            
                            " Netrc
    1              0.000002 au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Nginx
    1              0.000016 au BufNewFile,BufRead *.nginx,nginx*.conf,*nginx.conf,*/etc/nginx/*,*/usr/local/nginx/conf/*,*/nginx/*.conf			setf nginx
                            
                            " Ninja file
    1              0.000002 au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " NPM RC file
    1              0.000010 au BufNewFile,BufRead npmrc,.npmrc		setf dosini
                            
                            " Novell netware batch files
    1              0.000002 au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
    1              0.000003 au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
    1              0.000009 au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
    1              0.000002 au BufNewFile,BufRead *.[1-9]			call dist#ft#FTnroff()
                            
                            " Nroff or Objective C++
    1              0.000002 au BufNewFile,BufRead *.mm			call dist#ft#FTmm()
                            
                            " Not Quite C
    1              0.000002 au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSE - Nmap Script Engine - uses Lua syntax
    1              0.000002 au BufNewFile,BufRead *.nse			setf lua
                            
                            " NSIS
    1              0.000004 au BufNewFile,BufRead *.nsi,*.nsh		setf nsis
                            
                            " OCaml
    1              0.000017 au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit,*.mlt,*.mlp,*.mlip,*.mli.cppo,*.ml.cppo setf ocaml
                            
                            " Occam
    1              0.000002 au BufNewFile,BufRead *.occ			setf occam
                            
                            " Octave
    1              0.000010 au BufNewFile,BufRead octave.conf,.octaverc,octaverc	setf octave
                            
                            " Omnimark
    1              0.000005 au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OPAM
    1              0.000006 au BufNewFile,BufRead opam,*.opam,*.opam.template setf opam
                            
                            " OpenROAD
    1              0.000003 au BufNewFile,BufRead *.or			setf openroad
                            
                            " OPL
    1              0.000003 au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl
                            
                            " Oracle config file
    1              0.000002 au BufNewFile,BufRead *.ora			setf ora
                            
                            " Packet filter conf
    1              0.000003 au BufNewFile,BufRead pf.conf			setf pf
                            
                            " Pacman Config (close enough to dosini)
    1              0.000003 au BufNewFile,BufRead */etc/pacman.conf		setf dosini
                            
                            " Pacman hooks
    1              0.000003 au BufNewFile,BufRead *.hook
                            	\ if getline(1) == '[Trigger]' |
                            	\   setf dosini |
                            	\ endif
                            
                            " Pam conf
    1              0.000004 au BufNewFile,BufRead */etc/pam.conf			setf pamconf
                            
                            " Pam environment
    1              0.000006 au BufNewFile,BufRead pam_env.conf,.pam_environment	setf pamenv
                            
                            " PApp
    1              0.000004 au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp
                            
                            " Password file
    1              0.000023 au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p, *.pp, *.inc)
    1              0.000002 au BufNewFile,BufRead *.pas			setf pascal
                            
                            " Pascal or Puppet manifest
    1              0.000002 au BufNewFile,BufRead *.pp			call dist#ft#FTpp()
                            
                            " Delphi or Lazarus program file
    1              0.000004 au BufNewFile,BufRead *.dpr,*.lpr		setf pascal
                            
                            " Free Pascal makefile definition file
    1              0.000002 au BufNewFile,BufRead *.fpc			setf fpcmake
                            
                            " PDF
    1              0.000002 au BufNewFile,BufRead *.pdf			setf pdf
                            
                            " PCMK - HAE - crm configure edit
    1              0.000002 au BufNewFile,BufRead *.pcmk			setf pcmk
                            
                            " Perl
    1              0.000002 if has("fname_case")
    1              0.000006   au BufNewFile,BufRead *.pl,*.PL		call dist#ft#FTpl()
                            else
                              au BufNewFile,BufRead *.pl			call dist#ft#FTpl()
    1              0.000000 endif
    1              0.000005 au BufNewFile,BufRead *.plx,*.al,*.psgi		setf perl
                            
                            " Perl, XPM or XPM2
    1              0.000003 au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
    1              0.000002 au BufNewFile,BufRead *.pod			setf pod
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past)
                            " Also .ctp for Cake template file
    1              0.000008 au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php
                            
                            " PHP config
    1              0.000002 au BufNewFile,BufRead php.ini-*			setf dosini
                            
                            " Pike and Cmod
    1              0.000005 au BufNewFile,BufRead *.pike,*.pmod		setf pike
    1              0.000002 au BufNewFile,BufRead *.cmod			setf cmod
                            
                            " Pinfo config
    1              0.000004 au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
    1              0.000002 au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
    1              0.000009 au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " Pipenv Pipfiles
    1              0.000003 au BufNewFile,BufRead Pipfile			setf toml
    1              0.000004 au BufNewFile,BufRead Pipfile.lock		setf json
                            
                            " PL/1, PL/I
    1              0.000004 au BufNewFile,BufRead *.pli,*.pl1		setf pli
                            
                            " PL/M (also: *.inp)
    1              0.000004 au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
    1              0.000004 au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
    1              0.000002 au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
    1              0.000004 au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
    1              0.000002 au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
    1              0.000011 au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
    1              0.000003 au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
    1              0.000002 au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
    1              0.000002 au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, Pascal, PHP or assembly
    1              0.000002 au BufNewFile,BufRead *.inc			call dist#ft#FTinc()
                            
                            " PowerShell
    1              0.000007 au BufNewFile,BufRead	*.ps1,*.psd1,*.psm1,*.pssc	setf ps1
    1              0.000006 au BufNewFile,BufRead	*.ps1xml			setf ps1xml
    1              0.000003 au BufNewFile,BufRead	*.cdxml,*.psc1			setf xml
                            
                            " Printcap and Termcap
    1              0.000003 au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
    1              0.000005 au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " PCCTS / ANTLR
                            "au BufNewFile,BufRead *.g			setf antlr
    1              0.000002 au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
    1              0.000003 au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Puppet
    1              0.000003 au BufNewFile,BufRead Puppetfile		setf ruby
                            
                            " Embedded Puppet
    1              0.000002 au BufNewFile,BufRead *.epp			setf epuppet
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
    1              0.000003 au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
    1              0.000002 au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
    1              0.000002 au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
    1              0.000006 au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
    1              0.000003 au BufNewFile,BufRead *.w			call dist#ft#FTprogress_cweb()
                            
                            " Progress or assembly
    1              0.000002 au BufNewFile,BufRead *.i			call dist#ft#FTprogress_asm()
                            
                            " Progress or Pascal
    1              0.000002 au BufNewFile,BufRead *.p			call dist#ft#FTprogress_pascal()
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
    1              0.000002 au BufNewFile,BufRead *.psf			setf psf
    1              0.000006 au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
    1              0.000002 au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
    1              0.000002 au BufNewFile,BufRead *.pml			setf promela
                            
                            " Property Specification Language (PSL)
    1              0.000003 au BufNewFile,BufRead *.psl			setf psl
                            
                            " Google protocol buffers
    1              0.000002 au BufNewFile,BufRead *.proto			setf proto
    1              0.000002 au BufNewFile,BufRead *.pbtxt			setf pbtxt
                            
                            " Poke
    1              0.000002 au BufNewFile,BufRead *.pk			setf poke
                            
                            " Protocols
    1              0.000004 au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyret
    1              0.000002 au BufNewFile,BufRead *.arr			setf pyret
                            
                            " Pyrex
    1              0.000004 au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python, Python Shell Startup and Python Stub Files
                            " Quixote (Python-based web framework)
    1              0.000009 au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc  setf python
    1              0.000006 au BufNewFile,BufRead *.ptl,*.pyi,SConstruct		   setf python
                            
                            " Radiance
    1              0.000003 au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Raku (formerly Perl6)
    1              0.000015 au BufNewFile,BufRead *.pm6,*.p6,*.t6,*.pod6,*.raku,*.rakumod,*.rakudoc,*.rakutest  setf raku
                            
                            " Ratpoison config/command files
    1              0.000006 au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
    1              0.000002 au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
    1              0.000004 au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
    1              0.000004 au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
    1              0.000002 au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rego Policy Language
    1              0.000002 au BufNewFile,BufRead *.rego			setf rego
                            
                            " Rexx
    1              0.000016 au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx
                            
                            " R Help file
    1              0.000001 if has("fname_case")
    1              0.000004   au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
                            else
                              au BufNewFile,BufRead *.rd			setf rhelp
    1              0.000000 endif
                            
                            " R noweb file
    1              0.000001 if has("fname_case")
    1              0.000008   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
                            else
                              au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
    1              0.000000 endif
                            
                            " R Markdown file
    1              0.000001 if has("fname_case")
    1              0.000010   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
                            else
                              au BufNewFile,BufRead *.rmd,*.smd			setf rmd
    1              0.000000 endif
                            
                            " RSS looks like XML
    1              0.000002 au BufNewFile,BufRead *.rss				setf xml
                            
                            " R reStructuredText file
    1              0.000001 if has("fname_case")
    1              0.000007   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
                            else
                              au BufNewFile,BufRead *.rrst,*.srst			setf rrst
    1              0.000000 endif
                            
                            " Rexx, Rebol or R
    1              0.000003 au BufNewFile,BufRead *.r,*.R				call dist#ft#FTr()
                            
                            " Remind
    1              0.000008 au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " Resolv.conf
    1              0.000003 au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
    1              0.000002 au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " Relax NG XML
    1              0.000003 au BufNewFile,BufRead *.rng			setf rng
                            
                            " RPL/2
    1              0.000002 au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robots.txt
    1              0.000004 au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
    1              0.000003 au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " MikroTik RouterOS script
    1              0.000002 au BufRead,BufNewFile *.rsc			setf routeros
                            
                            " reStructuredText Documentation Format
    1              0.000002 au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
    1              0.000002 au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
    1              0.000007 au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
    1              0.000003 au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
    1              0.000002 au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " RBS (Ruby Signature)
    1              0.000002 au BufNewFile,BufRead *.rbs			setf rbs
                            
                            " Rackup
    1              0.000002 au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
    1              0.000002 au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
    1              0.000005 au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
    1              0.000008 au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " Rust
    1              0.000002 au BufNewFile,BufRead *.rs			setf rust
    1              0.000008 au BufNewFile,BufRead Cargo.lock,*/.cargo/config,*/.cargo/credentials	setf toml
                            
                            " S-lang (or shader language, or SmallLisp)
    1              0.000002 au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
    1              0.000003 au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
    1              0.000002 au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
    1              0.000002 au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
    1              0.000002 au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scala
    1              0.000003 au BufNewFile,BufRead *.scala,*.sc		setf scala
                            
                            " SBT - Scala Build Tool
    1              0.000002 au BufNewFile,BufRead *.sbt			setf sbt
                            
                            " Scilab
    1              0.000003 au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            " scdoc
    1              0.000002 au BufNewFile,BufRead *.scd			setf scdoc
                            
                            " SCSS
    1              0.000004 au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
    1              0.000002 au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
    1              0.000003 au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
    1              0.000002 au BufNewFile,BufRead *.sed			setf sed
                            
                            " svelte
    1              0.000003 au BufNewFile,BufRead *.svelte			setf svelte
                            
                            " Sieve (RFC 3028, 5228)
    1              0.000003 au BufNewFile,BufRead *.siv,*.sieve		setf sieve
                            
                            " Sendmail
    1              0.000004 au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
    1              0.000002 au BufNewFile,BufRead *.mc			call dist#ft#McSetf()
                            
                            " Services
    1              0.000004 au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
    1              0.000003 au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
    1              0.000003 au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
    1              0.000004 au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
    1              0.000004 au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
    1              0.000007 au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
    1              0.000006 au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
    1              0.000004 au BufNewFile,BufRead catalog			setf catalog
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds, Arch Linux PKGBUILDs and Alpine Linux APKBUILDs are actually
                            " bash scripts.
                            " NOTE: Patterns ending in a star are further down, these have lower priority.
    1              0.000027 au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,bash-fc[-.],*.ebuild,*.bash,*.eclass,PKGBUILD,APKBUILD call dist#ft#SetFileTypeSH("bash")
    1              0.000005 au BufNewFile,BufRead .kshrc,*.ksh call dist#ft#SetFileTypeSH("ksh")
    1              0.000008 au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
                            
                            " Shell script (Arch Linux) or PHP file (Drupal)
    1              0.000005 au BufNewFile,BufRead *.install
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   call dist#ft#SetFileTypeSH("bash") |
                            	\ endif
                            
                            " tcsh scripts (patterns ending in a star further below)
    1              0.000008 au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login	call dist#ft#SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
                            " (patterns ending in a start further below)
    1              0.000016 au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
                            
                            " Z-Shell script (patterns ending in a star further below)
    1              0.000008 au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
    1              0.000009 au BufNewFile,BufRead .zshrc,.zshenv,.zlogin,.zlogout,.zcompdump setf zsh
    1              0.000003 au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
    1              0.000008 au BufNewFile,BufRead *.scm,*.ss,*.rkt,*.rktd,*.rktl 	setf scheme
                            
                            " Screen RC
    1              0.000005 au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Sexplib
    1              0.000002 au BufNewFile,BufRead *.sexp setf sexplib
                            
                            " Simula
    1              0.000002 au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
    1              0.000004 au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
    1              0.000009 au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
    1              0.000007 au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
    1              0.000006 au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
    1              0.000003 au BufNewFile,BufRead .slrnrc			setf slrnrc
    1              0.000002 au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk (and TeX)
    1              0.000002 au BufNewFile,BufRead *.st			setf st
    1              0.000004 au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
                            	\  setf rexx |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " Smarty templates
    1              0.000002 au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
    1              0.000003 au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
    1              0.000003 au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
    1              0.000004 au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
    1              0.000003 au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
    1              0.000004 au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
    1              0.000007 au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
    1              0.000002 au BufNewFile,BufRead *.rules			call dist#ft#FTRules()
                            
                            " SPARQL queries
    1              0.000004 au BufNewFile,BufRead *.rq,*.sparql		setf sparql
                            
                            " Spec (Linux RPM)
    1              0.000002 au BufNewFile,BufRead *.spec			setf spec
                            
                            " Speedup (AspenTech plant simulator)
    1              0.000005 au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
    1              0.000002 au BufNewFile,BufRead *.ice			setf slice
                            
                            " Spice
    1              0.000004 au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
    1              0.000003 au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
    1              0.000004 au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
    1              0.000011 au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
    1              0.000002 au BufNewFile,BufRead *.sql			call dist#ft#SQL()
                            
                            " SQLJ
    1              0.000002 au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
    1              0.000004 au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " OpenSSH configuration
    1              0.000006 au BufNewFile,BufRead ssh_config,*/.ssh/config		setf sshconfig
    1              0.000007 au BufNewFile,BufRead */etc/ssh/ssh_config.d/*.conf	setf sshconfig
                            
                            " OpenSSH server configuration
    1              0.000004 au BufNewFile,BufRead sshd_config			setf sshdconfig
    1              0.000005 au BufNewFile,BufRead */etc/ssh/sshd_config.d/*.conf	setf sshdconfig
                            
                            " Stata
    1              0.000007 au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata	setf stata
                            " Also *.class, but not when it's a Java bytecode file
    1              0.000003 au BufNewFile,BufRead *.class
                            	\ if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
                            
                            " SMCL
    1              0.000005 au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
    1              0.000002 au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
    1              0.000002 au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
    1              0.000003 au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Swift
    1              0.000006 au BufNewFile,BufRead *.swift			setf swift
    1              0.000003 au BufNewFile,BufRead *.swift.gyb		setf swiftgyb
                            
                            " Swift Intermediate Language
    1              0.000002 au BufNewFile,BufRead *.sil			setf sil
                            
                            " Sysctl
    1              0.000007 au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Systemd unit files
    1              0.000015 au BufNewFile,BufRead */systemd/*.{automount,dnssd,link,mount,netdev,network,nspawn,path,service,slice,socket,swap,target,timer}	setf systemd
                            " Systemd overrides
    1              0.000005 au BufNewFile,BufRead */etc/systemd/*.conf.d/*.conf	setf systemd
    1              0.000006 au BufNewFile,BufRead */etc/systemd/system/*.d/*.conf	setf systemd
    1              0.000006 au BufNewFile,BufRead */.config/systemd/user/*.d/*.conf	setf systemd
                            " Systemd temp files
    1              0.000004 au BufNewFile,BufRead */etc/systemd/system/*.d/.#*	setf systemd
    1              0.000003 au BufNewFile,BufRead */etc/systemd/system/.#*		setf systemd
    1              0.000006 au BufNewFile,BufRead */.config/systemd/user/*.d/.#*	setf systemd
    1              0.000004 au BufNewFile,BufRead */.config/systemd/user/.#*	setf systemd
                            
                            " Synopsys Design Constraints
    1              0.000002 au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
    1              0.000006 au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
    1              0.000003 au BufNewFile,BufRead *.svg			setf svg
                            
                            " Tads (or Nroff or Perl test file)
    1              0.000003 au BufNewFile,BufRead *.t
                            	\ if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
                            
                            " Tags
    1              0.000002 au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
    1              0.000002 au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
    1              0.000006 au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
    1              0.000004 au BufRead,BufNewFile *.task			setf taskedit
                            
                            " Tcl (JACL too)
    1              0.000014 au BufNewFile,BufRead *.tcl,*.tm,*.tk,*.itcl,*.itk,*.jacl,.tclshrc,.wishrc	setf tcl
                            
                            " TealInfo
    1              0.000002 au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
    1              0.000003 au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Tera Term Language or Turtle
    1              0.000003 au BufRead,BufNewFile *.ttl
                            	\ if getline(1) =~ '^@\?\(prefix\|base\)' |
                            	\   setf turtle |
                            	\ else |
                            	\   setf teraterm |
                            	\ endif
                            
                            " Terminfo
    1              0.000002 au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " TeX
    1              0.000008 au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
    1              0.000003 au BufNewFile,BufRead *.tex			call dist#ft#FTtex()
                            
                            " ConTeXt
    1              0.000008 au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi,*.mkxl,*.mklx   setf context
                            
                            " Texinfo
    1              0.000007 au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
    1              0.000002 au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
    1              0.000006 au BufNewFile,BufRead .tidyrc,tidyrc,tidy.conf	setf tidy
                            
                            " TF mud client
    1              0.000004 au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf
                            
                            " tmux configuration
    1              0.000006 au BufNewFile,BufRead {.,}tmux*.conf		setf tmux
                            
                            " TOML
    1              0.000003 au BufNewFile,BufRead *.toml			setf toml
                            
                            " TPP - Text Presentation Program
    1              0.000002 au BufNewFile,BufReadPost *.tpp			setf tpp
                            
                            " Treetop
    1              0.000002 au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
    1              0.000003 au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
    1              0.000002 au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
    1              0.000003 au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
    1              0.000002 au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " Tutor mode
    1              0.000002 au BufNewFile,BufReadPost *.tutor		setf tutor
                            
                            " TWIG files
    1              0.000002 au BufNewFile,BufReadPost *.twig		setf twig
                            
                            " Typescript or Qt translation file (which is XML)
    1              0.000004 au BufNewFile,BufReadPost *.ts
                            	\ if getline(1) =~ '<?xml' |
                            	\   setf xml |
                            	\ else |
                            	\   setf typescript |
                            	\ endif
                            
                            " TypeScript with React
    1              0.000002 au BufNewFile,BufRead *.tsx			setf typescriptreact
                            
                            " Motif UIT/UIL files
    1              0.000003 au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
    1              0.000006 au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
    1              0.000006 au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
    1              0.000004 au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
    1              0.000002 au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
    1              0.000007 au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
    1              0.000004 au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
    1              0.000006 au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
    1              0.000006 au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
    1              0.000007 au BufNewFile,BufRead */.init/*.conf,*/.init/*.override	       setf upstart
    1              0.000005 au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
    1              0.000005 au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart
                            
                            " Vera
    1              0.000006 au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Verilog HDL
    1              0.000002 au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
    1              0.000003 au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " SystemVerilog
    1              0.000004 au BufNewFile,BufRead *.sv,*.svh		setf systemverilog
                            
                            " VHDL
    1              0.000010 au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst,*.vho  setf vhdl
                            
                            " Vim script
    1              0.000007 au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
    1              0.000005 au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
    1              0.000006 au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
    1              0.000003 au BufNewFile,BufRead *.frm			call dist#ft#FTVB("form")
                            
                            " SaxBasic is close to Visual Basic
    1              0.000003 au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
    1              0.000002 au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
    1              0.000002 au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Vroom (vim testing and executable documentation)
    1              0.000002 au BufNewFile,BufRead *.vroom			setf vroom
                            
                            " Vue.js Single File Component
    1              0.000004 au BufNewFile,BufRead *.vue			setf vue
                            
                            " WebAssembly
    1              0.000003 au BufNewFile,BufRead *.wast,*.wat		setf wast
                            
                            " Webmacro
    1              0.000002 au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " Wget config
    1              0.000005 au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Website MetaLanguage
    1              0.000002 au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
    1              0.000002 au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
    1              0.000002 au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WPL
    1              0.000004 au BufNewFile,BufRead *.wpl			setf xml
                            
                            " WvDial
    1              0.000004 au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
    1              0.000002 au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
    1              0.000004 au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
    1              0.000004 au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
    1              0.000003 au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
    1              0.000005 au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, this used to trigger on BufEnter to make
                            " it work better, but that breaks setting 'filetype' manually)
    1              0.000003 au BufNewFile,BufRead *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
    1              0.000002 au BufNewFile,BufRead *.xpm2			setf xpm2
                            
                            " XFree86 config
    1              0.000010 au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
    1              0.000005 au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
    1              0.000006 au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
    1              0.000003 au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
    1              0.000002 au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
    1              0.000011 au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
    1              0.000004 au BufNewFile,BufRead *.msc,*.msf		setf xmath
    1              0.000002 au BufNewFile,BufRead *.ms
                            	\ if !dist#ft#FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
    1              0.000002 au BufNewFile,BufRead *.xml			call dist#ft#FTxml()
                            
                            " XMI (holding UML models) is also XML
    1              0.000002 au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based C# project config files
    1              0.000005 au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " FSPROJ files are Visual Studio.NET's XML-based F# project config files
    1              0.000007 au BufNewFile,BufRead *.fsproj,*.fsproj.user	setf xml
                            
                            " VBPROJ files are Visual Studio.NET's XML-based Visual Basic project config files
    1              0.000004 au BufNewFile,BufRead *.vbproj,*.vbproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
                            " However, for .ts Typescript is more common.
    1              0.000002 au BufNewFile,BufRead *.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
    1              0.000003 au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
    1              0.000004 au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
    1              0.000002 au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " Web Services Description Language (WSDL)
    1              0.000006 au BufNewFile,BufRead *.wsdl			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
    1              0.000002 au BufNewFile,BufRead *.xlf			setf xml
    1              0.000003 au BufNewFile,BufRead *.xliff			setf xml
                            
                            " XML User Interface Language
    1              0.000002 au BufNewFile,BufRead *.xul			setf xml
                            
                            " X11 xmodmap (also see below)
    1              0.000003 au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
    1              0.000008 au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
    1              0.000002 au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
    1              0.000003 au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
    1              0.000006 au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc
                            
                            " Yacc or racc
    1              0.000002 au BufNewFile,BufRead *.y			call dist#ft#FTy()
                            
                            " Yaml
    1              0.000004 au BufNewFile,BufRead *.yaml,*.yml		setf yaml
                            
                            " Raml
    1              0.000002 au BufNewFile,BufRead *.raml			setf raml
                            
                            " yum conf (close enough to dosini)
    1              0.000003 au BufNewFile,BufRead */etc/yum.conf		setf dosini
                            
                            " Zimbu
    1              0.000003 au BufNewFile,BufRead *.zu			setf zimbu
                            " Zimbu Templates
    1              0.000002 au BufNewFile,BufRead *.zut			setf zimbutempl
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
    1              0.000005 au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call dist#ft#FThtml()
                            "   zsql (zope sql method)
    1              0.000002 au BufNewFile,BufRead *.zsql			call dist#ft#SQL()
                            
                            " Z80 assembler asz80
    1              0.000002 au BufNewFile,BufRead *.z8a			setf z8a
                            
    1              0.000001 augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
    1              0.000004 if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
    1              0.000000 endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
    1              0.000001 augroup filetypedetect
    1              0.000003 au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
    1              0.000002 au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache style config files
    1              0.000008 au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*	call s:StarSetf('apachestyle')
    1              0.000004 au BufNewFile,BufRead proftpd.conf*					call s:StarSetf('apachestyle')
                            
                            " More Apache config files
    1              0.000013 au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
    1              0.000028 au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.*/*,*/etc/httpd/mods-*/*,*/etc/httpd/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
    1              0.000003 au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
    1              0.000005 au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
    1              0.000003 au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " Bazel build file
    1              0.000002 if !has("fname_case")
                              au BufNewFile,BufRead *.BUILD,BUILD		setf bzl
    1              0.000000 endif
                            
                            " BIND zone
    1              0.000006 au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
    1              0.000003 au BufNewFile,BufRead cabal.project.*		call s:StarSetf('cabalproject')
                            
                            " Calendar
    1              0.000013 au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
    1              0.000004 au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
    1              0.000008 au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
    1              0.000003 au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
    1              0.000002 au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
    1              0.000004 au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
    1              0.000006 au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
    1              0.000004 au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
    1              0.000004 au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " Git
    1              0.000007 au BufNewFile,BufRead */.gitconfig.d/*,/etc/gitconfig.d/*	call s:StarSetf('gitconfig')
                            
                            " Gitolite
    1              0.000004 au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
                            
                            " GTK RC
    1              0.000004 au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
    1              0.000007 au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
    1              0.000070 au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
    1              0.000007 au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Kconfig
    1              0.000004 au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
    1              0.000002 au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
    1              0.000004 au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
    1              0.000004 au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
    1              0.000002 au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
    1              0.000009 au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
    1              0.000003 au BufNewFile,BufRead reportbug-*		call s:StarSetf('mail')
                            
                            " Modconf
    1              0.000005 au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
    1              0.000003 au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
    1              0.000008 au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
    1              0.000005 au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Neomutt setup file
    1              0.000006 au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*	call s:StarSetf('neomuttrc')
    1              0.000004 au BufNewFile,BufRead neomuttrc*,Neomuttrc*		call s:StarSetf('neomuttrc')
                            
                            " Nroff macros
    1              0.000003 au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " OpenBSD hostname.if
    1              0.000003 au BufNewFile,BufRead /etc/hostname.*		call s:StarSetf('config')
                            
                            " Pam conf
    1              0.000003 au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
    1              0.000004 au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
    1              0.000003 au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
    1              0.000003 au BufRead,BufNewFile *.rdf			call dist#ft#Redif()
                            
                            " Remind
    1              0.000003 au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " SGML catalog file
    1              0.000003 au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " avoid doc files being recognized a shell files
    1              0.000007 au BufNewFile,BufRead */doc/{,.}bash[_-]completion{,.d,.sh}{,/*} setf text
                            
                            " Shell scripts ending in a star
    1              0.000020 au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,PKGBUILD*,APKBUILD*,*/{,.}bash[_-]completion{,.d,.sh}{,/*} call dist#ft#SetFileTypeSH("bash")
    1              0.000003 au BufNewFile,BufRead .kshrc* call dist#ft#SetFileTypeSH("ksh")
    1              0.000003 au BufNewFile,BufRead .profile* call dist#ft#SetFileTypeSH(getline(1))
                            
                            " Sudoers
    1              0.000004 au BufNewFile,BufRead */etc/sudoers.d/*		call s:StarSetf('sudoers')
                            
                            " tcsh scripts ending in a star
    1              0.000003 au BufNewFile,BufRead .tcshrc*	call dist#ft#SetFileTypeShell("tcsh")
                            
                            " csh scripts ending in a star
    1              0.000004 au BufNewFile,BufRead .login*,.cshrc*  call dist#ft#CSH()
                            
                            " tmux configuration with arbitrary extension
    1              0.000005 au BufNewFile,BufRead {.,}tmux*.conf*		setf tmux
                            
                            " VHDL
    1              0.000003 au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
    1              0.000002 au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
    1              0.000012 au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
    1              0.000009 au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
    1              0.000005 au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
    1              0.000003 au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
    1              0.000004 au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
    1              0.000004 au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
    1              0.000003 au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script ending in a star
    1              0.000011 au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
    1              0.000004 au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
    1              0.000005 au BufNewFile,BufRead *.text,README setf text
                            
                            " Help files match *.txt but should have a last line that is a modeline. 
    1              0.000003 au BufNewFile,BufRead *.txt
                                    \  if getline('$') !~ 'vim:.*ft=help'
                                    \|   setf text
                                    \| endif       
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes.
    1   0.004204   0.003143 runtime! ftdetect/*.vim
    1              0.000979 runtime! ftdetect/*.lua
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
    1              0.000001 augroup END
                            
                            " Generic configuration file. Use FALLBACK, it's just guessing!
    1              0.000007 au filetypedetect BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf FALLBACK conf |
                            	\ endif
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
    1              0.000009 if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
                              source <sfile>:p:h/menu.vim
    1              0.000001 endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
    1              0.000002 func! TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
    1              0.000008 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-arduino/ftdetect/arduino.vim
Sourced 2 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    2              0.000013 au BufRead,BufNewFile *.ino setlocal ft=arduino
    2              0.000009 au BufRead,BufNewFile */Arduino/**/*.h setlocal ft=arduino
    2              0.000007 au BufRead,BufNewFile */Arduino/**/*.c setlocal ft=arduino
    2              0.000031 au BufRead,BufNewFile */Arduino/**/*.cpp setlocal ft=arduino

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-polyglot/ftdetect/polyglot.vim
Sourced 2 times
Total time:   0.000071
 Self time:   0.000068

count  total (s)   self (s)
    2   0.000038   0.000035 call polyglot#init#init()

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/css.vim
Sourced 2 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    2              0.000005 augroup PrettierFileDetect
    2              0.000009   autocmd BufNewFile,BufReadPost *.css setfiletype css
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/graphql.vim
Sourced 2 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    2              0.000004 augroup PrettierFileDetect
    2              0.000012   autocmd BufNewFile,BufReadPost *.graphql,*.gql setfiletype graphql
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/html.vim
Sourced 2 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000004 augroup PrettierFileDetect
    2              0.000008   autocmd BufNewFile,BufReadPost *.html setfiletype html
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/javascript.vim
Sourced 2 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    2              0.000004 augroup PrettierFileDetect
    2              0.000010   autocmd BufNewFile,BufReadPost *.js,*jsx setfiletype javascript
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/json.vim
Sourced 2 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000004 augroup PrettierFileDetect
    2              0.000007   autocmd BufNewFile,BufReadPost *.json setfiletype json
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/less.vim
Sourced 2 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    2              0.000003 augroup PrettierFileDetect
    2              0.000007   autocmd BufNewFile,BufReadPost *.less setfiletype less
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/lua.vim
Sourced 2 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    2              0.000003 augroup PrettierFileDetect
    2              0.000007   autocmd BufNewFile,BufReadPost *.lua setfiletype lua
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/markdown.vim
Sourced 2 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    2              0.000004 augroup PrettierFileDetect
    2              0.000021   autocmd BufNewFile,BufReadPost *.markdown,*.md,*.mdown,*.mkd,*.mkdn setfiletype markdown
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/php.vim
Sourced 2 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    2              0.000004 augroup PrettierFileDetect
    2              0.000007   autocmd BufNewFile,BufReadPost *.php setfiletype php 
    2              0.000018 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/ruby.vim
Sourced 2 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000004 augroup PrettierFileDetect
    2              0.000007   autocmd BufNewFile,BufReadPost *.rb setfiletype ruby
    2              0.000018 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/scss.vim
Sourced 2 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    2              0.000003 augroup PrettierFileDetect
    2              0.000011   autocmd BufNewFile,BufReadPost *.scss setfiletype scss
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/svelte.vim
Sourced 2 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    2              0.000004 augroup PrettierFileDetect
    2              0.000010   autocmd BufNewFile,BufReadPost *.svelte setfiletype svelte
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/typescript.vim
Sourced 2 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    2              0.000003 augroup PrettierFileDetect
    2              0.000007   autocmd BufNewFile,BufReadPost *.ts setfiletype typescript
    2              0.000005   autocmd BufNewFile,BufReadPost *.tsx setfiletype typescriptreact
    2              0.000018 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/vue.vim
Sourced 2 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000003 augroup PrettierFileDetect
    2              0.000009   autocmd BufNewFile,BufReadPost *.vue setfiletype vue
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/xml.vim
Sourced 2 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000004 augroup PrettierFileDetect
    2              0.000006   autocmd BufNewFile,BufReadPost *.xml setfiletype xml
    2              0.000018 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/ftdetect/yaml.vim
Sourced 2 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000003 augroup PrettierFileDetect
    2              0.000009   autocmd BufNewFile,BufReadPost *.yaml,*.yml setfiletype yaml
    2              0.000019 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-fugitive/ftdetect/fugitive.vim
Sourced 2 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000025 autocmd BufReadPost *.fugitiveblame setfiletype fugitiveblame

SCRIPT  /usr/share/vim/vimfiles/ftdetect/PKGBUILD.vim
Sourced 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000013 au BufNewFile,BufRead PKGBUILD set filetype=PKGBUILD

SCRIPT  /usr/share/vim/vimfiles/ftdetect/conkyrc.vim
Sourced 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
                            " Vim filetype detection file for Conky config files
                            "
                            
    2              0.000009 au BufNewFile,BufRead *conkyrc set filetype=conkyrc
    2              0.000009 au BufNewFile,BufRead conky.conf set filetype=conkyrc

SCRIPT  /usr/share/vim/vimfiles/ftdetect/gnfiletype.vim
Sourced 2 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
                            " Copyright 2014 The Chromium Authors. All rights reserved.
                            " Use of this source code is governed by a BSD-style license that can be
                            " found in the LICENSE file.
                            
                            " We take care to preserve the user's fileencodings and fileformats,
                            " because those settings are global (not buffer local), yet we want
                            " to override them for loading GN files, which should be UTF-8.
    2              0.000007 let s:current_fileformats = ''
    2              0.000002 let s:current_fileencodings = ''
                            
                            " define fileencodings to open as utf-8 encoding even if it's ascii.
    2              0.000006 function! s:gnfiletype_pre()
                              let s:current_fileformats = &g:fileformats
                              let s:current_fileencodings = &g:fileencodings
                              set fileencodings=utf-8 fileformats=unix
                              setlocal filetype=gn
                            endfunction
                            
                            " restore fileencodings as others
    2              0.000002 function! s:gnfiletype_post()
                              let &g:fileformats = s:current_fileformats
                              let &g:fileencodings = s:current_fileencodings
                            endfunction
                            
    2              0.000007 au BufNewFile *.gn,*.gni setlocal filetype=gn fileencoding=utf-8 fileformat=unix
    2              0.000005 au BufRead *.gn,*.gni call s:gnfiletype_pre()
    2              0.000006 au BufReadPost *.gn,*.gni call s:gnfiletype_post()

SCRIPT  /usr/share/vim/vimfiles/ftdetect/meson.vim
Sourced 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000012 au BufNewFile,BufRead meson.build set filetype=meson
    2              0.000007 au BufNewFile,BufRead meson_options.txt set filetype=meson
    2              0.000006 au BufNewFile,BufRead *.wrap set filetype=dosini

SCRIPT  /usr/share/nvim/runtime/ftplugin.vim
Sourced 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    1              0.000005 if exists("did_load_ftplugin")
                              finish
    1              0.000001 endif
    1              0.000002 let did_load_ftplugin = 1
                            
    1              0.000002 augroup filetypeplugin
    1              0.000003   au FileType * call s:LoadFTPlugin()
                            
    1              0.000003   func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                                    exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
                                    exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
                                  endfor
                                endif
                              endfunc
    1              0.000002 augroup END

SCRIPT  /usr/share/nvim/runtime/indent.vim
Sourced 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    1              0.000003 if exists("did_indent_on")
                              finish
    1              0.000000 endif
    1              0.000001 let did_indent_on = 1
                            
    1              0.000001 augroup filetypeindent
    1              0.000003   au FileType * call s:LoadIndent()
    1              0.000002   func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                                    exe 'runtime! indent/' . name . '.vim'
                                    exe 'runtime! indent/' . name . '.lua'
                                  endfor
                                endif
                              endfunc
    1              0.000001 augroup END

SCRIPT  /usr/share/nvim/runtime/syntax/syntax.vim
Sourced 2 times
Total time:   0.001791
 Self time:   0.001177

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 04
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    2              0.000008 if !has("syntax")
                              finish
    2              0.000001 endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    2              0.000004 if exists("syntax_on") || exists("syntax_manual")
    1   0.000436   0.000027   so <sfile>:p:h/nosyntax.vim
    2              0.000001 endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    2   0.001220   0.001089 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    2              0.000003 if exists("did_load_filetypes")
    2              0.000002   let s:did_ft = 1
                            else
                              filetype on
                              let s:did_ft = 0
    2              0.000001 endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected.
    2              0.000001 augroup syntaxset
    2              0.000005   au! FileType *	exe "set syntax=" . expand("<amatch>")
    2              0.000001 augroup END
                            
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    2   0.000079   0.000005 doautoall syntaxset FileType
    2              0.000002 if !s:did_ft
                              doautoall filetypedetect BufRead
    2              0.000003 endif

SCRIPT  /usr/share/nvim/runtime/syntax/synload.vim
Sourced 2 times
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2020 Apr 13
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    2              0.000005 if !has("syntax")
                              finish
    2              0.000001 endif
                            
                            " let others know that syntax has been switched on
    2              0.000004 let syntax_on = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    2              0.000010 let s:cpo_save = &cpo
    2              0.000009 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    2              0.000003 au! Syntax
                            
    2              0.000005 au Syntax *		call s:SynSet()
                            
    2              0.000004 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
                                for name in split(s, '\.')
                                  if !empty(name)
                                    exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
                                    exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
                                  endif
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
    2              0.000018 au Syntax c,cpp,cs,idl,java,php,datascript
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    2              0.000003 if exists("mysyntaxfile")
                              let s:fname = expand(mysyntaxfile)
                              if filereadable(s:fname)
                                execute "source " . fnameescape(s:fname)
                              endif
    2              0.000001 endif
                            
                            " Restore 'cpoptions'
    2              0.000008 let &cpo = s:cpo_save
    2              0.000005 unlet s:cpo_save

SCRIPT  /home/tony/.config/nvim/plug-config/coc/coc-init.vim
Sourced 1 time
Total time:   0.000851
 Self time:   0.000254

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  Coc initialize  "
                            """"""""""""""""""""""
                            
    1   0.000108   0.000057 source $HOME/.config/nvim/plug-config/coc/coc-general.vim
    1   0.000111   0.000057 source $HOME/.config/nvim/plug-config/coc/coc-snippets.vim
    1   0.000475   0.000058 source $HOME/.config/nvim/plug-config/coc/coc-mappings.vim
    1   0.000140   0.000067 source $HOME/.config/nvim/plug-config/coc/coc-explorer.vim

SCRIPT  /home/tony/.config/nvim/plug-config/coc/coc-general.vim
Sourced 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  Coc general sets  "
                            """"""""""""""""""""""
                            
                            " Set internal encoding of vim, not needed on neovim, since coc.nvim using some
                            " unicode characters in the file autoload/float.vim
    1              0.000002 set encoding=utf-8
                            
                            " TextEdit might fail if hidden is not set.
    1              0.000001 set hidden
                            
                            " Some servers have issues with backup files, see #649.
    1              0.000001 set nobackup
    1              0.000001 set nowritebackup
                            
                            " Give more space for displaying messages.
    1              0.000007 set cmdheight=2
                            
                            " Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
                            " delays and poor user experience.
    1              0.000001 set updatetime=300
                            
                            " Don't pass messages to |ins-completion-menu|.
    1              0.000007 set shortmess+=c

SCRIPT  /home/tony/.config/nvim/plug-config/coc/coc-snippets.vim
Sourced 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  Snippets config  "
                            """"""""""""""""""""""
                            
                            " Use <C-l> for trigger snippet expand.
    1              0.000006 imap <C-l> <Plug>(coc-snippets-expand)
                            
                            " Use <C-j> for select text for visual placeholder of snippet.
    1              0.000004 vmap <C-j> <Plug>(coc-snippets-select)
                            
                            " Use <C-j> for jump to next placeholder, it's default of coc.nvim
    1              0.000003 let g:coc_snippet_next = '<c-j>'
                            
                            " Use <C-k> for jump to previous placeholder, it's default of coc.nvim
    1              0.000002 let g:coc_snippet_prev = '<c-k>'
                            
                            " Use <C-j> for both expand and jump (make expand higher priority.)
    1              0.000010 imap <C-j> <Plug>(coc-snippets-expand-jump)

SCRIPT  /home/tony/.config/nvim/plug-config/coc/coc-mappings.vim
Sourced 1 time
Total time:   0.000403
 Self time:   0.000403

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  Coc Mappings  "
                            """"""""""""""""""""""
                            
                            " NOTE: Leaders defined in which key
                            
                            " Use tab for trigger completion with characters ahead and navigate.
                            " NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
                            " other plugin before putting this into your config.
    1              0.000007 inoremap <silent><expr> <TAB>
                                  \ pumvisible() ? "\<C-n>" :
                                  \ <SID>check_back_space() ? "\<TAB>" :
                                  \ coc#refresh()
    1              0.000003 inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"
                            
    1              0.000002 function! s:check_back_space() abort
                              let col = col('.') - 1
                              return !col || getline('.')[col - 1]  =~# '\s'
                            endfunction
                            
                            " Use <c-space> to trigger completion.
    1              0.000003 if has('nvim')
    1              0.000003   inoremap <silent><expr> <c-space> coc#refresh()
                            else
                              inoremap <silent><expr> <c-@> coc#refresh()
    1              0.000000 endif
                            
                            " Make <CR> auto-select the first completion item and notify coc.nvim to
                            " format on enter, <cr> could be remapped by other vim plugin
    1              0.000005 inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm()
                                                          \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"
                            
                            " Use `[g` and `]g` to navigate diagnostics
                            " Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
    1              0.000003 nmap <silent> [g <Plug>(coc-diagnostic-prev)
    1              0.000003 nmap <silent> ]g <Plug>(coc-diagnostic-next)
                            
                            " GoTo code navigation.
    1              0.000002 nmap <silent> gd <Plug>(coc-definition)
    1              0.000003 nmap <silent> gy <Plug>(coc-type-definition)
    1              0.000002 nmap <silent> gi <Plug>(coc-implementation)
    1              0.000002 nmap <silent> gr <Plug>(coc-references)
                            
                            " Use K to show documentation in preview window.
    1              0.000003 nnoremap <silent> K :call <SID>show_documentation()<CR>
                            
    1              0.000001 function! s:show_documentation()
                              if (index(['vim','help'], &filetype) >= 0)
                                execute 'h '.expand('<cword>')
                              elseif (coc#rpc#ready())
                                call CocActionAsync('doHover')
                              else
                                execute '!' . &keywordprg . " " . expand('<cword>')
                              endif
                            endfunction
                            
                            " Highlight the symbol and its references when holding the cursor.
    1              0.000003 autocmd CursorHold * silent call CocActionAsync('highlight')
                            
                            " Symbol renaming.
                            " nmap <leader>rn <Plug>(coc-rename)
                            
                            " Formatting selected code.
    1              0.000004 xmap <leader>fo  <Plug>(coc-format-selected)
                            " nmap <leader>fo  <Plug>(coc-format-selected)
                            
    1              0.000001 augroup mygroup
    1              0.000223   autocmd!
                              " Setup formatexpr specified filetype(s).
    1              0.000005   autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
                              " Update signature help on jump placeholder.
    1              0.000007   autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
    1              0.000001 augroup end
                            
                            " Applying codeAction to the selected region.
                            " Example: `<leader>aap` for current paragraph
    1              0.000004 xmap <leader>a  <Plug>(coc-codeaction-selected)
                            " nmap <leader>a  <Plug>(coc-codeaction-selected)
                            
                            " Remap keys for applying codeAction to the current buffer.
                            " nmap <leader>ac  <Plug>(coc-codeaction)
                            " Apply AutoFix to problem on the current line.
                            " nmap <leader>qf  <Plug>(coc-fix-current)
                            
                            " Run the Code Lens action on the current line.
                            " nmap <leader>cl  <Plug>(coc-codelens-action)
                            
                            " Map function and class text objects
                            " NOTE: Requires 'textDocument.documentSymbol' support from the language server.
    1              0.000003 xmap if <Plug>(coc-funcobj-i)
    1              0.000003 omap if <Plug>(coc-funcobj-i)
    1              0.000002 xmap af <Plug>(coc-funcobj-a)
    1              0.000002 omap af <Plug>(coc-funcobj-a)
    1              0.000002 xmap ic <Plug>(coc-classobj-i)
    1              0.000002 omap ic <Plug>(coc-classobj-i)
    1              0.000002 xmap ac <Plug>(coc-classobj-a)
    1              0.000002 omap ac <Plug>(coc-classobj-a)
                            
                            " Remap <C-f> and <C-b> for scroll float windows/popups.
    1              0.000003 if has('nvim-0.4.0') || has('patch-8.2.0750')
    1              0.000005   noremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
    1              0.000004   nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
    1              0.000005   inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
    1              0.000004   inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
    1              0.000004   vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
    1              0.000003   vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
    1              0.000000 endif
                            
                            " Use CTRL-S for selections ranges.
                            " Requires 'textDocument/selectionRange' support of language server.
    1              0.000003 nmap <silent> <C-S> <Plug>(coc-range-select)
    1              0.000003 xmap <silent> <C-S> <Plug>(coc-range-select)
                            
                            " Add `:Format` command to format current buffer.
    1              0.000002 command! -nargs=0 Format :call CocActionAsync('format')
                            
                            " Add `:Fold` command to fold current buffer.
    1              0.000002 command! -nargs=? Fold :call     CocAction('fold', <f-args>)
                            
                            " Add `:OR` command for organize imports of the current buffer.
    1              0.000003 command! -nargs=0 OR   :call     CocActionAsync('runCommand', 'editor.action.organizeImport')
                            
                            " Add (Neo)Vim's native statusline support.
                            " NOTE: Please see `:h coc-status` for integrations with external plugins that
                            " provide custom statusline: lightline.vim, vim-airline.
    1              0.000003 set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}
                            
                            " Mappings for CoCList
                            " Show all diagnostics.
                            " nnoremap <silent><nowait> <space>a  :<C-u>CocList diagnostics<cr>
                            " Manage extensions.
                            " nnoremap <silent><nowait> <space>e  :<C-u>CocList extensions<cr>
                            " Show commands.
                            " nnoremap <silent><nowait> <space>c  :<C-u>CocList commands<cr>
                            " Find symbol of current document.
                            " nnoremap <silent><nowait> <space>o  :<C-u>CocList outline<cr>
                            " Search workspace symbols.
                            " nnoremap <silent><nowait> <space>s  :<C-u>CocList -I symbols<cr>
                            " Do default action for next item.
                            " nnoremap <silent><nowait> <space>j  :<C-u>CocNext<CR>
                            " Do default action for previous item.
                            " nnoremap <silent><nowait> <space>k  :<C-u>CocPrev<CR>
                            " Resume latest coc list.
                            " nnoremap <silent><nowait> <space>p  :<C-u>CocListResume<CR>

SCRIPT  /home/tony/.config/nvim/plug-config/coc/coc-explorer.vim
Sourced 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  Explorer settings "
                            """"""""""""""""""""""
                            
    1              0.000024 let g:coc_explorer_global_presets = {
                            \   '.vim': {
                            \     'root-uri': '~/.vim',
                            \   },
                            \   'tab': {
                            \     'position': 'tab',
                            \     'quit-on-open': v:true,
                            \   },
                            \   'floating': {
                            \     'position': 'floating',
                            \     'open-action-strategy': 'sourceWindow',
                            \   },
                            \   'floatingTop': {
                            \     'position': 'floating',
                            \     'floating-position': 'center-top',
                            \     'open-action-strategy': 'sourceWindow',
                            \   },
                            \   'floatingLeftside': {
                            \     'position': 'floating',
                            \     'floating-position': 'left-center',
                            \     'floating-width': 50,
                            \     'open-action-strategy': 'sourceWindow',
                            \   },
                            \   'floatingRightside': {
                            \     'position': 'floating',
                            \     'floating-position': 'right-center',
                            \     'floating-width': 50,
                            \     'open-action-strategy': 'sourceWindow',
                            \   },
                            \   'simplify': {
                            \     'file-child-template': '[selection | clip | 1] [indent][icon | 1] [filename omitCenter 1]'
                            \   }
                            \ }
                            
    1              0.000011 autocmd BufEnter * if (winnr("$") == 1 && &filetype == 'coc-explorer') | q | endif

SCRIPT  /home/tony/.config/nvim/general/settings.vim
Sourced 1 time
Total time:   0.004648
 Self time:   0.001067

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  General sets  "
                            """"""""""""""""""""""
                            
                            " set leader key
    1              0.000003 let g:mapleader = "\<Space>"
                            
    1   0.001133   0.000026 syntax enable                           " Enables syntax highlighing
    1              0.000002 set hidden                              " Required to keep multiple buffers open multiple buffers
                            " set nowrap                              " Display long lines as just one line
    1              0.000002 set encoding=utf-8                      " The encoding displayed
    1              0.000001 set pumheight=10                        " Makes popup menu smaller
    1              0.000002 set fileencoding=utf-8                  " The encoding written to file
    1              0.000001 set ruler              			       " Show the cursor position all the time
    1              0.000003 set cmdheight=1                         " More space for displaying messages
    1              0.000016 set iskeyword+=-                      	" treat dash separated words as a word text object"
    1              0.000002 set mouse=a                             " Enable your mouse
    1              0.000001 set splitbelow                          " Horizontal splits will automatically be below
    1              0.000001 set splitright                          " Vertical splits will automatically be to the right
    1              0.000003 set t_Co=256                            " Support 256 colors
    1              0.000001 set conceallevel=0                      " So that I can see `` in markdown files
    1              0.000001 set tabstop=4                           " Insert 3 spaces for a tab
    1              0.000001 set shiftwidth=4                        " Change the number of space characters inserted for indentation
    1              0.000001 set smarttab                            " Makes tabbing smarter will realize you have 2 vs 4
    1              0.000001 set expandtab                           " Converts tabs to spaces
    1              0.000001 set smartindent                         " Makes indenting smart
    1              0.000001 set autoindent                          " Good auto indent
    1              0.000001 set laststatus=0                        " Always display the status line
    1              0.000001 set number                              " Line numbers
    1              0.000075 set background=dark                     " tell vim what the background color looks like
    1              0.000007 set showtabline=1                       " Show tabs if >=2
    1              0.000001 set noshowmode                        " We don't need to see things like -- INSERT -- anymore
    1              0.000001 set nobackup                            " This is recommended by coc
    1              0.000001 set nowritebackup                       " This is recommended by coc
    1              0.000001 set cursorline                          " Enable highlighting of the current line
    1              0.000001 set updatetime=300                      " Faster completion
    1              0.000001 set timeoutlen=500                      " By default timeoutlen is 1000 ms
    1              0.000002 set formatoptions-=cro                  " Stop newline continution of comments
    1              0.000001 set clipboard=unnamedplus               " Copy paste between vim and everything else
    1              0.000001 set number                              " Number line "
    1              0.000001 set relativenumber                    " Relative number line
    1              0.000001 set numberwidth=1                       " Number distance"
    1              0.000001 set autochdir                           " Your working directory will always be the same as your working directory"
    1              0.000001 set nohlsearch                          " Disable highlighting in search"
    1              0.000001 set ignorecase                          " Case insensitive search"
    1              0.000001 set foldmethod=marker                   " Marker fold method {{{}}}"
    1              0.000001 set signcolumn=yes                      " Enable column next to line number"
    1              0.000004 set list lcs=tab:\|\                    " Indent line for tabs"
                            
                            
                            " Disable auto comment in new line
    1              0.000004 autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o
                            
                            """"""""""""""""""""""
                            "  Color scheme mod  "
                            """"""""""""""""""""""
                            
    1   0.003308   0.000835 colorscheme dracula
    1              0.000005 highlight LineNr guifg=#d8e17e
    1              0.000033 highlight Comment guifg=#8696da

SCRIPT  /usr/share/nvim/runtime/syntax/nosyntax.vim
Sourced 1 time
Total time:   0.000403
 Self time:   0.000390

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2006 Apr 16
                            
                            " This file is used for ":syntax off".
                            " It removes the autocommands and stops highlighting for all buffers.
                            
    1              0.000002 if !has("syntax")
                              finish
    1              0.000000 endif
                            
                            " Remove all autocommands for the Syntax event.  This also avoids that
                            " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
    1              0.000154 au! Syntax
                            
                            " remove all syntax autocommands and remove the syntax for each buffer
    1              0.000001 augroup syntaxset
    1              0.000108   au!
    1              0.000004   au BufEnter * syn clear
    1              0.000001   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
    1   0.000018   0.000006   doautoall syntaxset BufEnter *
    1              0.000097   au!
    1              0.000001 augroup END
                            
    1              0.000002 if exists("syntax_on")
    1              0.000002   unlet syntax_on
    1              0.000000 endif
    1              0.000001 if exists("syntax_manual")
                              unlet syntax_manual
    1              0.000003 endif

SCRIPT  /home/tony/.config/nvim/autoload/plugged/dracula.nvim/colors/dracula.lua
Sourced 1 time
Total time:   0.002459
 Self time:   0.002459

count  total (s)   self (s)
                            local dracula = require("dracula")
                            
                            vim.cmd("hi clear")
                            
                            if vim.fn.exists("syntax_on") then
                            	vim.cmd("syntax reset")
                            end
                            
                            vim.o.background = "dark"
                            vim.o.termguicolors = true
                            vim.g.colors_name = "dracula"
                            
                            dracula.apply();

SCRIPT  /home/tony/.config/nvim/general/commands.vim
Sourced 1 time
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "     Functions      "
                            """"""""""""""""""""""
    1              0.000003 function! CocToggle()
                                if g:coc_enabled
                                    CocDisable
                                else
                                    CocEnable
                                endif
                            endfunction
                            
                            """"""""""""""""""""""
                            "  Custom commands  "
                            """"""""""""""""""""""
    1              0.000003 command! CocToggle :call CocToggle()
                            
                            " You can't stop me
    1              0.000005 cmap w!! w !sudo tee %
    1              0.000001 command W SudaWrite
                            
                            " Tags file
    1              0.000001 command! MakeTags !ctags -R .
                            
                            " Yank path
    1              0.000012 command Path redir @+ | echo Relpath(expand("%"))

SCRIPT  /home/tony/.config/nvim/keys/mappings.vim
Sourced 1 time
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  Custom mappings  "
                            """"""""""""""""""""""
                            
    1              0.000005 nnoremap <space> <nop>
                            
                            " Disable Ex mode
    1              0.000003 map q: <Nop>
    1              0.000002 nnoremap Q <nop>
                            
                            " Split long lines
    1              0.000002 nnoremap Q gqq
                            
                            " Use alt + hjkl to resize windows
    1              0.000004 nnoremap <M-J>    :resize -2<CR>
    1              0.000002 nnoremap <M-K>    :resize +2<CR>
    1              0.000003 nnoremap <M-H>    :vertical resize +2<CR>
    1              0.000002 nnoremap <M-L>    :vertical resize -2<CR>
                            
                            " I hate escape more than anything else
    1              0.000003 inoremap jk <Esc>
                            
                            " Fix multiline segments
    1              0.000002 nnoremap j gj
    1              0.000001 nnoremap k gk
                            
                            " TAB in general mode will move to text buffer
    1              0.000002 nnoremap <TAB> :bnext<CR>
                            " SHIFT-TAB will go back
    1              0.000002 nnoremap <S-TAB> :bprevious<CR>
                            
                            " Alternate way to save
    1              0.000002 nnoremap <C-s> :w<CR>
                            " <TAB>: completion.
    1              0.000004 inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
                            
                            " Better tabbing
    1              0.000002 vnoremap < <gv
    1              0.000002 vnoremap > >gv
                            
                            " Better window navigation
    1              0.000002 nnoremap <M-h> <C-w>h
    1              0.000002 nnoremap <M-j> <C-w>j
    1              0.000001 nnoremap <M-k> <C-w>k
    1              0.000001 nnoremap <M-l> <C-w>l
                            
                            " Folding
    1              0.000001 nnoremap , za
                            " New fold structure
    1              0.000004 nnoremap 'm <esc>I## {{{<CR>  <backspace><CR>}}}<esc>kkI##  <esc>i
                            
                            " insert line
    1              0.000002 nnoremap <enter> o<esc>
    1              0.000002 nnoremap <A-enter> O<esc>
                            
                            " Word wrap
    1              0.000002 nnoremap <A-z> :set wrap!<CR>
                            
                            " Faster scrolling
    1              0.000001 nnoremap <c-j> 5j
    1              0.000001 nnoremap <c-k> 5k
    1              0.000002 xnoremap <c-j> 5j
    1              0.000001 xnoremap <c-k> 5k
                            
                            " Better pasting
    1              0.000012 nnoremap <c-p> pg;h

SCRIPT  /home/tony/.config/nvim/keys/snippets.vim
Sourced 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  Custom snippets  "
                            """"""""""""""""""""""
                            
    1              0.000014 nnoremap !html :-1read $HOME/.config/nvim/snippets/skeleton.html<CR>6jwf>a

SCRIPT  /home/tony/.config/nvim/keys/which-key.vim
Sourced 1 time
Total time:   0.001310
 Self time:   0.001074

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "     Map leader     "
                            """"""""""""""""""""""
                            
                            " Map leader to which_key
    1              0.000007 nnoremap <silent> <leader> :silent WhichKey '<Space>'<CR>
    1              0.000005 vnoremap <silent> <leader> :silent <c-u> :silent WhichKeyVisual '<Space>'<CR>
                            
                            " Create map to add keys to
    1              0.000004 let g:which_key_map =  {}
                            " Define a separator
    1              0.000001 let g:which_key_sep = '→'
                            
                            " Not a fan of floating windows for this
    1              0.000002 let g:which_key_use_floating_win = 0
                            
                            " Change the colors if you want
    1              0.000002 highlight default link WhichKey          Operator
    1              0.000001 highlight default link WhichKeySeperator DiffAdded
    1              0.000001 highlight default link WhichKeyGroup     Identifier
    1              0.000001 highlight default link WhichKeyDesc      Function
                            
                            " Hide status line
    1              0.000003 autocmd! FileType which_key
    1              0.000006 autocmd  FileType which_key set laststatus=0 noshowmode noruler
                              \| autocmd BufLeave <buffer> set laststatus=2 noshowmode ruler
                            
                            " Single mappings
    1              0.000003 let g:which_key_map['/'] = [ '<Plug>NERDCommenterToggle'  , 'comment line' ]
    1              0.000002 let g:which_key_map[';'] = [ '$a;'  , 'Quick semicolon' ]
    1              0.000002 let g:which_key_map['D'] = [ ':Codi!'       , 'Disable codi' ]
    1              0.000002 let g:which_key_map['E'] = [ ':CocCommand explorer --preset floating'       , 'float explorer' ]
    1              0.000001 let g:which_key_map['S'] = [ ':Startify'                  , 'start screen' ]
    1              0.000003 let g:which_key_map['b'] = [ '<Plug>CodeRunner'                  , 'Run code' ]
    1              0.000001 let g:which_key_map['d'] = [ ':Codi'       , 'Enable codi' ]
    1              0.000001 let g:which_key_map['e'] = [ ':CocCommand explorer'       , 'explorer' ]
    1              0.000001 let g:which_key_map['h'] = [ '<C-W>s'                     , 'split below']
    1              0.000001 let g:which_key_map['m'] = [ ':Marks'                     , 'split marks']
    1              0.000001 let g:which_key_map['p'] = [ '<Plug>(Prettier)'                     , 'Prettier']
    1              0.000001 let g:which_key_map['q'] = [ ':Sayonara'                     , 'close buffer']
    1              0.000001 let g:which_key_map['r'] = [ ':Ranger'                    , 'ranger' ]
    1              0.000001 let g:which_key_map['v'] = [ '<C-W>v'                     , 'split right']
    1              0.000001 let g:which_key_map['z'] = [ ':Goyo'                       , 'zen' ]
                            
    1              0.000024 let g:which_key_map.s = {
                                  \ 'name' : '+search' ,
                                  \ '/' : [':History/'     , 'history'],
                                  \ ';' : [':Commands'     , 'commands'],
                                  \ 'a' : [':Ag'           , 'text Ag'],
                                  \ 'b' : [':BLines'       , 'current buffer'],
                                  \ 'B' : [':Buffers'      , 'open buffers'],
                                  \ 'c' : [':Commits'      , 'commits'],
                                  \ 'C' : [':BCommits'     , 'buffer commits'],
                                  \ 'f' : [':Files'        , 'files'],
                                  \ 'g' : [':GFiles'       , 'git files'],
                                  \ 'G' : [':GFiles?'      , 'modified git files'],
                                  \ 'h' : [':History'      , 'file history'],
                                  \ 'H' : [':History:'     , 'command history'],
                                  \ 'l' : [':Lines'        , 'lines'] ,
                                  \ 'm' : [':Marks'        , 'marks'] ,
                                  \ 'M' : [':Maps'         , 'normal maps'] ,
                                  \ 'p' : [':Helptags'     , 'help tags'] ,
                                  \ 'P' : [':Tags'         , 'project tags'],
                                  \ 's' : [':Snippets'     , 'snippets'],
                                  \ 'S' : [':Colors'       , 'color schemes'],
                                  \ 't' : [':Rg'           , 'text Rg'],
                                  \ 'T' : [':BTags'        , 'buffer tags'],
                                  \ 'w' : [':Windows'      , 'search windows'],
                                  \ 'y' : [':Filetypes'    , 'file types'],
                                  \ 'z' : [':FZF'          , 'FZF'],
                                  \ }
                            
                            " g is for hunks (signify)
    1              0.000006 let g:which_key_map.g = {
                                  \ 'name' : '+hunk' ,
                                  \ 'J' : ['99<plug>(signify-next-hunk)'      , 'Last hunk' ],
                                  \ 'K' : ['99<plug>(signify-prev-hunk)'      , 'First hunk'],
                                  \ 'j' : ['<plug>(signify-next-hunk)'        , 'Next hunk' ],
                                  \ 'k' : ['<plug>(signify-prev-hunk)'        , 'Prev hunk' ],
                                  \ }
                            
                            " c is for Conqueror of completion (Coc)
    1              0.000037 let g:which_key_map.k = {
                                  \ 'name' : '+Coc' ,
                                  \ 'a'  : ['<Plug>(coc-codeaction-selected)'      , 'Codeaction selection'],
                                  \ 'ac' : ['<Plug>(coc-codeaction)'      , 'Codeaction buffer'],
                                  \ 'c'  : [':<C-u>CocList commands<cr>'      , 'Show commands'],
                                  \ 'cl' : ['<Plug>(coc-codelens-action)'      , 'Code lens current line'],
                                  \ 'd'  : [':<C-u>CocList diagnostics<cr>'      , 'Show all diagnostics'],
                                  \ 'e'  : [':<C-u>CocList extensions<cr>'      , 'Manage extensions'],
                                  \ 'fo' : ['<Plug>(coc-format-selected)'      , 'Format selection'],
                                  \ 'j'  : [':<C-u>CocNext<CR>'      , 'Default action next item'],
                                  \ 'k'  : [':<C-u>CocPrev<CR>'      , 'Default action prev item'],
                                  \ 'o'  : [':<C-u>CocList outline<cr>'      , 'Search symbol in doc'],
                                  \ 'p'  : [':<C-u>CocListResume<CR>'      , 'Resum latest coc list'],
                                  \ 'qf' : ['<Plug>(coc-fix-current)'      , 'Autofix current line'],
                                  \ 'rn' : ['<Plug>(coc-rename)'      , 'Symbol renaming'],
                                  \ 's'  : [':<C-u>CocList -I symbols<cr>'      , 'Search workspace symbols'],
                                  \ 't'  :  [':CocToggle'      , 'Toggle Coc'],
                                  \ }
                            
                            " space is for better navigation (easymotion)
    1              0.000006 let g:which_key_map.f = {
                                  \ 'name' : '+easymotion' ,
                                  \ 'f' : ['<Plug>(easymotion-bd-f)'      , 'find 1 char' ],
                                  \ 's' : ['<Plug>(easymotion-overwin-f2)'      , 'find 2 char'],
                                  \ 'l' : ['<Plug>(easymotion-bd-jk)'        , 'find line' ],
                                  \ 'w' : ['<Plug>(easymotion-bd-w)'        , 'find word' ],
                                  \ }
                            
    1              0.000006 let g:which_key_map.a = {
                                  \ 'name' : '+arduino' ,
                                  \ 'a' : [':ArduinoVerify'      , 'Build sketch' ],
                                  \ 'b' : [':ArduinoUpload'      , 'Build and upload'],
                                  \ 'd' : [':ArduinoUploadAndSerial'        , 'Build, upload and debug' ],
                                  \ 'q' : [':ArduinoChooseBoard'        , 'Choose board' ],
                                  \ 'p' : [':ArduinoChooseProgrammer'        , 'Choose programmer' ],
                                  \ }
                            
    1              0.000018 let g:which_key_map.c = {
                                  \ 'name' : '+comment' ,
                                  \ '/' : ['<Plug>NERDCommenterToggle'      , 'Line' ],
                                  \ 'm' : ['<Plug>NERDCommenterMinimal'      , 'Minimal'],
                                  \ 'i' : ['<Plug>NERDCommenterInvert'        , 'Invert' ],
                                  \ 's' : ['<Plug>NERDCommenterSexy'        , 'Sexy' ],
                                  \ 'y' : ['<Plug>NERDCommenterYank'        , 'Yank and comment' ],
                                  \ '$' : ['<Plug>NERDCommenterToEOL'        , 'EOL' ],
                                  \ 'A' : ['<Plug>NERDCommenterAppend'        , 'Append' ],
                                  \ 'I' : ['<Plug>NERDCommenterInsert'        , 'Insert' ],
                                  \ 'c' : ['<Plug>NERDCommenterComment'        , 'Comment' ],
                                  \ 'n' : ['<Plug>NERDCommenterNested'        , 'Nesting' ],
                                  \ 'a' : ['<Plug>NERDCommenterAltDelims'        , 'Alt delimiters' ],
                                  \ 'l' : ['<Plug>NERDCommenterAlignLeft'        , 'Align left' ],
                                  \ 'b' : ['<Plug>NERDCommenterAlignBoth'        , 'Align both' ],
                                  \ 'u' : ['<Plug>NERDCommenterUncomment'        , 'Uncomment' ],
                                  \ 'p' : ["gcap"        , 'Paragraph' ],
                                  \ }
                            
                            " Register which key map
    1   0.001136   0.000900 call which_key#register('<Space>', "g:which_key_map")

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-which-key/autoload/which_key.vim
Sourced 1 time
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
    1              0.000003 scriptencoding utf-8
                            
    1              0.000006 let s:desc = get(s:, 'desc', {})
    1              0.000002 let s:cache = get(s:, 'cache', {})
    1              0.000009 let s:TYPE = {
                                  \ 'list':    type([]),
                                  \ 'dict':    type({}),
                                  \ 'number':  type(0),
                                  \ 'string':  type(''),
                                  \ 'funcref': type(function('call'))
                                  \ }
    1              0.000001 let g:which_key#TYPE = s:TYPE
                            
    1              0.000003 let s:should_note_winid = exists('*win_getid')
                            
    1              0.000002 function! which_key#register(prefix, dict) abort
                              let key = a:prefix ==? '<Space>' ? ' ' : a:prefix
                              let val = a:dict
                              call extend(s:desc, {key:val})
                            endfunction
                            
                            " No need to open which-key window, execute the acction according to the current input.
    1              0.000003 function! s:handle_char_on_start_is_ok(c) abort
                              if which_key#char_handler#is_exit_code(a:c)
                                return 1
                              endif
                              let char = a:c == 9 ? '<Tab>' : nr2char(a:c)
                              let s:which_key_trigger .= ' '.char
                              let next_level = get(s:runtime, char)
                              let ty = type(next_level)
                              if ty == s:TYPE.dict
                                let s:runtime = next_level
                                return 0
                              elseif ty == s:TYPE.list
                                call s:execute(next_level[0])
                                return 1
                              elseif g:which_key_fallback_to_native_key
                                call s:execute_native_fallback(0)
                                return 1
                              else
                                call which_key#error#undefined_key(s:which_key_trigger)
                                return 1
                              endif
                            endfunction
                            
    1              0.000001 function! which_key#start(vis, bang, prefix) " {{{
                              let s:vis = a:vis ? 'gv' : ''
                              let s:count = v:count != 0 ? v:count : ''
                              let s:which_key_trigger = ''
                            
                              if s:should_note_winid
                                let g:which_key_origin_winid = win_getid()
                              endif
                            
                              if a:bang
                                let s:runtime = a:prefix
                                let s:last_runtime_stack = [copy(s:runtime)]
                                call which_key#window#show(s:runtime)
                                return
                              endif
                            
                              let key = a:prefix
                              let s:which_key_trigger = key ==# ' ' ? '<space>' : key
                            
                              if !has_key(s:cache, key) || g:which_key_run_map_on_popup
                                " First run
                                let s:cache[key] = {}
                                call which_key#mappings#parse(key, s:cache[key], s:vis ==# 'gv' ? 1 : 0)
                              endif
                            
                              " s:runtime is a dictionary combining the native key mapping dictionary
                              " parsed by vim-which-key itself with user defined prefix dictionary if avaliable.
                              let s:runtime = s:create_runtime(key)
                            
                              if getchar(1)
                                while 1
                                  try
                                    let c = getchar()
                                  catch /^Vim:Interrupt$/
                                    return ''
                                  endtry
                                  if s:handle_char_on_start_is_ok(c)
                                    return
                                  endif
                                  " When there are next level options, wait another timeoutlen.
                                  " https://github.com/liuchengxu/vim-which-key/issues/3
                                  " https://github.com/liuchengxu/vim-which-key/issues/4
                                  if which_key#char_handler#wait_with_timeout()
                                    break
                                  endif
                                endwhile
                              endif
                            
                              let s:last_runtime_stack = [copy(s:runtime)]
                              call which_key#window#show(s:runtime)
                            endfunction
                            
    1              0.000001 function! s:create_runtime(key)
                              let key = a:key
                              if has_key(s:desc, key)
                                if type(s:desc[key]) == s:TYPE.dict
                                  let runtime = deepcopy(s:desc[key])
                                else
                                  let runtime = deepcopy({s:desc[key]})
                                endif
                                let native = s:cache[key]
                                call s:merge(runtime, native)
                              else
                                let runtime = s:cache[key]
                              endif
                              return runtime
                            endfunction
                            
    1              0.000001 function! s:merge(target, native) " {{{
                              let target = a:target
                              let native = a:native
                            
                              for [k, v] in items(target)
                            
                                if type(v) == s:TYPE.dict && has_key(native, k)
                            
                                  if type(native[k]) == s:TYPE.dict
                                    if has_key(v, 'name')
                                      let native[k].name = v.name
                                    endif
                                    call s:merge(target[k], native[k])
                                  elseif type(native[k]) == s:TYPE.list
                                    let target[k] = native[k]
                                  endif
                            
                                " Support add a description to an existing map without dual definition
                                elseif type(v) == s:TYPE.string && k !=# 'name'
                            
                                  " <Tab> <C-I>
                                  if k ==# '<Tab>' && has_key(native, '<C-I>')
                                    let target[k] = [
                                          \ native['<C-I>'][0],
                                          \ v]
                                  else
                                    let target[k] = [
                                          \ has_key(native, k) ? native[k][0] : 'which_key#error#missing_mapping()',
                                          \ v]
                                  endif
                            
                                endif
                            
                              endfor
                            
                              " TODO handle <C-I>, <Tab> more clearly
                              if has_key(native, '<C-I>')
                                if !has_key(target, '<Tab>')
                                  let target['<Tab>'] = native['<C-I>']
                                endif
                                call remove(native, '<C-I>')
                              endif
                            
                              call extend(target, native, 'keep')
                            endfunction
                            
    1              0.000001 function! s:echo_prompt() abort
                              echohl Keyword
                              echo s:which_key_trigger.'- '
                              echohl None
                            
                              echohl String
                              echon which_key#window#name()
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:has_children(input) abort
                              " TODO: escape properly, E114: Missing quote: "^\"
                              if a:input ==# '\'
                                let group = map(keys(s:runtime), 'v:val =~# "^\'.a:input.'"')
                              elseif a:input ==# '"'
                                let group = map(keys(s:runtime), "v:val =~# '^".a:input."'")
                              elseif a:input == '.'
                                let group = map(keys(s:runtime), "v:val =~# '^\\.'")
                              else
                                let group = map(keys(s:runtime), 'v:val =~# "^'.a:input.'"')
                              endif
                              return len(filter(group, 'v:val == 1')) > 1
                            endfunction
                            
    1              0.000001 function! s:show_upper_level_mappings() abort
                              " Top level
                              if empty(s:last_runtime_stack)
                                call which_key#window#show(s:runtime)
                                return
                              endif
                            
                              let last_runtime = s:last_runtime_stack[-1]
                              let s:runtime = last_runtime
                            
                              if len(s:last_runtime_stack) > 1
                                let s:which_key_trigger = join(split(s:which_key_trigger)[:-2], ' ')
                              endif
                            
                              unlet s:last_runtime_stack[-1]
                            
                              call which_key#window#show(last_runtime)
                            endfunction
                            
    1              0.000001 function! s:getchar() abort
                              let input = ''
                              try
                                let c = getchar()
                              " Handle <C-C>
                              catch /^Vim:Interrupt$/
                                call which_key#window#close()
                                redraw!
                                return ''
                              endtry
                            
                              if which_key#char_handler#is_exit_code(c)
                                call which_key#window#close()
                                redraw!
                                return ''
                              endif
                            
                              " Allow <BS> to go back to the upper level.
                              if c ==# "\<BS>"
                                call s:show_upper_level_mappings()
                                return ''
                              endif
                            
                              " :h keycode
                              " <CR>, <Enter>
                              if c == 13
                                return '<CR>'
                              endif
                            
                              let input .= which_key#char_handler#parse_raw(c)
                              if s:has_children(input)
                                while 1
                                  if !which_key#char_handler#timeout_for_next_char()
                                    let input .= which_key#char_handler#parse_raw(getchar())
                                  else
                                    break
                                  endif
                                endwhile
                              endif
                            
                              return input
                            endfunction
                            
    1              0.000001 function! which_key#wait_for_input() " {{{
                              " redraw is needed!
                              redraw
                            
                              " Append the prompt in the buffer at last when using floating or
                              " popup wnidow, otherwise show it in the cmdline.
                              if !g:which_key_use_floating_win
                                call s:echo_prompt()
                              endif
                            
                              let char = s:getchar()
                              if char ==# ''
                                return
                              endif
                            
                              let s:cur_char = char
                            
                              call s:handle_input(get(s:runtime, char))
                            endfunction
                            
    1              0.000001 function! s:show_next_level_mappings(next_runtime) abort
                              let s:which_key_trigger .= ' '. (s:cur_char ==# ' ' ? '<space>' : s:cur_char)
                              call add(s:last_runtime_stack, copy(s:runtime))
                              let s:runtime = a:next_runtime
                              call which_key#window#show(s:runtime)
                            endfunction
                            
    1              0.000001 function! s:handle_input(input) " {{{
                              let ty = type(a:input)
                            
                              if ty ==? s:TYPE.dict
                                call s:show_next_level_mappings(a:input)
                                return
                              endif
                            
                              if ty ==? s:TYPE.list
                                call which_key#window#close()
                                call s:execute(a:input[0])
                              elseif g:which_key_fallback_to_native_key
                                call which_key#window#close()
                                " Is redraw needed here?
                                " redraw!
                                call s:execute_native_fallback(1)
                              else
                                if g:which_key_ignore_invalid_key
                                  call which_key#wait_for_input()
                                else
                                  call which_key#window#close()
                                  redraw!
                                  call which_key#error#undefined_key(s:which_key_trigger)
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! s:execute_native_fallback(append) abort
                              let l:reg = s:get_register()
                              let l:fallback_cmd = s:vis.l:reg.s:count.substitute(s:which_key_trigger, ' ', '', '')
                              if (a:append)
                                let l:fallback_cmd = l:fallback_cmd.get(s:, 'cur_char', '')
                              endif
                              try
                                call feedkeys(l:fallback_cmd, 'n')
                              catch
                                call which_key#error#report('Exception: '.v:exception.' occurs for the fallback mapping: '.l:fallback_cmd)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:join(...) abort
                              return join(a:000, ' ')
                            endfunction
                            
    1              0.000001 function! s:execute(cmd) abort
                              let reg = s:get_register()
                              if s:vis.reg.s:count !=# ''
                                execute 'normal!' s:vis.reg.s:count
                              endif
                              redraw
                              let Cmd = a:cmd
                              try
                                if type(Cmd) == s:TYPE.funcref
                                  call call(Cmd, [])
                                  return
                                endif
                                if Cmd =~? '^<Plug>.\+' || Cmd =~? '^<C-W>.\+' || Cmd =~? '^<.\+>$'
                                  let Cmd = s:join('call', 'feedkeys("\'.Cmd.'")')
                                elseif Cmd =~? '.(*)$' && match(Cmd, '\<call\>') == -1
                                  let Cmd = s:join('call', Cmd)
                                elseif exists(':'.Cmd)  || Cmd =~# '^:' || Cmd =~? '^call feedkeys(.*)$'
                                  let Cmd = Cmd
                                else
                                  let Cmd = s:join('call', 'feedkeys("'.Cmd.'")')
                                endif
                                execute Cmd
                              catch
                                echom v:exception
                              endtry
                            endfunction
                            
                            " --------------------------------------
                            " Misc
                            " --------------------------------------
    1              0.000001 function! s:register() abort
                              let clipboard = &clipboard
                              if clipboard ==# 'unnamedplus'
                                return '+'
                              elseif clipboard ==# 'unnamed'
                                return '*'
                              else
                                return '"'
                              endif
                            endfunction
                            
    1              0.000001 function! s:get_register() abort
                             if has('nvim') && !exists('s:reg')
                                let s:reg = ''
                              else
                                let s:reg = v:register != s:register() ? '"'.v:register : ''
                              endif
                              return s:reg
                            endfunction
                            
                            " Update the cache manually by calling this function.
    1              0.000001 function! which_key#parse_mappings() " {{{
                              for [k, v] in items(s:cache)
                                call which_key#mappings#parse(k, v, s:vis ==# 'gv' ? 1 : 0)
                              endfor
                            endfunction " }}}
                            
    1              0.000001 function! which_key#format(mapping) abort
                              let l:ret = a:mapping
                              let l:ret = substitute(l:ret, '\c<cr>$', '', '')
                              let l:ret = substitute(l:ret, '^:', '', '')
                              let l:ret = substitute(l:ret, '^\c<c-u>', '', '')
                              " let l:ret = substitute(l:ret, '^<Plug>', '', '')
                              return l:ret
                            endfunction
                            
    1              0.000001 function! which_key#statusline() abort
                              let key = '%#WhichKeyTrigger# %{get(s:, "which_key_trigger", "")} %*'
                              let name = '%#WhichKeyName# %{which_key#window#name()} %*'
                              return key.name
                            endfunction
                            
    1              0.000001 function! which_key#trigger() abort
                              return get(s:, 'which_key_trigger', '')
                            endfunction
                            
    1              0.000001 function! which_key#get_sep() abort
                              return get(g:, 'which_key_sep', '→')
                            endfunction

SCRIPT  /home/tony/.config/nvim/plug-config/arduino.vim
Sourced 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000011 let g:arduino_dir = '/usr/share/arduino'

SCRIPT  /home/tony/.config/nvim/plug-config/coderunner.vim
Sourced 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000011 let g:code_runner_save_before_execute = 1

SCRIPT  /home/tony/.config/nvim/plug-config/codi.vim
Sourced 1 time
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
                            " Change the color
    1              0.000009 highlight CodiVirtualText guifg=#568c64
                            
    1              0.000003 let g:codi#virtual_text_prefix = "→ "
                            
                            "
    1              0.000044 let g:codi#aliases = {
                                               \ 'javascript.jsx': 'javascript',
                                               \ }

SCRIPT  /home/tony/.config/nvim/plug-config/easymotion.vim
Sourced 1 time
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
                            " <Leader>f{char} to move to {char}
    1              0.000012 map  <Leader>ff <Plug>(easymotion-bd-f)
    1              0.000009 nmap <Leader>ff <Plug>(easymotion-overwin-f)
                            
                            " s{char}{char} to move to {char}{char}
    1              0.000006 nmap s <Plug>(easymotion-overwin-f2)
                            
                            " Move to line
    1              0.000007 map <Leader>fl <Plug>(easymotion-bd-jk)
    1              0.000007 nmap <Leader>fl <Plug>(easymotion-overwin-line)
                            
                            " Move to word
    1              0.000006 map  <Leader>fw <Plug>(easymotion-bd-w)
    1              0.000018 nmap <Leader>fw <Plug>(easymotion-overwin-w)

SCRIPT  /home/tony/.config/nvim/plug-config/fzf.vim
Sourced 1 time
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
                            " This is the default extra key bindings
    1              0.000007 let g:fzf_action = {
                              \ 'ctrl-t': 'tab split',
                              \ 'ctrl-x': 'split',
                              \ 'ctrl-v': 'vsplit' }
                            
                            " Enable per-command history.
                            " CTRL-N and CTRL-P will be automatically bound to next-history and
                            " previous-history instead of down and up. If you don't like the change,
                            " explicitly bind the keys to down and up in your $FZF_DEFAULT_OPTS.
    1              0.000002 let g:fzf_history_dir = '~/.local/share/fzf-history'
                            
    1              0.000002 let g:fzf_tags_command = 'ctags -R'
                            " Border color
    1              0.000010 let g:fzf_layout = {'up':'~90%', 'window': { 'width': 0.8, 'height': 0.8,'yoffset':0.5,'xoffset': 0.5, 'highlight': 'Todo', 'border': 'sharp' } }
                            
    1              0.000005 let $FZF_DEFAULT_OPTS = '--layout=reverse --info=inline'
    1              0.000003 let $FZF_DEFAULT_COMMAND="rg --files --hidden"
                            
                            
                            " Customize fzf colors to match your color scheme
    1              0.000021 let g:fzf_colors =
                            \ { 'fg':      ['fg', 'Normal'],
                              \ 'bg':      ['bg', 'Normal'],
                              \ 'hl':      ['fg', 'Comment'],
                              \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
                              \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
                              \ 'hl+':     ['fg', 'Statement'],
                              \ 'info':    ['fg', 'PreProc'],
                              \ 'border':  ['fg', 'Ignore'],
                              \ 'prompt':  ['fg', 'Conditional'],
                              \ 'pointer': ['fg', 'Exception'],
                              \ 'marker':  ['fg', 'Keyword'],
                              \ 'spinner': ['fg', 'Label'],
                              \ 'header':  ['fg', 'Comment'] }
                            
                            "Get Files
    1              0.000013 command! -bang -nargs=? -complete=dir Files
                                \ call fzf#vim#files(<q-args>, fzf#vim#with_preview({'options': ['--layout=reverse', '--info=inline']}), <bang>0)
                            
                            
                            " Get text in files with Rg
    1              0.000014 command! -bang -nargs=* Rg
                              \ call fzf#vim#grep(
                              \   'rg --column --line-number --no-heading --color=always --smart-case '.shellescape(<q-args>), 1,
                              \   fzf#vim#with_preview(), <bang>0)
                            
                            " Ripgrep advanced
    1              0.000003 function! RipgrepFzf(query, fullscreen)
                              let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case %s || true'
                              let initial_command = printf(command_fmt, shellescape(a:query))
                              let reload_command = printf(command_fmt, '{q}')
                              let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
                              call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
                            endfunction
                            
    1              0.000006 command! -nargs=* -bang RG call RipgrepFzf(<q-args>, <bang>0)
                            
                            " Git grep
    1              0.000022 command! -bang -nargs=* GGrep
                              \ call fzf#vim#grep(
                              \   'git grep --line-number '.shellescape(<q-args>), 0,
                              \   fzf#vim#with_preview({'dir': systemlist('git rev-parse --show-toplevel')[0]}), <bang>0)

SCRIPT  /home/tony/.config/nvim/plug-config/quickscope.vim
Sourced 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
                            " Trigger a highlight in the appropriate direction when pressing these keys:
    1              0.000004 let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']
                            
    1              0.000009 highlight QuickScopePrimary guifg='#00C7DF' gui=underline ctermfg=155 cterm=underline
    1              0.000007 highlight QuickScopeSecondary guifg='#afff5f' gui=underline ctermfg=81 cterm=underline
                            
    1              0.000011 let g:qs_max_chars=150

SCRIPT  /home/tony/.config/nvim/plug-config/rainbow.vim
Sourced 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000004 let g:rainbow#max_level = 16
    1              0.000012 let g:rainbow#pairs = [['(', ')'], ['[', ']'], ['{', '}']]

SCRIPT  /home/tony/.config/nvim/plug-config/rnvimr.vim
Sourced 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                            " Make Ranger replace netrw and be the file explorer
    1              0.000002 let g:rnvimr_ex_enable = 1
                            
    1              0.000018 nmap <space>r :RnvimrToggle<CR>

SCRIPT  /home/tony/.config/nvim/plug-config/signature.vim
Sourced 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000013 highlight SignatureMarkText guifg=#ff6e67

SCRIPT  /home/tony/.config/nvim/plug-config/signify.vim
Sourced 1 time
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
                            " Change these if you want
    1              0.000003 let g:signify_sign_add               = '+'
    1              0.000002 let g:signify_sign_delete            = '-'
    1              0.000002 let g:signify_sign_delete_first_line = '‾'
    1              0.000002 let g:signify_sign_change            = '~'
                            
                            " I find the numbers disctracting
    1              0.000002 let g:signify_sign_show_count = 0
    1              0.000002 let g:signify_sign_show_text = 1
                            
                            " Less priority
    1              0.000002 let g:signify_priority = 1
                            
                            " Jump though hunks
    1              0.000009 nmap <leader>gj <plug>(signify-next-hunk)
    1              0.000006 nmap <leader>gk <plug>(signify-prev-hunk)
    1              0.000006 nmap <leader>gJ 9999<leader>gJ
    1              0.000006 nmap <leader>gK 9999<leader>gk
                            
                            
                            " If you like colors instead
                            " highlight SignifySignAdd                  ctermbg=green                guibg=#00ff00
                            " highlight SignifySignDelete ctermfg=black ctermbg=red    guifg=#ffffff guibg=#ff0000
                            " highlight SignifySignChange ctermfg=black ctermbg=yellow guifg=#000000 guibg=#ffff00

SCRIPT  /home/tony/.config/nvim/plug-config/sneak.vim
Sourced 1 time
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000003 let g:sneak#label = 1
                            
                            " case insensitive sneak
    1              0.000001 let g:sneak#use_ic_scs = 1
                            
                            " immediately move to the next instance of search, if you move the cursor sneak is back to default behavior
    1              0.000001 let g:sneak#s_next = 1
                            
                            " remap so I can use , and ; with f and t
    1              0.000004 map gS <Plug>Sneak_,
    1              0.000003 map gs <Plug>Sneak_;
                            
                            " Change the colors
    1              0.000006 highlight Sneak guifg=black guibg=#00C7DF ctermfg=black ctermbg=cyan
    1              0.000015 highlight SneakScope guifg=red guibg=yellow ctermfg=red ctermbg=yellow
                            
                            " Cool prompts
                            " let g:sneak#prompt = '🕵'
                            " let g:sneak#prompt = '🔎'
                            
                            " I like quickscope better for this since it keeps me in the scope of a single line
                            " map f <Plug>Sneak_f
                            " map F <Plug>Sneak_F
                            " map t <Plug>Sneak_t
                            " map T <Plug>Sneak_T

SCRIPT  /home/tony/.config/nvim/plug-config/start-screen.vim
Sourced 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000002 let g:startify_session_dir = '~/.config/nvim/session'
                            
    1              0.000011 let g:startify_lists = [
                                      \ { 'type': 'files',     'header': ['   Files']            },
                                      \ { 'type': 'dir',       'header': ['   Current Directory '. getcwd()] },
                                      \ { 'type': 'sessions',  'header': ['   Sessions']       },
                                      \ ]
                            
    1              0.000010 let g:startify_custom_header = [
                                    \ '                        _            ',
                                    \ '  _ __   ___  _____   _(_)_ __ ___   ',
                                    \ ' | |_ \ / _ \/ _ \ \ / / | |_ ` _ \  ',
                                    \ ' | | | |  __/ (_) \ V /| | | | | | | ',
                                    \ ' |_| |_|\___|\___/ \_/ |_|_| |_| |_| ',
                                    \]

SCRIPT  /home/tony/.config/nvim/plug-config/lualine.vim
Sourced 1 time
Total time:   0.001548
 Self time:   0.001548

count  total (s)   self (s)
    1              0.000001 lua << END
                            require('lualine').setup {
                              options = {
                                icons_enabled = true,
                                theme = 'auto',
                                component_separators = { left = '', right = ''},
                                section_separators = { left = '', right = ''},
                                disabled_filetypes = {},
                                always_divide_middle = true,
                              },
                              sections = {
                                lualine_a = {'mode'},
                                lualine_b = {'branch', 'diff'},
                                lualine_c = {'filename','filesize'},
                                lualine_x = {'diagnostics','encoding',
                                    { 'fileformat',
                                        symbols = {
                                            unix = 'unix',
                                            dos = 'dos',
                                            mac = 'mac',
                                        }
                                    },
                                    { 'filetype',
                                        colored = false;
                                    }
                                },
                                lualine_y = {'progress'},
                                lualine_z = {'location'}
                              },
                              inactive_sections = {
                                lualine_a = {},
                                lualine_b = {},
                                lualine_c = {'filename'},
                                lualine_x = {'location'},
                                lualine_y = {},
                                lualine_z = {}
                              },
                            tabline = {
                                lualine_a = {'buffers'},
                                lualine_x = {},
                                lualine_y = {},
                                lualine_z = {'tabs'}
                            },
                              extensions = {
                                'quickfix',
                                'fzf'
                                  },
                            }
                            END

SCRIPT  /home/tony/.config/nvim/plug-config/airline.vim
Sourced 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  Airline theming  "
                            """"""""""""""""""""""
                            
                            " enable tabline
    1              0.000004 let g:airline#extensions#tabline#enabled = 1
    1              0.000002 let g:airline#extensions#tabline#buffer_min_count = 2
    1              0.000001 let g:airline#extensions#tabline#left_sep = ''
    1              0.000002 let g:airline#extensions#tabline#left_alt_sep = ''
    1              0.000001 let g:airline#extensions#tabline#right_sep = ''
    1              0.000002 let g:airline#extensions#tabline#right_alt_sep = ''
    1              0.000001 let g:airline#extensions#tabline#formatter = 'short_path'
                            
                            " enable powerline fonts
    1              0.000001 let g:airline_symbols_ascii = 1
    1              0.000001 let g:airline_left_sep = ''
    1              0.000001 let g:airline_right_sep = ''
                            
                            " Switch to your current theme
    1              0.000001 let g:airline_theme = 'lucius'
                            
                            " Always show tabs
    1              0.000006 set showtabline=1
                            
                            " We don't need to see things like -- INSERT -- anymore
    1              0.000010 set noshowmode

SCRIPT  /home/tony/.config/nvim/autorun/auto-source.vim
Sourced 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  Auto source  "
                            """"""""""""""""""""""
                            
                            " VIMRC
    1              0.000013 au! BufWritePost $MYVIMRC source %
                            
                            " Xbinkeys
    1              0.000003 autocmd BufWritePost *xbindkeysrc !killall xbindkeys; xbindkeys --poll-rc
                            
                            " sxhkd
    1              0.000002 autocmd BufWritePost *sxhkdrc !killall sxhkd; setsid sxhkd -t 2 &
                            
                            " Suckless
                            " autocmd BufWritePost config.h,config.def.h !sudo make install
                            
                            " Remove trailing whitespace
    1              0.000009 autocmd BufWritePre * :%s/\s\+$//e

SCRIPT  /home/tony/.config/nvim/autorun/on-startup.vim
Sourced 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
                            """"""""""""""""""""""
                            "  Autorun  "
                            """"""""""""""""""""""
                            
                            " Hex colors
    1              0.000002 autocmd BufEnter * ColorizerAttachToBuffer
                            
                            " Rainbow nested ((()))
    1              0.000001 autocmd BufEnter * RainbowParentheses
                            

SCRIPT  /home/tony/.config/nvim/autoload/plugged/coc.nvim/plugin/coc.vim
Sourced 1 time
Total time:   0.004866
 Self time:   0.000744

count  total (s)   self (s)
    1              0.000003 scriptencoding utf-8
    1              0.000006 if exists('g:did_coc_loaded') || v:version < 800
                              finish
    1              0.000000 endif
                            
    1              0.000003 function! s:checkVersion() abort
                              let l:unsupported = 0
                              if get(g:, 'coc_disable_startup_warning', 0) != 1
                                if has('nvim')
                                  let l:unsupported = !has('nvim-0.3.2')
                                else
                                  let l:unsupported = !has('patch-8.0.1453')
                                endif
                            
                                if l:unsupported == 1
                                  echohl Error
                                  echom "coc.nvim requires at least Vim 8.0.1453 or Neovim 0.3.2, but you're using an older version."
                                  echom "Please upgrade your (neo)vim."
                                  echom "You can add this to your vimrc to avoid this message:"
                                  echom "    let g:coc_disable_startup_warning = 1"
                                  echom "Note that some features may error out or behave incorrectly."
                                  echom "Please do not report bugs unless you're using at least Vim 8.0.1453 or Neovim 0.3.2."
                                  echohl None
                                  sleep 2
                                else
                                  if !has('nvim-0.4.0') && !has('patch-8.1.1719')
                                    echohl WarningMsg
                                    echom "coc.nvim works best on vim >= 8.1.1719 and neovim >= 0.4.0, consider upgrade your vim."
                                    echom "You can add this to your vimrc to avoid this message:"
                                    echom "    let g:coc_disable_startup_warning = 1"
                                    echom "Note that some features may behave incorrectly."
                                    echohl None
                                    sleep 2
                                  endif
                                endif
                              endif
                            endfunction
                            
    1   0.000035   0.000007 call s:checkVersion()
                            
    1              0.000001 let g:did_coc_loaded = 1
    1              0.000001 let g:coc_service_initialized = 0
    1              0.000003 let s:is_win = has('win32') || has('win64')
    1              0.000003 let s:root = expand('<sfile>:h:h')
    1              0.000002 let s:is_vim = !has('nvim')
    1              0.000002 let s:is_gvim = get(v:, 'progname', '') ==# 'gvim'
                            
    1              0.000002 if get(g:, 'coc_start_at_startup', 1) && !s:is_gvim
    1   0.002011   0.000124   call coc#rpc#start_server()
    1              0.000003 endif
                            
    1              0.000002 function! CocTagFunc(pattern, flags, info) abort
                              if a:flags !=# 'c'
                                " use standard tag search
                                return v:null
                              endif
                              return coc#rpc#request('getTagList', [])
                            endfunction
                            
    1              0.000001 function! CocPopupCallback(bufnr, arglist) abort
                              if len(a:arglist) == 2
                                if a:arglist[0] == 'confirm'
                                  call coc#rpc#notify('PromptInsert', [a:arglist[1]])
                                elseif a:arglist[0] == 'exit'
                                  execute 'silent! bd! '.a:bufnr
                                  "call coc#rpc#notify('PromptUpdate', [a:arglist[1]])
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! CocAction(name, ...) abort
                              if !get(g:, 'coc_service_initialized', 0)
                                throw 'coc.nvim not ready when invoke CocAction "'.a:name.'"'
                              endif
                              return coc#rpc#request(a:name, a:000)
                            endfunction
                            
    1              0.000001 function! CocHasProvider(name) abort
                              return coc#rpc#request('hasProvider', [a:name])
                            endfunction
                            
    1              0.000001 function! CocActionAsync(name, ...) abort
                              return s:AsyncRequest(a:name, a:000)
                            endfunction
                            
    1              0.000001 function! CocRequest(...) abort
                              return coc#rpc#request('sendRequest', a:000)
                            endfunction
                            
    1              0.000001 function! CocNotify(...) abort
                              return coc#rpc#request('sendNotification', a:000)
                            endfunction
                            
    1              0.000001 function! CocRegistNotification(id, method, cb) abort
                              call coc#on_notify(a:id, a:method, a:cb)
                            endfunction
                            
    1              0.000001 function! CocLocations(id, method, ...) abort
                              let args = [a:id, a:method] + copy(a:000)
                              return coc#rpc#request('findLocations', args)
                            endfunction
                            
    1              0.000001 function! CocLocationsAsync(id, method, ...) abort
                              let args = [a:id, a:method] + copy(a:000)
                              return s:AsyncRequest('findLocations', args)
                            endfunction
                            
    1              0.000001 function! CocRequestAsync(...)
                              return s:AsyncRequest('sendRequest', a:000)
                            endfunction
                            
    1              0.000002 function! s:AsyncRequest(name, args) abort
                              let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
                              if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
                              endif
                              call coc#rpc#notify(a:name, a:args)
                              return ''
                            endfunction
                            
    1              0.000001 function! s:CommandList(...) abort
                              let list = coc#rpc#request('commandList', a:000)
                              return join(list, "\n")
                            endfunction
                            
    1              0.000001 function! s:ExtensionList(...) abort
                              let stats = CocAction('extensionStats')
                              call filter(stats, 'v:val["isLocal"] == v:false')
                              let list = map(stats, 'v:val["id"]')
                              return join(list, "\n")
                            endfunction
                            
    1              0.000001 function! s:SearchOptions(...) abort
                              let list = ['-e', '--regexp', '-F', '--fixed-strings', '-L', '--follow',
                                    \ '-g', '--glob', '--hidden', '--no-hidden', '--no-ignore-vcs',
                                    \ '--word-regexp', '-w', '--smart-case', '-S', '--no-config',
                                    \ '--line-regexp', '--no-ignore', '-x']
                              return join(list, "\n")
                            endfunction
                            
    1              0.000001 function! s:LoadedExtensions(...) abort
                              let list = CocAction('loadedExtensions')
                              return join(list, "\n")
                            endfunction
                            
    1              0.000001 function! s:InstallOptions(...)abort
                              let list = ['-terminal', '-sync']
                              return join(list, "\n")
                            endfunction
                            
    1              0.000001 function! s:OpenConfig()
                              let home = coc#util#get_config_home()
                              if !isdirectory(home)
                                echohl MoreMsg
                                echom 'Config directory "'.home.'" not exists, create? (y/n)'
                                echohl None
                                let confirm = nr2char(getchar())
                                redraw!
                                if !(confirm ==? "y" || confirm ==? "\r")
                                  return
                                else
                                  call mkdir(home, 'p')
                                end
                              endif
                              execute 'edit '.home.'/coc-settings.json'
                              call coc#rpc#notify('checkJsonExtension', [])
                            endfunction
                            
    1              0.000001 function! s:get_color(item, fallback) abort
                              let t = type(a:item)
                              if t == 1
                                return a:item
                              endif
                              if t == 4
                                let item = get(a:item, 'gui', {})
                                let color = get(item, &background, a:fallback)
                                return type(color) == 1 ? color : a:fallback
                              endif
                              return a:fallback
                            endfunction
                            
    1              0.000001 function! s:AddAnsiGroups() abort
                              let color_map = {}
                              let colors = ['#282828', '#cc241d', '#98971a', '#d79921', '#458588', '#b16286', '#689d6a', '#a89984', '#928374']
                              let names = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white', 'grey']
                              for i in range(0, len(names) - 1)
                                let name = names[i]
                                if exists('g:terminal_ansi_colors')
                                  let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
                                else
                                  let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
                                endif
                              endfor
                              try
                                for name in keys(color_map)
                                  let foreground = toupper(name[0]).name[1:]
                                  let foregroundColor = color_map[name]
                                  for key in keys(color_map)
                                    let background = toupper(key[0]).key[1:]
                                    let backgroundColor = color_map[key]
                                    exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
                                  endfor
                                  exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
                                  exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
                                endfor
                              catch /.*/
                                " ignore invalid color
                              endtry
                            endfunction
                            
    1              0.000001 function! s:CursorRangeFromSelected(type, ...) abort
                              " add range by operator
                              call coc#rpc#request('cursorsSelect', [bufnr('%'), 'operator', a:type])
                            endfunction
                            
    1              0.000001 function! s:OpenDiagnostics(...) abort
                              let height = get(a:, 1, 0)
                              call coc#rpc#request('fillDiagnostics', [bufnr('%')])
                              if height
                                execute ':lopen '.height
                               else
                                lopen
                              endif
                            endfunction
                            
    1              0.000001 function! s:Disable() abort
                              if get(g:, 'coc_enabled', 0) == 0
                                return
                              endif
                              augroup coc_nvim
                                autocmd!
                              augroup end
                              call coc#rpc#request('detach', [])
                              echohl MoreMsg
                                echom '[coc.nvim] Event disabled'
                              echohl None
                              let g:coc_enabled = 0
                            endfunction
                            
    1              0.000001 function! s:Autocmd(...) abort
                              if !g:coc_service_initialized
                                return
                              endif
                              call coc#rpc#notify('CocAutocmd', a:000)
                            endfunction
                            
    1              0.000001 function! s:HandleCharInsert(char, bufnr) abort
                              if get(g:, 'coc_disable_space_report', 0)
                                let g:coc_disable_space_report = 0
                                if a:char ==# ' '
                                  return
                                endif
                              endif
                              call s:Autocmd('InsertCharPre', a:char, a:bufnr)
                            endfunction
                            
    1              0.000001 function! s:SyncAutocmd(...)
                              if !g:coc_service_initialized
                                return
                              endif
                              call coc#rpc#request('CocAutocmd', a:000)
                            endfunction
                            
    1              0.000001 function! s:Enable(initialize)
                              if get(g:, 'coc_enabled', 0) == 1
                                return
                              endif
                              let g:coc_enabled = 1
                            
                              augroup coc_nvim
                                autocmd!
                            
                                if exists('##MenuPopupChanged') && exists('*nvim_open_win')
                                  autocmd MenuPopupChanged *   call s:Autocmd('MenuPopupChanged', get(v:, 'event', {}), win_screenpos(winnr())[0] + winline() - 2)
                                endif
                                if exists('##CompleteChanged')
                                  autocmd CompleteChanged *   call s:Autocmd('MenuPopupChanged', get(v:, 'event', {}), win_screenpos(winnr())[0] + winline() - 2)
                                endif
                            
                                if coc#rpc#started()
                                  autocmd VimEnter            * call coc#rpc#notify('VimEnter', [])
                                elseif get(g:, 'coc_start_at_startup', 1)
                                  autocmd VimEnter            * call coc#rpc#start_server()
                                endif
                                if s:is_vim
                                  if exists('##DirChanged')
                                    autocmd DirChanged        * call s:Autocmd('DirChanged', getcwd())
                                  endif
                                  if exists('##TerminalOpen')
                                    autocmd TerminalOpen      * call s:Autocmd('TermOpen', +expand('<abuf>'))
                                  endif
                                else
                                  autocmd DirChanged        * call s:Autocmd('DirChanged', get(v:event, 'cwd', ''))
                                  autocmd TermOpen          * call s:Autocmd('TermOpen', +expand('<abuf>'))
                                  autocmd TermClose         * call s:Autocmd('TermClose', +expand('<abuf>'))
                                  autocmd CursorMoved       * call coc#float#nvim_refresh_scrollbar(win_getid())
                                  autocmd WinEnter          * call coc#float#nvim_win_enter(win_getid())
                                  if exists('##WinClosed')
                                    autocmd WinClosed       * call coc#float#close_related(+expand('<afile>'))
                                    autocmd WinClosed       * call s:Autocmd('WinClosed', +expand('<afile>'))
                                  endif
                                endif
                                if has('nvim-0.4.0') || has('patch-8.1.1719')
                                  autocmd CursorHold        * call coc#float#check_related()
                                endif
                                autocmd WinLeave            * call s:Autocmd('WinLeave', win_getid())
                                autocmd WinEnter            * call s:Autocmd('WinEnter', win_getid())
                                autocmd BufWinLeave         * call s:Autocmd('BufWinLeave', +expand('<abuf>'), bufwinid(+expand('<abuf>')))
                                autocmd BufWinEnter         * call s:Autocmd('BufWinEnter', +expand('<abuf>'), win_getid())
                                autocmd FileType            * call s:Autocmd('FileType', expand('<amatch>'), +expand('<abuf>'))
                                autocmd CompleteDone        * call s:Autocmd('CompleteDone', get(v:, 'completed_item', {}))
                                autocmd InsertCharPre       * call s:HandleCharInsert(v:char, bufnr('%'))
                                if exists('##TextChangedP')
                                  autocmd TextChangedP        * call s:Autocmd('TextChangedP', +expand('<abuf>'), {'lnum': line('.'), 'col': col('.'), 'line': getline('.'), 'changedtick': b:changedtick})
                                endif
                                autocmd TextChangedI        * call s:Autocmd('TextChangedI', +expand('<abuf>'), {'lnum': line('.'), 'col': col('.'), 'pre': strpart(getline('.'), 0, col('.') - 1), 'changedtick': b:changedtick})
                                autocmd InsertLeave         * call s:Autocmd('InsertLeave', +expand('<abuf>'))
                                autocmd InsertEnter         * call s:Autocmd('InsertEnter', +expand('<abuf>'))
                                autocmd BufHidden           * call s:Autocmd('BufHidden', +expand('<abuf>'))
                                autocmd BufEnter            * call s:Autocmd('BufEnter', +expand('<abuf>'))
                                autocmd TextChanged         * call s:Autocmd('TextChanged', +expand('<abuf>'), getbufvar(+expand('<abuf>'), 'changedtick'))
                                autocmd BufWritePost        * call s:Autocmd('BufWritePost', +expand('<abuf>'))
                                autocmd CursorMoved         * call s:Autocmd('CursorMoved', +expand('<abuf>'), [line('.'), col('.')])
                                autocmd CursorMovedI        * call s:Autocmd('CursorMovedI', +expand('<abuf>'), [line('.'), col('.')])
                                autocmd CursorHold          * call s:Autocmd('CursorHold', +expand('<abuf>'))
                                autocmd CursorHoldI         * call s:Autocmd('CursorHoldI', +expand('<abuf>'))
                                autocmd BufNewFile,BufReadPost * call s:Autocmd('BufCreate', +expand('<abuf>'))
                                autocmd BufUnload           * call s:Autocmd('BufUnload', +expand('<abuf>'))
                                autocmd BufWritePre         * call s:SyncAutocmd('BufWritePre', +expand('<abuf>'))
                                autocmd FocusGained         * if mode() !~# '^c' | call s:Autocmd('FocusGained') | endif
                                autocmd FocusLost           * call s:Autocmd('FocusLost')
                                autocmd VimResized          * call s:Autocmd('VimResized', &columns, &lines)
                                autocmd VimLeavePre         * let g:coc_vim_leaving = 1
                                autocmd BufReadCmd,FileReadCmd,SourceCmd list://* call coc#list#setup(expand('<amatch>'))
                                autocmd BufWriteCmd __coc_refactor__* :call coc#rpc#notify('saveRefactor', [+expand('<abuf>')])
                                autocmd ColorScheme * call s:Hi()
                              augroup end
                              if a:initialize == 0
                                 call coc#rpc#request('attach', [])
                                 echohl MoreMsg
                                 echom '[coc.nvim] Event enabled'
                                 echohl None
                              endif
                            endfunction
                            
    1              0.000001 function! s:Hi() abort
                              hi default CocErrorSign     ctermfg=Red     guifg=#ff0000 guibg=NONE
                              hi default CocWarningSign   ctermfg=Brown   guifg=#ff922b guibg=NONE
                              hi default CocInfoSign      ctermfg=Yellow  guifg=#fab005 guibg=NONE
                              hi default CocHintSign      ctermfg=Blue    guifg=#15aabf guibg=NONE
                              hi default CocSelectedText  ctermfg=Red     guifg=#fb4934 guibg=NONE
                              hi default CocCodeLens      ctermfg=Gray    guifg=#999999 guibg=NONE
                              hi default CocUnderline     term=underline cterm=underline gui=underline
                              hi default CocBold          term=bold cterm=bold gui=bold
                              hi default CocItalic        term=italic cterm=italic gui=italic
                              if s:is_vim || has('nvim-0.4.0')
                                hi default CocStrikeThrough term=strikethrough cterm=strikethrough gui=strikethrough
                              else
                                hi default CocStrikeThrough guifg=#989898 ctermfg=gray
                              endif
                              hi default CocMarkdownLink  ctermfg=Blue    guifg=#15aabf guibg=NONE
                              hi default CocDisabled guifg=#999999 ctermfg=gray
                              hi default link CocFadeOut             Conceal
                              hi default link CocMarkdownCode        markdownCode
                              hi default link CocMarkdownHeader      markdownH1
                              hi default link CocMenuSel             PmenuSel
                              hi default link CocErrorFloat          CocErrorSign
                              hi default link CocWarningFloat        CocWarningSign
                              hi default link CocInfoFloat           CocInfoSign
                              hi default link CocHintFloat           CocHintSign
                              hi default link CocErrorHighlight      CocUnderline
                              hi default link CocWarningHighlight    CocUnderline
                              hi default link CocInfoHighlight       CocUnderline
                              hi default link CocHintHighlight       CocUnderline
                              hi default link CocDeprecatedHighlight CocStrikeThrough
                              hi default link CocUnusedHighlight     CocFadeOut
                              hi default link CocListMode            ModeMsg
                              hi default link CocListPath            Comment
                              hi default link CocHighlightText       CursorColumn
                              hi default link CocHoverRange          Search
                              hi default link CocCursorRange         Search
                              hi default link CocHighlightRead       CocHighlightText
                              hi default link CocHighlightWrite      CocHighlightText
                              " Tree view highlights
                              hi default link CocTreeTitle       Title
                              hi default link CocTreeDescription Comment
                              hi default link CocTreeOpenClose   CocBold
                              hi default link CocTreeSelected    CursorLine
                              hi default link CocSelectedRange   CocHighlightText
                              " Symbol highlights
                              hi default link CocSymbolDefault       MoreMsg
                              hi default link CocSymbolFile          Statement
                              hi default link CocSymbolModule        Statement
                              hi default link CocSymbolNamespace     Statement
                              hi default link CocSymbolPackage       Statement
                              hi default link CocSymbolClass         Statement
                              hi default link CocSymbolMethod        Function
                              hi default link CocSymbolProperty      Keyword
                              hi default link CocSymbolField         CocSymbolDefault
                              hi default link CocSymbolConstructor   Function
                              hi default link CocSymbolEnum          CocSymbolDefault
                              hi default link CocSymbolInterface     CocSymbolDefault
                              hi default link CocSymbolFunction      Function
                              hi default link CocSymbolVariable      CocSymbolDefault
                              hi default link CocSymbolConstant      Constant
                              hi default link CocSymbolString        String
                              hi default link CocSymbolNumber        Number
                              hi default link CocSymbolBoolean       Boolean
                              hi default link CocSymbolArray         CocSymbolDefault
                              hi default link CocSymbolObject        CocSymbolDefault
                              hi default link CocSymbolKey           Keyword
                              hi default link CocSymbolNull          Type
                              hi default link CocSymbolEnumMember    CocSymbolDefault
                              hi default link CocSymbolStruct        Keyword
                              hi default link CocSymbolEvent         Keyword
                              hi default link CocSymbolOperator      Operator
                              hi default link CocSymbolTypeParameter Operator
                            
                              if has('nvim')
                                hi default link CocFloating NormalFloat
                              else
                                hi default link CocFloating Pmenu
                              endif
                              if !exists('*sign_getdefined') || empty(sign_getdefined('CocCurrentLine'))
                                sign define CocCurrentLine linehl=CocMenuSel
                              endif
                              if !exists('*sign_getdefined') || empty(sign_getdefined('CocTreeSelected'))
                                sign define CocTreeSelected linehl=CocTreeSelected
                              endif
                              if has('nvim-0.5.0')
                                hi default CocCursorTransparent gui=strikethrough blend=100
                              endif
                            
                              if has('nvim')
                                let names = ['Error', 'Warning', 'Info', 'Hint']
                                for name in names
                                  if !hlexists('Coc'.name.'VirtualText')
                                    exe 'hi default link Coc'.name.'VirtualText Coc'.name.'Sign'
                                  endif
                                endfor
                              endif
                              call s:AddAnsiGroups()
                            
                              if get(g:, 'coc_default_semantic_highlight_groups', 1)
                                let hlMap = {
                                    \ 'Namespace': ['TSNamespace', 'Include'],
                                    \ 'Type': ['TSType', 'Type'],
                                    \ 'Class': ['TSConstructor', 'Special'],
                                    \ 'Enum': ['TSEnum', 'Type'],
                                    \ 'Interface': ['TSInterface', 'Type'],
                                    \ 'Struct': ['TSStruct', 'Identifier'],
                                    \ 'TypeParameter': ['TSParameter', 'Identifier'],
                                    \ 'Parameter': ['TSParameter', 'Identifier'],
                                    \ 'Variable': ['TSSymbol', 'Identifier'],
                                    \ 'Property': ['TSProperty', 'Identifier'],
                                    \ 'EnumMember': ['TSEnumMember', 'Constant'],
                                    \ 'Event': ['TSEvent', 'Keyword'],
                                    \ 'Function': ['TSFunction', 'Function'],
                                    \ 'Method': ['TSMethod', 'Function'],
                                    \ 'Macro': ['TSConstMacro', 'Define'],
                                    \ 'Keyword': ['TSKeyword', 'Keyword'],
                                    \ 'Modifier': ['TSModifier', 'StorageClass'],
                                    \ 'Comment': ['TSComment', 'Comment'],
                                    \ 'String': ['TSString', 'String'],
                                    \ 'Number': ['TSNumber', 'Number'],
                                    \ 'Boolean': ['TSBoolean', 'Boolean'],
                                    \ 'Regexp': ['TSStringRegex', 'String'],
                                    \ 'Operator': ['TSOperator', 'Operator'],
                                    \ 'Decorator': ['TSSymbol', 'Identifier'],
                                    \ 'Deprecated': ['TSStrike', 'CocDeprecatedHighlight']
                                    \ }
                                for [key, value] in items(hlMap)
                                  let ts = get(value, 0, '')
                                  let fallback = get(value, 1, '')
                                  execute 'hi default link CocSem'.key.' '.(hlexists(ts) ? ts : fallback)
                                endfor
                              endif
                            endfunction
                            
    1              0.000001 function! s:FormatFromSelected(type)
                              call CocActionAsync('formatSelected', a:type)
                            endfunction
                            
    1              0.000001 function! s:CodeActionFromSelected(type)
                              call CocActionAsync('codeAction', a:type)
                            endfunction
                            
    1              0.000001 function! s:ShowInfo()
                              if coc#rpc#ready()
                                call coc#rpc#notify('showInfo', [])
                              else
                                let lines = []
                                echomsg 'coc.nvim service not started, checking environment...'
                                let node = get(g:, 'coc_node_path', $COC_NODE_PATH == '' ? 'node' : $COC_NODE_PATH)
                                if !executable(node)
                                  call add(lines, 'Error: '.node.' is not executable!')
                                else
                                  let output = trim(system(node . ' --version'))
                                  let ms = matchlist(output, 'v\(\d\+\).\(\d\+\).\(\d\+\)')
                                  if empty(ms) || str2nr(ms[1]) < 12 || (str2nr(ms[1]) == 12 && str2nr(ms[2]) < 12)
                                    call add(lines, 'Error: Node version '.output.' < 12.12.0, please upgrade node.js')
                                  endif
                                endif
                                " check bundle
                                let file = s:root.'/build/index.js'
                                if !filereadable(file)
                                  call add(lines, 'Error: javascript bundle not found, please compile code of coc.nvim by esbuild.')
                                endif
                                if !empty(lines)
                                  botright vnew
                                  setl filetype=nofile
                                  call setline(1, lines)
                                else
                                  if get(g:, 'coc_start_at_startup',1)
                                    echohl MoreMsg | echon 'Service stopped for some unknown reason, try :CocStart' | echohl None
                                  else
                                    echohl MoreMsg | echon 'Start on startup is disabled, try :CocStart' | echohl None
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000007 command! -nargs=0 CocOutline      :call coc#rpc#notify('showOutline', [])
    1              0.000002 command! -nargs=? CocDiagnostics  :call s:OpenDiagnostics(<f-args>)
    1              0.000001 command! -nargs=0 CocInfo         :call s:ShowInfo()
    1              0.000003 command! -nargs=0 CocOpenLog      :call coc#rpc#notify('openLog',  [])
    1              0.000001 command! -nargs=0 CocDisable      :call s:Disable()
    1              0.000001 command! -nargs=0 CocEnable       :call s:Enable(0)
    1              0.000002 command! -nargs=0 CocConfig       :call s:OpenConfig()
    1              0.000002 command! -nargs=0 CocLocalConfig  :call coc#rpc#notify('openLocalConfig', [])
    1              0.000001 command! -nargs=0 CocRestart      :call coc#rpc#restart()
    1              0.000003 command! -nargs=0 CocStart        :call coc#rpc#start_server()
    1              0.000001 command! -nargs=0 CocRebuild      :call coc#util#rebuild()
    1              0.000004 command! -nargs=1 -complete=custom,s:LoadedExtensions  CocWatch    :call coc#rpc#notify('watchExtension', [<f-args>])
    1              0.000003 command! -nargs=+ -complete=custom,s:SearchOptions  CocSearch    :call coc#rpc#notify('search', [<f-args>])
    1              0.000002 command! -nargs=+ -complete=custom,s:ExtensionList  CocUninstall :call CocActionAsync('uninstallExtension', <f-args>)
    1              0.000003 command! -nargs=* -complete=custom,s:CommandList -range CocCommand :call coc#rpc#notify('runCommand', [<f-args>])
    1              0.000003 command! -nargs=* -complete=custom,coc#list#options CocList      :call coc#rpc#notify('openList',  [<f-args>])
    1              0.000003 command! -nargs=? -complete=custom,coc#list#names CocListResume   :call coc#rpc#notify('listResume', [<f-args>])
    1              0.000002 command! -nargs=? -complete=custom,coc#list#names CocListCancel   :call coc#rpc#notify('listCancel', [])
    1              0.000002 command! -nargs=? -complete=custom,coc#list#names CocPrev         :call coc#rpc#notify('listPrev', [<f-args>])
    1              0.000002 command! -nargs=? -complete=custom,coc#list#names CocNext         :call coc#rpc#notify('listNext', [<f-args>])
    1              0.000002 command! -nargs=? -complete=custom,coc#list#names CocFirst        :call coc#rpc#notify('listFirst', [<f-args>])
    1              0.000002 command! -nargs=? -complete=custom,coc#list#names CocLast         :call coc#rpc#notify('listLast', [<f-args>])
    1              0.000006 command! -nargs=* -range CocAction :call coc#rpc#notify('codeActionRange', [<line1>, <line2>, <f-args>])
    1              0.000004 command! -nargs=* -range CocFix    :call coc#rpc#notify('codeActionRange', [<line1>, <line2>, 'quickfix'])
    1              0.000002 command! -nargs=0 CocUpdate       :call coc#util#update_extensions(1)
    1              0.000002 command! -nargs=0 -bar CocUpdateSync   :call coc#util#update_extensions()
    1              0.000002 command! -nargs=* -bar -complete=custom,s:InstallOptions CocInstall   :call coc#util#install_extension([<f-args>])
                            
    1   0.000435   0.000012 call s:Enable(1)
    1   0.001802   0.000016 call s:Hi()
                            
    1              0.000016 vnoremap <silent> <Plug>(coc-range-select)          :<C-u>call       CocActionAsync('rangeSelect',     visualmode(), v:true)<CR>
    1              0.000008 vnoremap <silent> <Plug>(coc-range-select-backward) :<C-u>call       CocActionAsync('rangeSelect',     visualmode(), v:false)<CR>
    1              0.000007 nnoremap <Plug>(coc-range-select)          :<C-u>call       CocActionAsync('rangeSelect',     '', v:true)<CR>
    1              0.000005 nnoremap <Plug>(coc-codelens-action)       :<C-u>call       CocActionAsync('codeLensAction')<CR>
    1              0.000006 vnoremap <silent> <Plug>(coc-format-selected)       :<C-u>call       CocActionAsync('formatSelected',     visualmode())<CR>
    1              0.000005 vnoremap <silent> <Plug>(coc-codeaction-selected)   :<C-u>call       CocActionAsync('codeAction',         visualmode())<CR>
    1              0.000007 nnoremap <Plug>(coc-codeaction-selected)   :<C-u>set        operatorfunc=<SID>CodeActionFromSelected<CR>g@
    1              0.000005 nnoremap <Plug>(coc-codeaction)            :<C-u>call       CocActionAsync('codeAction',         '')<CR>
    1              0.000004 nnoremap <Plug>(coc-codeaction-line)       :<C-u>call       CocActionAsync('codeAction',         'line')<CR>
    1              0.000005 nnoremap <Plug>(coc-codeaction-cursor)     :<C-u>call       CocActionAsync('codeAction',         'cursor')<CR>
    1              0.000004 nnoremap <silent> <Plug>(coc-rename)                :<C-u>call       CocActionAsync('rename')<CR>
    1              0.000004 nnoremap <silent> <Plug>(coc-format-selected)       :<C-u>set        operatorfunc=<SID>FormatFromSelected<CR>g@
    1              0.000004 nnoremap <silent> <Plug>(coc-format)                :<C-u>call       CocActionAsync('format')<CR>
    1              0.000004 nnoremap <silent> <Plug>(coc-diagnostic-info)       :<C-u>call       CocActionAsync('diagnosticInfo')<CR>
    1              0.000004 nnoremap <silent> <Plug>(coc-diagnostic-next)       :<C-u>call       CocActionAsync('diagnosticNext')<CR>
    1              0.000005 nnoremap <silent> <Plug>(coc-diagnostic-prev)       :<C-u>call       CocActionAsync('diagnosticPrevious')<CR>
    1              0.000005 nnoremap <silent> <Plug>(coc-diagnostic-next-error) :<C-u>call       CocActionAsync('diagnosticNext',     'error')<CR>
    1              0.000005 nnoremap <silent> <Plug>(coc-diagnostic-prev-error) :<C-u>call       CocActionAsync('diagnosticPrevious', 'error')<CR>
    1              0.000004 nnoremap <silent> <Plug>(coc-definition)            :<C-u>call       CocActionAsync('jumpDefinition')<CR>
    1              0.000039 nnoremap <silent> <Plug>(coc-declaration)           :<C-u>call       CocActionAsync('jumpDeclaration')<CR>
    1              0.000006 nnoremap <silent> <Plug>(coc-implementation)        :<C-u>call       CocActionAsync('jumpImplementation')<CR>
    1              0.000006 nnoremap <silent> <Plug>(coc-type-definition)       :<C-u>call       CocActionAsync('jumpTypeDefinition')<CR>
    1              0.000004 nnoremap <silent> <Plug>(coc-references)            :<C-u>call       CocActionAsync('jumpReferences')<CR>
    1              0.000004 nnoremap <silent> <Plug>(coc-references-used)       :<C-u>call       CocActionAsync('jumpUsed')<CR>
    1              0.000006 nnoremap <silent> <Plug>(coc-openlink)              :<C-u>call       CocActionAsync('openLink')<CR>
    1              0.000004 nnoremap <silent> <Plug>(coc-fix-current)           :<C-u>call       CocActionAsync('doQuickfix')<CR>
    1              0.000004 nnoremap <silent> <Plug>(coc-float-hide)            :<C-u>call       coc#float#close_all()<CR>
    1              0.000004 nnoremap <silent> <Plug>(coc-float-jump)            :<c-u>call       coc#float#jump()<cr>
    1              0.000004 nnoremap <silent> <Plug>(coc-command-repeat)        :<C-u>call       CocAction('repeatCommand')<CR>
    1              0.000004 nnoremap <silent> <Plug>(coc-refactor)              :<C-u>call       CocActionAsync('refactor')<CR>
    1              0.000004 inoremap <silent>                          <Plug>CocRefresh <C-r>=coc#_complete()<CR>
                            
    1              0.000006 nnoremap <silent> <Plug>(coc-cursors-operator) :<C-u>set operatorfunc=<SID>CursorRangeFromSelected<CR>g@
    1              0.000007 vnoremap <silent> <Plug>(coc-cursors-range)    :<C-u>call CocAction('cursorsSelect', bufnr('%'), 'range', visualmode())<CR>
    1              0.000006 nnoremap <silent> <Plug>(coc-cursors-word)     :<C-u>call CocAction('cursorsSelect', bufnr('%'), 'word', 'n')<CR>
    1              0.000005 nnoremap <silent> <Plug>(coc-cursors-position) :<C-u>call CocAction('cursorsSelect', bufnr('%'), 'position', 'n')<CR>
                            
    1              0.000007 vnoremap <silent> <Plug>(coc-funcobj-i)        :<C-U>call CocAction('selectSymbolRange', v:true, visualmode(), ['Method', 'Function'])<CR>
    1              0.000005 vnoremap <silent> <Plug>(coc-funcobj-a)        :<C-U>call CocAction('selectSymbolRange', v:false, visualmode(), ['Method', 'Function'])<CR>
    1              0.000006 onoremap <silent> <Plug>(coc-funcobj-i)        :<C-U>call CocAction('selectSymbolRange', v:true, '', ['Method', 'Function'])<CR>
    1              0.000007 onoremap <silent> <Plug>(coc-funcobj-a)        :<C-U>call CocAction('selectSymbolRange', v:false, '', ['Method', 'Function'])<CR>
                            
    1              0.000005 vnoremap <silent> <Plug>(coc-classobj-i)       :<C-U>call CocAction('selectSymbolRange', v:true, visualmode(), ['Interface', 'Struct', 'Class'])<CR>
    1              0.000006 vnoremap <silent> <Plug>(coc-classobj-a)       :<C-U>call CocAction('selectSymbolRange', v:false, visualmode(), ['Interface', 'Struct', 'Class'])<CR>
    1              0.000006 onoremap <silent> <Plug>(coc-classobj-i)       :<C-U>call CocAction('selectSymbolRange', v:true, '', ['Interface', 'Struct', 'Class'])<CR>
    1              0.000018 onoremap <silent> <Plug>(coc-classobj-a)       :<C-U>call CocAction('selectSymbolRange', v:false, '', ['Interface', 'Struct', 'Class'])<CR>

SCRIPT  /home/tony/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/rpc.vim
Sourced 1 time
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
    1              0.000002 scriptencoding utf-8
    1              0.000005 let s:is_win = has("win32") || has("win64")
    1              0.000001 let s:client = v:null
    1              0.000001 let s:name = 'coc'
    1              0.000002 let s:is_vim = !has('nvim')
                            
    1              0.000001 function! coc#rpc#start_server()
                              if get(g:, 'coc_node_env', '') ==# 'test'
                                " server already started
                                let s:client = coc#client#create(s:name, [])
                                let s:client['running'] = 1
                                let s:client['chan_id'] = get(g:, 'coc_node_channel_id', 0)
                                call dictwatcheradd(g:, 'coc_node_channel_id', function('s:ChannelSet'))
                                return
                              endif
                              if empty(s:client)
                                let cmd = coc#util#job_command()
                                if empty(cmd) | return | endif
                                let $COC_VIMCONFIG = coc#util#get_config_home()
                                let $COC_DATA_HOME = coc#util#get_data_home()
                                let s:client = coc#client#create(s:name, cmd)
                              endif
                              if !coc#client#is_running('coc')
                                call s:client['start']()
                              endif
                            endfunction
                            
    1              0.000001 function! coc#rpc#started() abort
                              return !empty(s:client)
                            endfunction
                            
    1              0.000001 function! coc#rpc#ready()
                              if empty(s:client) || s:client['running'] == 0
                                return 0
                              endif
                              return 1
                            endfunction
                            
    1              0.000002 function! s:ChannelSet(dict, key, val)
                              let chan_id = get(a:val, 'new', 0)
                              if empty(s:client) | return | endif
                              let s:client['running'] = 1
                              let s:client['chan_id'] = chan_id
                              call dictwatcherdel(g:, 'coc_node_channel_id', function('s:ChannelSet'))
                            endfunction
                            
    1              0.000001 function! coc#rpc#kill()
                              let pid = get(g:, 'coc_process_pid', 0)
                              if !pid | return | endif
                              if s:is_win
                                call system('taskkill /PID '.pid)
                              else
                                call system('kill -9 '.pid)
                              endif
                            endfunction
                            
    1              0.000001 function! coc#rpc#get_errors()
                              return split(execute('messages'), "\n")
                            endfunction
                            
    1              0.000001 function! coc#rpc#stop()
                              if empty(s:client)
                                return
                              endif
                              try
                                if s:is_vim
                                  call job_stop(ch_getjob(s:client['channel']), 'term')
                                else
                                  call jobstop(s:client['chan_id'])
                                endif
                              catch /.*/
                                " ignore
                              endtry
                            endfunction
                            
    1              0.000001 function! coc#rpc#restart()
                              if empty(s:client)
                                call coc#rpc#start_server()
                              else
                                call coc#float#close_all()
                                call coc#rpc#request('detach', [])
                                sleep 100m
                                let s:client['command'] = coc#util#job_command()
                                call coc#client#restart(s:name)
                                echohl MoreMsg | echom 'starting coc.nvim service' | echohl None
                              endif
                            endfunction
                            
    1              0.000001 function! coc#rpc#request(method, args) abort
                              if !coc#rpc#ready()
                                return ''
                              endif
                              return s:client['request'](a:method, a:args)
                            endfunction
                            
    1              0.000001 function! coc#rpc#notify(method, args) abort
                              if !coc#rpc#ready()
                                return ''
                              endif
                              call s:client['notify'](a:method, a:args)
                              return ''
                            endfunction
                            
    1              0.000001 function! coc#rpc#request_async(method, args, cb) abort
                              if !coc#rpc#ready()
                                return cb('coc.nvim service not started.')
                              endif
                              call s:client['request_async'](a:method, a:args, a:cb)
                            endfunction
                            
                            " receive async response
    1              0.000001 function! coc#rpc#async_response(id, resp, isErr) abort
                              if empty(s:client)
                                return
                              endif
                              call coc#client#on_response(s:name, a:id, a:resp, a:isErr)
                            endfunction
                            
                            " send async response to server
    1              0.000001 function! coc#rpc#async_request(id, method, args)
                              let l:Cb = {err, ... -> coc#rpc#notify('nvim_async_response_event', [a:id, err, get(a:000, 0, v:null)])}
                              let args = a:args + [l:Cb]
                              try
                                call call(a:method, args)
                              catch /.*/
                                call coc#rpc#notify('nvim_async_response_event', [a:id, v:exception, v:null])
                              endtry
                            endfunction

SCRIPT  /home/tony/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/util.vim
Sourced 1 time
Total time:   0.000357
 Self time:   0.000357

count  total (s)   self (s)
    1              0.000002 scriptencoding utf-8
    1              0.000003 let s:root = expand('<sfile>:h:h:h')
    1              0.000004 let s:is_win = has('win32') || has('win64')
    1              0.000002 let s:is_vim = !has('nvim')
    1              0.000003 let s:clear_match_by_id = has('nvim-0.5.0') || has('patch-8.1.1084')
    1              0.000001 let s:vim_api_version = 20
    1              0.000001 let s:activate = ""
    1              0.000001 let s:quit = ""
                            
    1              0.000002 if has("gui_macvim") && has('gui_running')
                              let s:app = "MacVim"
    1              0.000002 elseif $TERM_PROGRAM ==# "Apple_Terminal"
                              let s:app = "Terminal"
    1              0.000001 elseif $TERM_PROGRAM ==# "iTerm.app"
                              let s:app = "iTerm2"
    1              0.000001 elseif has('mac')
                              let s:app = "System Events"
                              let s:quit = "quit"
                              let s:activate = 'activate'
    1              0.000000 endif
                            
    1              0.000001 function! coc#util#api_version() abort
                              return s:vim_api_version
                            endfunction
                            
    1              0.000001 function! coc#util#semantic_hlgroups() abort
                              let res = split(execute('hi'), "\n")
                              let filtered = filter(res, "v:val =~# '^CocSem'")
                              return map(filtered, "matchstr(v:val,'\\v^CocSem\\w+')")
                            endfunction
                            
                            " get cursor position
    1              0.000001 function! coc#util#cursor()
                              return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]
                            endfunction
                            
    1              0.000001 function! coc#util#has_preview()
                              for i in range(1, winnr('$'))
                                if getwinvar(i, '&previewwindow')
                                  return i
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000001 function! coc#util#jumpTo(line, character) abort
                              echohl WarningMsg | echon 'coc#util#jumpTo is deprecated, use coc#cursor#move_to instead.' | echohl None
                              call coc#cursor#move_to(a:line, a:character)
                            endfunction
                            
    1              0.000001 function! coc#util#path_replace_patterns() abort
                              if has('win32unix') && exists('g:coc_cygqwin_path_prefixes')
                                echohl WarningMsg 
                                echon 'g:coc_cygqwin_path_prefixes is deprecated, use g:coc_uri_prefix_replace_patterns instead' 
                                echohl None
                                return g:coc_cygqwin_path_prefixes
                              endif
                              if exists('g:coc_uri_prefix_replace_patterns')
                                return g:coc_uri_prefix_replace_patterns
                              endif
                              return v:null
                            endfunction
                            
    1              0.000001 function! coc#util#version()
                              if s:is_vim
                                return string(v:versionlong)
                              endif
                              let c = execute('silent version')
                              let lines = split(matchstr(c,  'NVIM v\zs[^\n-]*'))
                              return lines[0]
                            endfunction
                            
    1              0.000001 function! coc#util#check_refresh(bufnr)
                              if !bufloaded(a:bufnr)
                                return 0
                              endif
                              if getbufvar(a:bufnr, 'coc_diagnostic_disable', 0)
                                return 0
                              endif
                              if get(g: , 'EasyMotion_loaded', 0)
                                return EasyMotion#is_active() != 1
                              endif
                              return 1
                            endfunction
                            
    1              0.000001 function! coc#util#diagnostic_info(bufnr, checkInsert) abort
                              let checked = coc#util#check_refresh(a:bufnr)
                              if !checked
                                return v:null
                              endif
                              if a:checkInsert && mode() =~# '^i'
                                return v:null
                              endif
                              let locationlist = ''
                              let winid = -1
                              for info in getwininfo()
                                if info['bufnr'] == a:bufnr
                                  let winid = info['winid']
                                  let locationlist = get(getloclist(winid, {'title': 1}), 'title', '')
                                  break
                                endif
                              endfor
                              return {
                                  \ 'bufnr': bufnr('%'),
                                  \ 'winid': winid,
                                  \ 'lnum': line('.'),
                                  \ 'locationlist': locationlist
                                  \ }
                            endfunction
                            
    1              0.000001 function! coc#util#open_file(cmd, file)
                              let file = fnameescape(a:file)
                              execute a:cmd .' '.file
                            endfunction
                            
    1              0.000001 function! coc#util#remote_fns(name)
                              let fns = ['init', 'complete', 'should_complete', 'refresh', 'get_startcol', 'on_complete', 'on_enter']
                              let res = []
                              for fn in fns
                                if exists('*coc#source#'.a:name.'#'.fn)
                                  call add(res, fn)
                                endif
                              endfor
                              return res
                            endfunction
                            
    1              0.000001 function! coc#util#job_command()
                              if (has_key(g:, 'coc_node_path'))
                                let node = expand(g:coc_node_path)
                              else
                                let node = $COC_NODE_PATH == '' ? 'node' : $COC_NODE_PATH
                              endif
                              if !executable(node)
                                echohl Error | echom '[coc.nvim] "'.node.'" is not executable, checkout https://nodejs.org/en/download/' | echohl None
                                return
                              endif
                              if !filereadable(s:root.'/build/index.js')
                                if isdirectory(s:root.'/src')
                                  echohl Error | echom '[coc.nvim] build/index.js not found, please install dependencies and compile coc.nvim by: yarn install' | echohl None
                                else
                                  echohl Error | echon '[coc.nvim] your coc.nvim is broken.' | echohl None
                                endif
                                return
                              endif
                              return [node] + get(g:, 'coc_node_args', ['--no-warnings']) + [s:root.'/build/index.js']
                            endfunction
                            
    1              0.000001 function! coc#util#echo_hover(msg)
                              echohl MoreMsg
                              echo a:msg
                              echohl None
                              let g:coc_last_hover_message = a:msg
                            endfunction
                            
    1              0.000001 function! coc#util#jump(cmd, filepath, ...) abort
                              if a:cmd != 'pedit'
                                silent! normal! m'
                              endif
                              let path = a:filepath
                              if (has('win32unix'))
                                let path = substitute(a:filepath, '\v\\', '/', 'g')
                              endif
                              let file = fnamemodify(path, ":~:.")
                              if a:cmd == 'pedit'
                                let extra = empty(get(a:, 1, [])) ? '' : '+'.(a:1[0] + 1)
                                exe 'pedit '.extra.' '.fnameescape(file)
                                return
                              elseif a:cmd == 'drop' && exists('*bufadd')
                                let dstbuf = bufadd(path)
                                let binfo = getbufinfo(dstbuf)
                                if len(binfo) == 1 && empty(binfo[0].windows)
                                  exec 'buffer '.dstbuf
                                  let &buflisted = 1
                                else
                                  exec 'drop '.fnameescape(file)
                                endif
                              elseif a:cmd == 'edit'
                                if bufloaded(file)
                                  exe 'b '.bufnr(file)
                                else
                                  exe a:cmd.' '.fnameescape(file)
                                endif
                              else
                                exe a:cmd.' '.fnameescape(file)
                              endif
                              if !empty(get(a:, 1, []))
                                let line = getline(a:1[0] + 1)
                                " TODO need to use utf16 here
                                let col = byteidx(line, a:1[1]) + 1
                                if col == 0
                                  let col = 999
                                endif
                                call cursor(a:1[0] + 1, col)
                              endif
                              if &filetype ==# ''
                                filetype detect
                              endif
                              if s:is_vim
                                redraw
                              endif
                            endfunction
                            
    1              0.000001 function! coc#util#echo_messages(hl, msgs)
                              if a:hl !~# 'Error' && (mode() !~# '\v^(i|n)$')
                                return
                              endif
                              let msgs = filter(copy(a:msgs), '!empty(v:val)')
                              if empty(msgs)
                                return
                              endif
                              execute 'echohl '.a:hl
                              echom a:msgs[0]
                              redraw
                              echo join(msgs, "\n")
                              echohl None
                            endfunction
                            
    1              0.000001 function! coc#util#echo_lines(lines)
                              echo join(a:lines, "\n")
                            endfunction
                            
    1              0.000001 function! coc#util#timer(method, args)
                              call timer_start(0, { -> s:Call(a:method, a:args)})
                            endfunction
                            
    1              0.000001 function! s:Call(method, args)
                              try
                                call call(a:method, a:args)
                                redraw
                              catch /.*/
                                return 0
                              endtry
                            endfunction
                            
    1              0.000001 function! coc#util#get_bufoptions(bufnr, maxFileSize) abort
                              if !bufloaded(a:bufnr) | return v:null | endif
                              let bufname = bufname(a:bufnr)
                              let buftype = getbufvar(a:bufnr, '&buftype')
                              let winid = bufwinid(a:bufnr)
                              let size = -1
                              if bufnr('%') == a:bufnr
                                let size = line2byte(line("$") + 1)
                              elseif !empty(bufname)
                                let size = getfsize(bufname)
                              endif
                              let lines = []
                              if getbufvar(a:bufnr, 'coc_enabled', 1) && (buftype == '' || buftype == 'acwrite') && size < a:maxFileSize
                                let lines = getbufline(a:bufnr, 1, '$')
                              endif
                              return {
                                    \ 'bufname': bufname,
                                    \ 'size': size,
                                    \ 'buftype': buftype,
                                    \ 'winid': winid,
                                    \ 'previewwindow': v:false,
                                    \ 'variables': s:variables(a:bufnr),
                                    \ 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'),
                                    \ 'eol': getbufvar(a:bufnr, '&eol'),
                                    \ 'filetype': getbufvar(a:bufnr, '&filetype'),
                                    \ 'iskeyword': getbufvar(a:bufnr, '&iskeyword'),
                                    \ 'changedtick': getbufvar(a:bufnr, 'changedtick'),
                                    \ 'lines': lines,
                                    \}
                            endfunction
                            
    1              0.000001 function! s:variables(bufnr) abort
                              let info = getbufinfo(a:bufnr)
                              let variables = empty(info) ? {} : copy(info[0]['variables'])
                              for key in keys(variables)
                                if key !~# '\v^coc'
                                  unlet variables[key]
                                endif
                              endfor
                              return variables
                            endfunction
                            
    1              0.000001 function! coc#util#root_patterns() abort
                              return coc#rpc#request('rootPatterns', [bufnr('%')])
                            endfunction
                            
    1              0.000001 function! coc#util#get_config(key) abort
                              return coc#rpc#request('getConfig', [a:key])
                            endfunction
                            
    1              0.000001 function! coc#util#preview_info(info, filetype, ...) abort
                              pclose
                              keepalt new +setlocal\ previewwindow|setlocal\ buftype=nofile|setlocal\ noswapfile|setlocal\ wrap [Document]
                              setl bufhidden=wipe
                              setl nobuflisted
                              setl nospell
                              exe 'setl filetype='.a:filetype
                              setl conceallevel=0
                              setl nofoldenable
                              for command in a:000
                                execute command
                              endfor
                              let lines = a:info
                              call append(0, lines)
                              exe "normal! z" . len(lines) . "\<cr>"
                              exe "normal! gg"
                              wincmd p
                            endfunction
                            
    1              0.000001 function! coc#util#get_config_home()
                              if !empty(get(g:, 'coc_config_home', ''))
                                  return resolve(expand(g:coc_config_home))
                              endif
                              if exists('$VIMCONFIG')
                                return resolve($VIMCONFIG)
                              endif
                              if has('nvim')
                                if exists('$XDG_CONFIG_HOME')
                                  return resolve($XDG_CONFIG_HOME."/nvim")
                                endif
                                if s:is_win
                                  return resolve($HOME.'/AppData/Local/nvim')
                                endif
                                return resolve($HOME.'/.config/nvim')
                              else
                                if s:is_win
                                  return resolve($HOME."/vimfiles")
                                endif
                                return resolve($HOME.'/.vim')
                              endif
                            endfunction
                            
    1              0.000001 function! coc#util#get_data_home()
                              if !empty(get(g:, 'coc_data_home', ''))
                                let dir = resolve(expand(g:coc_data_home))
                              else
                                if exists('$XDG_CONFIG_HOME')
                                  let dir = resolve($XDG_CONFIG_HOME."/coc")
                                else
                                  if s:is_win
                                    let dir = resolve(expand('~/AppData/Local/coc'))
                                  else
                                    let dir = resolve(expand('~/.config/coc'))
                                  endif
                                endif
                              endif
                              if !isdirectory(dir)
                                echohl MoreMsg | echom '[coc.nvim] creating data directory: '.dir | echohl None
                                call mkdir(dir, "p", 0755)
                              endif
                              return dir
                            endfunction
                            
    1              0.000001 function! coc#util#get_input()
                              let before = strpart(getline('.'), 0, col('.')-1)
                              if len(before) == 0
                                return ''
                              endif
                              return matchstr(before, '\k*$')
                            endfunction
                            
    1              0.000001 function! coc#util#get_complete_option()
                              if get(b:,"coc_suggest_disable",0)
                                return v:null
                              endif
                              let pos = getcurpos()
                              let line = getline(pos[1])
                              let input = matchstr(strpart(line, 0, pos[2] - 1), '\k*$')
                              let col = pos[2] - strlen(input)
                              let synname = synIDattr(synID(pos[1], col, 1), 'name')
                              return {
                                    \ 'word': matchstr(strpart(line, col - 1), '^\k\+'),
                                    \ 'input': empty(input) ? '' : input,
                                    \ 'line': line,
                                    \ 'filetype': &filetype,
                                    \ 'filepath': expand('%:p'),
                                    \ 'bufnr': bufnr('%'),
                                    \ 'linenr': pos[1],
                                    \ 'colnr' : pos[2],
                                    \ 'col': col - 1,
                                    \ 'synname': synname,
                                    \ 'changedtick': b:changedtick,
                                    \ 'blacklist': get(b:, 'coc_suggest_blacklist', []),
                                    \ 'disabled': get(b:, 'coc_disabled_sources', []),
                                    \ 'indentkeys': coc#util#get_indentkeys()
                                    \}
                            endfunction
                            
    1              0.000001 function! coc#util#with_callback(method, args, cb)
                              function! s:Cb() closure
                                try
                                  let res = call(a:method, a:args)
                                  call a:cb(v:null, res)
                                catch /.*/
                                  call a:cb(v:exception)
                                endtry
                              endfunction
                              let timeout = s:is_vim ? 10 : 0
                              call timer_start(timeout, {-> s:Cb() })
                            endfunction
                            
    1              0.000001 function! coc#util#quickpick(title, items, cb) abort
                              if exists('*popup_menu')
                                function! s:QuickpickHandler(id, result) closure
                                  call a:cb(v:null, a:result)
                                endfunction
                                function! s:QuickpickFilter(id, key) closure
                                  for i in range(1, len(a:items))
                                    if a:key == string(i)
                                      call popup_close(a:id, i)
                                      return 1
                                    endif
                                  endfor
                                  " No shortcut, pass to generic filter
                                  return popup_filter_menu(a:id, a:key)
                                endfunction
                                try
                                  call popup_menu(a:items, {
                                    \ 'title': a:title,
                                    \ 'filter': function('s:QuickpickFilter'),
                                    \ 'callback': function('s:QuickpickHandler'),
                                    \ })
                                  redraw
                                catch /.*/
                                  call a:cb(v:exception)
                                endtry
                              else
                                let res = inputlist([a:title] + a:items)
                                call a:cb(v:null, res)
                              endif
                            endfunction
                            
    1              0.000001 function! coc#util#echo_signatures(signatures) abort
                              if pumvisible() | return | endif
                              echo ""
                              for i in range(len(a:signatures))
                                call s:echo_signature(a:signatures[i])
                                if i != len(a:signatures) - 1
                                  echon "\n"
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! s:echo_signature(parts)
                              for part in a:parts
                                let hl = get(part, 'type', 'Normal')
                                let text = get(part, 'text', '')
                                if !empty(text)
                                  execute 'echohl '.hl
                                  execute "echon '".substitute(text, "'", "''", 'g')."'"
                                  echohl None
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! coc#util#setline(lnum, line)
                              keepjumps call setline(a:lnum, a:line)
                            endfunction
                            
                            " cmd, cwd
    1              0.000001 function! coc#util#open_terminal(opts) abort
                              if s:is_vim && !exists('*term_start')
                                echohl WarningMsg | echon "Your vim doesn't have terminal support!" | echohl None
                                return
                              endif
                              if get(a:opts, 'position', 'bottom') ==# 'bottom'
                                let p = '5new'
                              else
                                let p = 'vnew'
                              endif
                              execute 'belowright '.p.' +setl\ buftype=nofile '
                              setl buftype=nofile
                              setl winfixheight
                              setl norelativenumber
                              setl nonumber
                              setl bufhidden=wipe
                              if exists('#User#CocTerminalOpen')
                                exe 'doautocmd <nomodeline> User CocTerminalOpen'
                              endif
                              let cmd = get(a:opts, 'cmd', '')
                              let autoclose = get(a:opts, 'autoclose', 1)
                              if empty(cmd)
                                throw 'command required!'
                              endif
                              let cwd = get(a:opts, 'cwd', getcwd())
                              let keepfocus = get(a:opts, 'keepfocus', 0)
                              let bufnr = bufnr('%')
                              let Callback = get(a:opts, 'Callback', v:null)
                            
                              function! s:OnExit(status) closure
                                let content = join(getbufline(bufnr, 1, '$'), "\n")
                                if a:status == 0 && autoclose == 1
                                  execute 'silent! bd! '.bufnr
                                endif
                                if !empty(Callback)
                                  call call(Callback, [a:status, bufnr, content])
                                endif
                              endfunction
                            
                              if has('nvim')
                                call termopen(cmd, {
                                      \ 'cwd': cwd,
                                      \ 'on_exit': {job, status -> s:OnExit(status)},
                                      \})
                              else
                                if s:is_win
                                  let cmd = 'cmd.exe /C "'.cmd.'"'
                                endif
                                call term_start(cmd, {
                                      \ 'cwd': cwd,
                                      \ 'exit_cb': {job, status -> s:OnExit(status)},
                                      \ 'curwin': 1,
                                      \})
                              endif
                              if keepfocus
                                wincmd p
                              endif
                              return bufnr
                            endfunction
                            
                            " run command in terminal
    1              0.000001 function! coc#util#run_terminal(opts, cb)
                              let cmd = get(a:opts, 'cmd', '')
                              if empty(cmd)
                                return a:cb('command required for terminal')
                              endif
                              let opts = {
                                    \ 'cmd': cmd,
                                    \ 'cwd': get(a:opts, 'cwd', getcwd()),
                                    \ 'keepfocus': get(a:opts, 'keepfocus', 0),
                                    \ 'Callback': {status, bufnr, content -> a:cb(v:null, {'success': status == 0 ? v:true : v:false, 'bufnr': bufnr, 'content': content})}
                                    \}
                              call coc#util#open_terminal(opts)
                            endfunction
                            
    1              0.000001 function! coc#util#getpid()
                              if !has('win32unix')
                                return getpid()
                              endif
                              let cmd = 'cat /proc/' . getpid() . '/winpid'
                              return substitute(system(cmd), '\v\n', '', 'gi')
                            endfunction
                            
    1              0.000001 function! coc#util#vim_info()
                              return {
                                    \ 'apiversion': s:vim_api_version,
                                    \ 'mode': mode(),
                                    \ 'floating': has('nvim') && exists('*nvim_open_win') ? v:true : v:false,
                                    \ 'extensionRoot': coc#util#extension_root(),
                                    \ 'globalExtensions': get(g:, 'coc_global_extensions', []),
                                    \ 'config': get(g:, 'coc_user_config', {}),
                                    \ 'pid': coc#util#getpid(),
                                    \ 'columns': &columns,
                                    \ 'lines': &lines,
                                    \ 'cmdheight': &cmdheight,
                                    \ 'filetypeMap': get(g:, 'coc_filetype_map', {}),
                                    \ 'version': coc#util#version(),
                                    \ 'completeOpt': &completeopt,
                                    \ 'pumevent': exists('##MenuPopupChanged') || exists('##CompleteChanged'),
                                    \ 'isVim': has('nvim') ? v:false : v:true,
                                    \ 'isCygwin': has('win32unix') ? v:true : v:false,
                                    \ 'isMacvim': has('gui_macvim') ? v:true : v:false,
                                    \ 'isiTerm': $TERM_PROGRAM ==# "iTerm.app",
                                    \ 'colorscheme': get(g:, 'colors_name', ''),
                                    \ 'workspaceFolders': get(g:, 'WorkspaceFolders', v:null),
                                    \ 'background': &background,
                                    \ 'runtimepath': join(globpath(&runtimepath, '', 0, 1), ','),
                                    \ 'locationlist': get(g:,'coc_enable_locationlist', 1),
                                    \ 'progpath': v:progpath,
                                    \ 'guicursor': &guicursor,
                                    \ 'updateHighlight': has('nvim-0.5.0') || has('patch-8.1.1719') ? v:true : v:false,
                                    \ 'vimCommands': get(g:, 'coc_vim_commands', []),
                                    \ 'sign': exists('*sign_place') && exists('*sign_unplace'),
                                    \ 'textprop': has('textprop') && has('patch-8.1.1719') && !has('nvim') ? v:true : v:false,
                                    \ 'dialog': has('nvim-0.4.0') || has('patch-8.2.0750') ? v:true : v:false,
                                    \ 'semanticHighlights': coc#util#semantic_hlgroups()
                                    \}
                            endfunction
                            
    1              0.000001 function! coc#util#highlight_options()
                              return {
                                    \ 'colorscheme': get(g:, 'colors_name', ''),
                                    \ 'background': &background,
                                    \ 'runtimepath': join(globpath(&runtimepath, '', 0, 1), ','),
                                    \}
                            endfunction
                            
    1              0.000002 function! coc#util#set_lines(bufnr, changedtick, original, replacement, start, end, changes) abort
                              if !bufloaded(a:bufnr)
                                return
                              endif
                              if getbufvar(a:bufnr, 'changedtick') != a:changedtick && bufnr('%') == a:bufnr
                                " try apply current line change
                                let lnum = line('.')
                                let idx = a:start - lnum + 1
                                let previous = get(a:original, idx, 0)
                                if type(previous) == 1
                                  let content = getline('.')
                                  if previous !=# content
                                    let diff = coc#helper#str_diff(content, previous, col('.'))
                                    let changed = get(a:replacement, idx, 0)
                                    if type(changed) == 1 && strcharpart(previous, 0, diff['end']) ==# strcharpart(changed, 0, diff['end'])
                                      let applied = coc#helper#str_apply(changed, diff)
                                      let replacement = copy(a:replacement)
                                      let replacement[idx] = applied
                                      call coc#compat#buf_set_lines(a:bufnr, a:start, a:end, replacement)
                                      return
                                    endif
                                  endif
                                endif
                              endif
                              if exists('*nvim_buf_set_text') && !empty(a:changes)
                                for item in a:changes
                                  let lines = nvim_buf_get_lines(a:bufnr, 0, -1, v:false)
                                  call nvim_buf_set_text(a:bufnr, item[1], item[2], item[3], item[4], item[0])
                                endfor
                              else
                                call coc#compat#buf_set_lines(a:bufnr, a:start, a:end, a:replacement)
                              endif
                            endfunction
                            
    1              0.000001 function! coc#util#change_lines(bufnr, list) abort
                              if !bufloaded(a:bufnr) | return v:null | endif
                              undojoin
                              if exists('*setbufline')
                                for [lnum, line] in a:list
                                  call setbufline(a:bufnr, lnum + 1, line)
                                endfor
                              elseif a:bufnr == bufnr('%')
                                for [lnum, line] in a:list
                                  call setline(lnum + 1, line)
                                endfor
                              else
                                let bufnr = bufnr('%')
                                exe 'noa buffer '.a:bufnr
                                for [lnum, line] in a:list
                                  call setline(lnum + 1, line)
                                endfor
                                exe 'noa buffer '.bufnr
                              endif
                            endfunction
                            
                            
                            " used by vim
    1              0.000001 function! coc#util#get_buf_lines(bufnr, changedtick)
                              if !bufloaded(a:bufnr)
                                return v:null
                              endif
                              let changedtick = getbufvar(a:bufnr, 'changedtick')
                              if changedtick == a:changedtick
                                return v:null
                              endif
                              return {
                                    \ 'lines': getbufline(a:bufnr, 1, '$'),
                                    \ 'changedtick': getbufvar(a:bufnr, 'changedtick')
                                    \ }
                            endfunction
                            
                            " used for TextChangedI with InsertCharPre
    1              0.000001 function! coc#util#get_changeinfo()
                              return {
                                    \ 'bufnr': bufnr('%'),
                                    \ 'lnum': line('.'),
                                    \ 'line': getline('.'),
                                    \ 'changedtick': b:changedtick,
                                    \}
                            endfunction
                            
    1              0.000001 function! coc#util#open_url(url)
                              if has('mac') && executable('open')
                                call system('open '.a:url)
                                return
                              endif
                              if executable('xdg-open')
                                call system('xdg-open '.a:url)
                                return
                              endif
                              call system('cmd /c start "" /b '. substitute(a:url, '&', '^&', 'g'))
                              if v:shell_error
                                echohl Error | echom 'Failed to open '.a:url | echohl None
                                return
                              endif
                            endfunction
                            
    1              0.000001 function! coc#util#install() abort
                              let yarncmd = get(g:, 'coc_install_yarn_cmd', executable('yarnpkg') ? 'yarnpkg' : 'yarn')
                              call coc#util#open_terminal({
                                    \ 'cwd': s:root,
                                    \ 'cmd': yarncmd.' install --frozen-lockfile --ignore-engines',
                                    \ 'autoclose': 0,
                                    \ })
                            endfunction
                            
    1              0.000001 function! coc#util#do_complete(name, opt, cb) abort
                              let handler = 'coc#source#'.a:name.'#complete'
                              let l:Cb = {res -> a:cb(v:null, res)}
                              let args = [a:opt, l:Cb]
                              call call(handler, args)
                            endfunction
                            
    1              0.000001 function! coc#util#extension_root() abort
                              if get(g:, 'coc_node_env', '') ==# 'test'
                                return s:root.'/src/__tests__/extensions'
                              endif
                              if !empty(get(g:, 'coc_extension_root', ''))
                                echohl Error | echon 'g:coc_extension_root not used any more, use g:coc_data_home instead' | echohl None
                              endif
                              return coc#util#get_data_home().'/extensions'
                            endfunction
                            
    1              0.000001 function! coc#util#update_extensions(...) abort
                              let async = get(a:, 1, 0)
                              if async
                                call coc#rpc#notify('updateExtensions', [])
                              else
                                call coc#rpc#request('updateExtensions', [v:true])
                              endif
                            endfunction
                            
    1              0.000001 function! coc#util#install_extension(args) abort
                              let names = filter(copy(a:args), 'v:val !~# "^-"')
                              let isRequest = index(a:args, '-sync') != -1
                              if isRequest
                                call coc#rpc#request('installExtensions', names)
                              else
                                call coc#rpc#notify('installExtensions', names)
                              endif
                            endfunction
                            
    1              0.000001 function! coc#util#do_autocmd(name) abort
                              if exists('#User#'.a:name)
                                exe 'doautocmd <nomodeline> User '.a:name
                              endif
                            endfunction
                            
    1              0.000001 function! coc#util#rebuild()
                              let dir = coc#util#extension_root()
                              if !isdirectory(dir) | return | endif
                              call coc#util#open_terminal({
                                    \ 'cwd': dir,
                                    \ 'cmd': 'npm rebuild',
                                    \ 'keepfocus': 1,
                                    \})
                            endfunction
                            
                            " [r, g, b] ['255', '255', '255']
                            " return ['65535', '65535', '65535'] or return v:false to cancel
    1              0.000001 function! coc#util#pick_color(default_color)
                              if has('mac')
                                let default_color = map(a:default_color, {idx, val -> str2nr(val) * 65535 / 255 })
                                " This is the AppleScript magic:
                                let s:ascrpt = ['-e "tell application \"' . s:app . '\""',
                                      \ '-e "' . s:activate . '"',
                                      \ "-e \"set AppleScript's text item delimiters to {\\\",\\\"}\"",
                                      \ '-e "set theColor to (choose color default color {' . default_color[0] . ", " . default_color[1] . ", " . default_color[2] . '}) as text"',
                                      \ '-e "' . s:quit . '"',
                                      \ '-e "end tell"',
                                      \ '-e "return theColor"']
                                let res = trim(system("osascript " . join(s:ascrpt, ' ') . " 2>/dev/null"))
                                if empty(res)
                                  return v:false
                                else
                                  return split(trim(res), ',')
                                endif
                              endif
                            
                              let hex_color = printf('#%02x%02x%02x', a:default_color[0], a:default_color[1], a:default_color[2])
                            
                              if has('unix')
                                if executable('zenity')
                                  let res = trim(system('zenity --title="Select a color" --color-selection --color="' . hex_color . '" 2> /dev/null'))
                                  if empty(res)
                                    return v:false
                                  else
                                    " res format is rgb(255,255,255)
                                    return map(split(res[4:-2], ','), {idx, val -> string(str2nr(trim(val)) * 65535 / 255)})
                                  endif
                                endif
                              endif
                            
                              let rgb = v:false
                              if !has('python')
                                echohl Error | echom 'python support required, checkout :echo has(''python'')' | echohl None
                                return
                              endif
                              try
                                execute 'py import gtk'
                              catch /.*/
                                echohl Error | echom 'python gtk module not found' | echohl None
                                return
                              endtry
                            python << endpython
                            
                            import vim
                            import gtk, sys
                            
                            # message strings
                            wnd_title_insert = "Insert a color"
                            
                            csd = gtk.ColorSelectionDialog(wnd_title_insert)
                            cs = csd.colorsel
                            
                            cs.set_current_color(gtk.gdk.color_parse(vim.eval("hex_color")))
                            
                            cs.set_current_alpha(65535)
                            cs.set_has_opacity_control(False)
                            # cs.set_has_palette(int(vim.eval("s:display_palette")))
                            
                            if csd.run()==gtk.RESPONSE_OK:
                                c = cs.get_current_color()
                                s = [str(int(c.red)),',',str(int(c.green)),',',str(int(c.blue))]
                                thecolor = ''.join(s)
                                vim.command(":let rgb = split('%s',',')" % thecolor)
                            
                            csd.destroy()
                            
                            endpython
                              return rgb
                            endfunction
                            
    1              0.000001 function! coc#util#iterm_open(dir)
                              return s:osascript(
                                  \ 'if application "iTerm2" is not running',
                                  \   'error',
                                  \ 'end if') && s:osascript(
                                  \ 'tell application "iTerm2"',
                                  \   'tell current window',
                                  \     'create tab with default profile',
                                  \     'tell current session',
                                  \       'write text "cd ' . a:dir . '"',
                                  \       'write text "clear"',
                                  \       'activate',
                                  \     'end tell',
                                  \   'end tell',
                                  \ 'end tell')
                            endfunction
                            
    1              0.000001 function! s:osascript(...) abort
                              let args = join(map(copy(a:000), '" -e ".shellescape(v:val)'), '')
                              call  s:system('osascript'. args)
                              return !v:shell_error
                            endfunction
                            
    1              0.000001 function! s:system(cmd)
                              let output = system(a:cmd)
                              if v:shell_error && output !=# ""
                                echohl Error | echom output | echohl None
                                return
                              endif
                              return output
                            endfunction
                            
    1              0.000001 function! coc#util#unmap(bufnr, keys) abort
                              if bufnr('%') == a:bufnr
                                for key in a:keys
                                  exe 'silent! nunmap <buffer> '.key
                                endfor
                              endif
                            endfunction
                            
    1              0.000001 function! coc#util#open_files(files)
                              let bufnrs = []
                              " added on latest vim8
                              if exists('*bufadd') && exists('*bufload')
                                for file in a:files
                                  let file = fnamemodify(file, ':.')
                                  if bufloaded(file)
                                    call add(bufnrs, bufnr(file))
                                  else
                                    let bufnr = bufadd(file)
                                    call bufload(file)
                                    call add(bufnrs, bufnr)
                                    call setbufvar(bufnr, '&buflisted', 1)
                                  endif
                                endfor
                              else
                                noa keepalt 1new +setl\ bufhidden=wipe
                                for file in a:files
                                  let file = fnamemodify(file, ':.')
                                  execute 'noa edit +setl\ bufhidden=hide '.fnameescape(file)
                                  if &filetype ==# ''
                                    filetype detect
                                  endif
                                  call add(bufnrs, bufnr('%'))
                                endfor
                                noa close
                              endif
                              doautocmd BufEnter
                              return bufnrs
                            endfunction
                            
    1              0.000001 function! coc#util#refactor_foldlevel(lnum) abort
                              if a:lnum <= 2 | return 0 | endif
                              let line = getline(a:lnum)
                              if line =~# '^\%u3000\s*$' | return 0 | endif
                              return 1
                            endfunction
                            
    1              0.000001 function! coc#util#refactor_fold_text(lnum) abort
                              let range = ''
                              let info = get(b:line_infos, a:lnum, [])
                              if !empty(info)
                                let range = info[0].':'.info[1]
                              endif
                              return trim(getline(a:lnum)[3:]).' '.range
                            endfunction
                            
                            " get tabsize & expandtab option
    1              0.000001 function! coc#util#get_format_opts(bufnr) abort
                              let bufnr = a:bufnr && bufloaded(a:bufnr) ? a:bufnr : bufnr('%')
                              let tabsize = getbufvar(bufnr, '&shiftwidth')
                              if tabsize == 0
                                let tabsize = getbufvar(bufnr, '&tabstop')
                              endif
                              return {
                                  \ 'tabsize': tabsize,
                                  \ 'expandtab': getbufvar(bufnr, '&expandtab'),
                                  \ 'insertFinalNewline': getbufvar(bufnr, '&eol'),
                                  \ 'trimTrailingWhitespace': getbufvar(bufnr, 'coc_trim_trailing_whitespace', 0),
                                  \ 'trimFinalNewlines': getbufvar(bufnr, 'coc_trim_final_newlines', 0)
                                  \ }
                            endfunction
                            
                            " Get indentkeys for indent on TextChangedP, consider = for word indent only.
    1              0.000001 function! coc#util#get_indentkeys() abort
                              if empty(&indentexpr)
                                return ''
                              endif
                              if &indentkeys !~# '='
                                return ''
                              endif
                              return &indentkeys
                            endfunction

SCRIPT  /home/tony/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/client.vim
Sourced 1 time
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
    1              0.000002 scriptencoding utf-8
    1              0.000003 let s:root = expand('<sfile>:h:h:h')
    1              0.000003 let s:is_vim = !has('nvim')
    1              0.000003 let s:is_win = has("win32") || has("win64")
    1              0.000001 let s:clients = {}
                            
    1              0.000002 if get(g:, 'node_client_debug', 0)
                              echohl WarningMsg | echon '[coc.nvim] Enable g:node_client_debug could impact your vim experience' | echohl None
                              let $NODE_CLIENT_LOG_LEVEL = 'debug'
                              if exists('$NODE_CLIENT_LOG_FILE')
                                let s:logfile = resolve($NODE_CLIENT_LOG_FILE)
                              else
                                let s:logfile = tempname()
                                let $NODE_CLIENT_LOG_FILE = s:logfile
                              endif
    1              0.000000 endif
                            
                            " create a client
    1              0.000002 function! coc#client#create(name, command)
                              let client = {}
                              let client['command'] = a:command
                              let client['name'] = a:name
                              let client['running'] = 0
                              let client['async_req_id'] = 1
                              let client['async_callbacks'] = {}
                              " vim only
                              let client['channel'] = v:null
                              " neovim only
                              let client['chan_id'] = 0
                              let client['start'] = function('s:start', [], client)
                              let client['request'] = function('s:request', [], client)
                              let client['notify'] = function('s:notify', [], client)
                              let client['request_async'] = function('s:request_async', [], client)
                              let client['on_async_response'] = function('s:on_async_response', [], client)
                              let s:clients[a:name] = client
                              return client
                            endfunction
                            
    1              0.000001 function! s:start() dict
                              if self.running | return | endif
                              if !isdirectory(getcwd())
                                echohl Error | echon '[coc.nvim] Current cwd is not a valid directory.' | echohl None
                                return
                              endif
                              let timeout = string(get(g:, 'coc_channel_timeout', 30))
                              let disable_warning = string(get(g:, 'coc_disable_startup_warning', 0))
                              let tmpdir = fnamemodify(tempname(), ':p:h')
                              if s:is_vim
                                let options = {
                                      \ 'in_mode': 'json',
                                      \ 'out_mode': 'json',
                                      \ 'err_mode': 'nl',
                                      \ 'err_cb': {channel, message -> s:on_stderr(self.name, split(message, "\n"))},
                                      \ 'exit_cb': {channel, code -> s:on_exit(self.name, code)},
                                      \ 'env': {
                                        \ 'NODE_NO_WARNINGS': '1',
                                        \ 'VIM_NODE_RPC': '1',
                                        \ 'COC_NVIM': '1',
                                        \ 'COC_CHANNEL_TIMEOUT': timeout,
                                        \ 'TMPDIR': tmpdir,
                                      \ }
                                      \}
                                if has("patch-8.1.350")
                                  let options['noblock'] = 1
                                endif
                                let job = job_start(self.command, options)
                                let status = job_status(job)
                                if status !=# 'run'
                                  let self.running = 0
                                  echohl Error | echom 'Failed to start '.self.name.' service' | echohl None
                                  return
                                endif
                                let self['running'] = 1
                                let self['channel'] = job_getchannel(job)
                              else
                                let original = {}
                                let opts = {
                                      \ 'rpc': 1,
                                      \ 'on_stderr': {channel, msgs -> s:on_stderr(self.name, msgs)},
                                      \ 'on_exit': {channel, code -> s:on_exit(self.name, code)},
                                      \ }
                                if has('nvim-0.5.0')
                                  " could use env option
                                  let opts['env'] = {
                                      \ 'NODE_NO_WARNINGS': '1',
                                      \ 'COC_CHANNEL_TIMEOUT': timeout,
                                      \ 'TMPDIR': tmpdir
                                      \ }
                                else
                                  let original = {
                                        \ 'NODE_NO_WARNINGS': getenv('NODE_NO_WARNINGS'),
                                        \ 'TMPDIR': getenv('TMPDIR'),
                                        \ }
                                  if exists('*setenv')
                                    call setenv('NODE_NO_WARNINGS', '1')
                                    call setenv('COC_CHANNEL_TIMEOUT', timeout)
                                    call setenv('TMPDIR', tmpdir)
                                  else
                                    let $NODE_NO_WARNINGS = 1
                                    let $TMPDIR = tmpdir
                                  endif
                                endif
                                let chan_id = jobstart(self.command, opts)
                                if !empty(original)
                                  if exists('*setenv')
                                    for key in keys(original)
                                      call setenv(key, original[key])
                                    endfor
                                  else
                                    let $TMPDIR = original['TMPDIR']
                                  endif
                                endif
                                if chan_id <= 0
                                  echohl Error | echom 'Failed to start '.self.name.' service' | echohl None
                                  return
                                endif
                                let self['chan_id'] = chan_id
                                let self['running'] = 1
                              endif
                            endfunction
                            
    1              0.000001 function! s:on_stderr(name, msgs)
                              if get(g:, 'coc_vim_leaving', 0) | return | endif
                              if get(g:, 'coc_disable_uncaught_error', 0) | return | endif
                              let data = filter(copy(a:msgs), '!empty(v:val)')
                              if empty(data) | return | endif
                              let client = a:name ==# 'coc' ? '[coc.nvim]' : '['.a:name.']'
                              let data[0] = client.': '.data[0]
                              call coc#util#echo_messages('Error', data)
                            endfunction
                            
    1              0.000001 function! s:on_exit(name, code) abort
                              if get(g:, 'coc_vim_leaving', 0) | return | endif
                              let client = get(s:clients, a:name, v:null)
                              if empty(client) | return | endif
                              if client['running'] != 1 | return | endif
                              let client['running'] = 0
                              let client['chan_id'] = 0
                              let client['channel'] = v:null
                              let client['async_req_id'] = 1
                              if a:code != 0 && a:code != 143
                                echohl Error | echom 'client '.a:name. ' abnormal exit with: '.a:code | echohl None
                              endif
                            endfunction
                            
    1              0.000001 function! coc#client#get_client(name) abort
                              return get(s:clients, a:name, v:null)
                            endfunction
                            
    1              0.000001 function! coc#client#get_channel(client)
                              if s:is_vim
                                return a:client['channel']
                              endif
                              return a:client['chan_id']
                            endfunction
                            
    1              0.000001 function! s:request(method, args) dict
                              let channel = coc#client#get_channel(self)
                              if empty(channel) | return '' | endif
                              try
                                if s:is_vim
                                  let res = ch_evalexpr(channel, [a:method, a:args], {'timeout': 60 * 1000})
                                  if type(res) == 1 && res ==# ''
                                    throw 'request '.a:method. ' '.string(a:args).' timeout after 60s'
                                  endif
                                  let [l:errmsg, res] =  res
                                  if !empty(l:errmsg)
                                    throw l:errmsg
                                  else
                                    return res
                                  endif
                                else
                                  return call('rpcrequest', [channel, a:method] + a:args)
                                endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on request ('.a:method.'): '.v:exception | echohl None
                                endif
                              endtry
                            endfunction
                            
    1              0.000001 function! s:notify(method, args) dict
                              let channel = coc#client#get_channel(self)
                              if empty(channel)
                                return ''
                              endif
                              try
                                if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
                                else
                                  call call('rpcnotify', [channel, a:method] + a:args)
                                endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
                              endtry
                            endfunction
                            
    1              0.000001 function! s:request_async(method, args, cb) dict
                              let channel = coc#client#get_channel(self)
                              if empty(channel) | return '' | endif
                              if type(a:cb) != 2
                                echohl Error | echom '['.self['name'].'] Callback should be function' | echohl None
                                return
                              endif
                              let id = self.async_req_id
                              let self.async_req_id = id + 1
                              let self.async_callbacks[id] = a:cb
                              call self['notify']('nvim_async_request_event', [id, a:method, a:args])
                            endfunction
                            
    1              0.000001 function! s:on_async_response(id, resp, isErr) dict
                              let Callback = get(self.async_callbacks, a:id, v:null)
                              if empty(Callback)
                                " should not happen
                                echohl Error | echom 'callback not found' | echohl None
                                return
                              endif
                              call remove(self.async_callbacks, a:id)
                              if a:isErr
                                call call(Callback, [a:resp, v:null])
                              else
                                call call(Callback, [v:null, a:resp])
                              endif
                            endfunction
                            
    1              0.000001 function! coc#client#is_running(name) abort
                              let client = get(s:clients, a:name, v:null)
                              if empty(client) | return 0 | endif
                              if !client['running'] | return 0 | endif
                              if s:is_vim
                                let status = job_status(ch_getjob(client['channel']))
                                return status ==# 'run'
                              else
                                let chan_id = client['chan_id']
                                let [code] = jobwait([chan_id], 10)
                                return code == -1
                              endif
                            endfunction
                            
    1              0.000002 function! coc#client#stop(name) abort
                              let client = get(s:clients, a:name, v:null)
                              if empty(client) | return 1 | endif
                              let running = coc#client#is_running(a:name)
                              if !running
                                echohl WarningMsg | echom 'client '.a:name. ' not running.' | echohl None
                                return 1
                              endif
                              if s:is_vim
                                call job_stop(ch_getjob(client['channel']), 'term')
                              else
                                call jobstop(client['chan_id'])
                              endif
                              sleep 200m
                              if coc#client#is_running(a:name)
                                echohl Error | echom 'client '.a:name. ' stop failed.' | echohl None
                                return 0
                              endif
                              call s:on_exit(a:name, 0)
                              echohl MoreMsg | echom 'client '.a:name.' stopped!' | echohl None
                              return 1
                            endfunction
                            
    1              0.000001 function! coc#client#request(name, method, args)
                              let client = get(s:clients, a:name, v:null)
                              if !empty(client)
                                return client['request'](a:method, a:args)
                              endif
                            endfunction
                            
    1              0.000001 function! coc#client#notify(name, method, args)
                              let client = get(s:clients, a:name, v:null)
                              if !empty(client)
                                call client['notify'](a:method, a:args)
                              endif
                            endfunction
                            
    1              0.000001 function! coc#client#request_async(name, method, args, cb)
                              let client = get(s:clients, a:name, v:null)
                              if !empty(client)
                                call client['request_async'](a:method, a:args, a:cb)
                              endif
                            endfunction
                            
    1              0.000001 function! coc#client#on_response(name, id, resp, isErr)
                              let client = get(s:clients, a:name, v:null)
                              if !empty(client)
                                call client['on_async_response'](a:id, a:resp, a:isErr)
                              endif
                            endfunction
                            
    1              0.000001 function! coc#client#restart(name) abort
                              let stopped = coc#client#stop(a:name)
                              if !stopped | return | endif
                              let client = get(s:clients, a:name, v:null)
                              if !empty(client)
                                call client['start']()
                              endif
                            endfunction
                            
    1              0.000001 function! coc#client#restart_all()
                              for key in keys(s:clients)
                                call coc#client#restart(key)
                              endfor
                            endfunction
                            
    1              0.000001 function! coc#client#open_log()
                              if !get(g:, 'node_client_debug', 0)
                                echohl Error | echon '[coc.nvim] use let g:node_client_debug = 1 in your vimrc to enabled debug mode.' | echohl None
                                return
                              endif
                              execute 'vs '.s:logfile
                            endfunction

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-snippets/plugin/vimsnippets.vim
Sourced 1 time
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000007 if exists("b:done_vimsnippets")
                               finish
    1              0.000000 endif
    1              0.000003 let b:done_vimsnippets = 1
                            
                            " Some variables need default value
    1              0.000002 if !exists("g:snips_author")
    1              0.000001     let g:snips_author = "yourname"
    1              0.000000 endif
                            
    1              0.000001 if !exists("g:snips_email")
    1              0.000001     let g:snips_email = "yourname@email.com"
    1              0.000000 endif
                            
    1              0.000001 if !exists("g:snips_github")
    1              0.000001     let g:snips_github = "https://github.com/yourname"
    1              0.000000 endif
                            
                            " Expanding the path is not needed on Vim 7.4
    1              0.000007 if &cp || version >= 704
    1              0.000001     finish
                            endif
                            
                            " Add pythonx to the python search path if needed (i.e. <= Vim 7.3).
                            if !has("python") && !has("python3")
                               finish
                            end
                            
                            " This will fail if UltiSnips is not installed.
                            try
                               call UltiSnips#bootstrap#Bootstrap()
                            catch /E117/
                               finish
                            endtry
                            
                            
                            " This should have been set by UltiSnips, otherwise something is wrong.
                            if !exists("g:_uspy")
                               finish
                            end
                            
                            
                            " Expand our path
                            let s:SourcedFile=expand("<sfile>")
                            exec g:_uspy "import vim, os, sys"
                            exec g:_uspy "sourced_file = vim.eval('s:SourcedFile')"
                            exec g:_uspy "while not os.path.exists(os.path.join(sourced_file, 'pythonx')):
                               \ sourced_file = os.path.dirname(sourced_file)"
                            exec g:_uspy "module_path = os.path.join(sourced_file, 'pythonx')"
                            exec g:_uspy "sys.path.append(module_path)"

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-code-runner/plugin/CodeRunner.vim
Sourced 1 time
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
                            " Title:         Vim Code Runner
                            " Author:        Wang Xianzhong   wxz1120339073@gmail.com
                            "
                            " Goal:          Run code snippets more conveniently
                            "
                            " License:       Public domain, no restrictions whatsoever
                            " Documentation: type ":help CodeRunner"
                            "
                            " Version:       1.0
                            
                            " Internals {{{
                            " Script Variables {{{
    1              0.000005 let s:CodeRunnerSourceFile=expand("<sfile>")
                            
    1              0.000002 if !exists("g:code_runner_save_before_execute")
                                let g:code_runner_save_before_execute = 0
    1              0.000001 endif
    1              0.000001 if !exists("g:code_runner_output_window_size")
    1              0.000001     let g:code_runner_output_window_size = 15
    1              0.000000 endif
                            
                            " Common {{{
                            " Echo {{{
    1              0.000004 function! <sid>Echo(message)
                                let str = ""
                                if !s:OptionsExplorerOpen
                                    let str .= "[CodeRunner] "
                                endif
                                let str .= a:message
                                echo str
                            endfunction
                            "}}}
                            " EchoNewline {{{
    1              0.000001 function! <sid>EchoNewline()
                                echo " "
                            endfunction
                            "}}}
                            " Quit {{{
    1              0.000001 function! <sid>Quit()
                                echo ""
                                quit
                            endfunction
                            " }}}
                            " MapOutputWindowKeys {{{
    1              0.000001 function! s:MapOutputWindowKeys()
                                nnoremap <buffer> <silent> :    :call <sid>Echo("Type q to quit")<cr>
                                nnoremap <buffer> <silent> q    :call <sid>Quit()<cr>
                            endfunction
                            " }}}
                            " GetSafePath {{{
    1              0.000001 function! s:GetSafePath(path)
                                " Wrap the path with double quotes if it contains space
                                if stridx(a:path, ' ') == -1
                                    return a:path
                                endif
                                return '"' . a:path . '"'
                            endfunction
                            " }}}
                            " }}} - End of Common
                            
                            " GetCommand {{{
                            
    1              0.000001 function! s:GetCommand(type)abort
                                let cmdMaps = s:ParseCommandAssociationList()
                                if has_key(cmdMaps, a:type)
                                    let strCmd = cmdMaps[a:type]
                                else
                                    return ''
                                endif
                            
                                " Replace path variables
                                let dirPath = s:GetSafePath(expand('%:h') . '/')
                                let fileNameWithoutExt = s:GetSafePath(expand('%:t:r'))
                                let fileName = s:GetSafePath(expand('%:t'))
                            
                                " Change to current directory if not given
                                if strCmd !~ 'cd $dir'
                                    let strCmd = 'cd $dir && ' . strCmd
                                endif
                            
                                let strCmd = substitute(strCmd, '$fileNameWithoutExt', fileNameWithoutExt, 'gC')
                                let strCmd = substitute(strCmd, '$fileName', fileName, 'gC')
                                let strCmd = substitute(strCmd, '$dir', dirPath, 'gC')
                            
                                return strCmd
                            endfunction
                            " }}}
                            
                            " GetCommandConfigFile {{{
    1              0.000001 function! s:GetCommandConfigFile()
                                let sawError = 0
                                if exists("g:code_runner_command_config_file")
                                    if filereadable(g:code_runner_command_config_file)
                                        return g:code_runner_command_config_file
                                    endif
                                    let sawError = 1
                                    call CodeRunner#Error("The file specified by g:code_runner_command_config_file = " .
                                                \ g:code_runner_command_config_file . " cannot be read.")
                                    call CodeRunner#Error("Attempting to look for 'CodeRunnerCommandAssociations' in other locations.")
                                endif
                            
                                let nextToSource = fnamemodify(s:CodeRunnerSourceFile, ":h")."/CodeRunnerCommandAssociations"
                                if filereadable(nextToSource)
                                    let l:CodeRunnerCommandConfigFile = nextToSource
                                else
                                    let VimfilesDirs = split(&runtimepath, ',')
                                    for v in VimfilesDirs
                                        let cfgFilePath = CodeRunner#BackToForwardSlash(v)."/plugin/CodeRunnerCommandAssociations"
                                        if filereadable(cfgFilePath)
                                            let l:CodeRunnerCommandConfigFile = cfgFilePath
                                        endif
                                    endfor
                                endif
                            
                                if empty(l:CodeRunnerCommandConfigFile)
                                    let l:CodeRunnerCommandConfigFile = ""
                                elseif sawError
                                    call CodeRunner#Error("    Found at: ".l:CodeRunnerCommandConfigFile)
                                    call CodeRunner#Error("    Please fix your configuration to suppress these messages!")
                                endif
                                return l:CodeRunnerCommandConfigFile
                            endfunction
                            " }}}
                            " ParseCommandAssociationList {{{
    1              0.000001 function! s:ParseCommandAssociationList()
                                if exists("s:Dict")
                                    return s:Dict
                                endif
                                let s:Dict = {}
                                if exists('g:CodeRunnerCommandMap')
                                    for key in keys(g:CodeRunnerCommandMap)
                                        let s:Dict[key] = CodeRunner#Trim(g:CodeRunnerCommandMap[key])
                                    endfor
                                endif
                                let filePath = s:GetCommandConfigFile()
                            
                                if empty(filePath)
                                    call CodeRunenr#Error("Code Runner Command config file not exists!")
                                    return
                                endif
                            
                                if !filereadable(filePath)
                                    call CodeRunner#Error("Code Runner config file can't be read!")
                                    return
                                endif
                            
                                let strLines = readfile(filePath)
                            
                                let lineCounter = 0
                                for strLine in strLines
                                    let lineCounter += 1
                                    let strLine = CodeRunner#Trim(strLine)
                                    if empty(strLine) || strLine[0] == "\""
                                        continue
                                    endif
                            
                                    let items = split(strLine, "::")
                                    if len(items) != 2
                                        call CodeRunner#Warning("Invalid strLine: ".strLine)
                                        continue
                                    endif
                            
                                    let sourceType = CodeRunner#Trim(items[0])
                                    let exeCommand = CodeRunner#Trim(items[1])
                            
                                    if empty(sourceType) || empty(exeCommand)
                                        call CodeRunner#Warning("Invalid strLine: ".strLine)
                                        continue
                                    endif
                                    if !has_key(s:Dict, sourceType)
                                        let s:Dict[sourceType] = exeCommand
                                    endif
                                endfor
                                if lineCounter == 0
                                    call CodeRunner#Warning("Code Runner config is empty!")
                                    return
                                endif
                            
                                return s:Dict
                            endfunction
                            "}}}
                            " GotoWindowByName {{{
    1              0.000003 function! s:GotoWindowByName(bufname)
                                let bufmap = map(range(1, winnr('$')), '[bufname(winbufnr(v:val)), v:val]')
                            
                                let a = filter(bufmap, 'v:val[0] =~ a:bufname')
                                if len(a) > 0 && len(a[0]) > 1
                                    let thewindow = a[0][1]
                                    execute thewindow 'wincmd w'
                                    return 1
                                endif
                                return 0
                            endfunction
                            "}}}
                            
                            " CodeRunner {{{
    1              0.000001 function! s:CodeRunner()
                                if g:code_runner_save_before_execute == 1
                                    write
                                endif
                                let cmd = s:GetCommand(&ft)
                                if empty(cmd)
                                    call CodeRunner#Error("Unknow File Type: " . &ft . "!")
                                    return
                                endif
                            
                                echom cmd
                                let winName = "CodeRunner.out"
                                let options= {"cwd":getcwd(),"term_rows":g:code_runner_output_window_size, "term_name":winName}
                            
                                if has('nvim')
                                    exec "belowright ".g:code_runner_output_window_size."sp ".winName." | terminal ".cmd
                                else
                                    exec "belowright terminal ++shell ++rows=".g:code_runner_output_window_size." ".cmd
                                endif
                            
                            endfunction
                            " }}}
                            
    1              0.000016 nnoremap <silent> <plug>CodeRunner :call <sid>CodeRunner()<CR>
                            " if !hasmapto("<plug>CodeRunner")
                            "     nmap <silent> <Leader>B <plug>CodeRunner
                            " endif

SCRIPT  /home/tony/.config/nvim/autoload/plugged/codi.vim/plugin/codi.vim
Sourced 1 time
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
                            " User-defined interpreters (see codi-interpreters)
                            " Entries are in the form of:
                            "   <filetype>: {
                            "     'bin': <interpreter binary name, str or array>,
                            "     'prompt': <vim regex pattern indicating the prompt>,
                            "     'preprocess': <optional function to run bin output through
                            "                    before prompt parsing>,
                            "     'rephrase': <optional function to run buffer contents through
                            "                    before handing off to bin>,
                            "   }
                            " For example:
                            "   'javascript': {
                            "       'bin': 'node',
                            "       'prompt': '^\(>\|\.\.\.\+\) ',
                            "       'preprocess': function('s:pp_js'),
                            "       'rephrase': function('s:rp_js'),
                            "    }
    1              0.000009 if !exists('g:codi#interpreters')
    1              0.000004   let g:codi#interpreters = {}
    1              0.000001 endif
                            
    1              0.000001 if !exists('g:codi#command_prefix')
    1              0.000002   let g:codi#command_prefix = ['env' , 'INPUTRC=/dev/null']
    1              0.000000 endif
                            
                            " Interpreter aliases
                            " Entries are in the form of:
                            "   <aliased filetype>: <filetype>
                            " For example:
                            "   'javascript.jsx': 'javascript'
    1              0.000002 if !exists('g:codi#aliases')
                              let g:codi#aliases = {}
    1              0.000000 endif
                            
                            " What autocmds trigger updates
    1              0.000001 if !exists('g:codi#autocmd')
    1              0.000001   let g:codi#autocmd = ''
    1              0.000000 endif
                            
                            " Width of Codi split
    1              0.000001 if !exists('g:codi#width')
    1              0.000001   let g:codi#width = 40
    1              0.000000 endif
                            
                            " Split on right?
    1              0.000001 if !exists('g:codi#rightsplit')
    1              0.000001   let g:codi#rightsplit = 1
    1              0.000000 endif
                            
                            " Right-align?
    1              0.000001 if !exists('g:codi#rightalign')
    1              0.000001   let g:codi#rightalign = 1
    1              0.000000 endif
                            
                            " Close codi on target buffer close?
    1              0.000001 if !exists('g:codi#autoclose')
    1              0.000001   let g:codi#autoclose = 1
    1              0.000000 endif
                            
                            " Disable prompt parsing?
    1              0.000001 if !exists('g:codi#raw')
    1              0.000001   let g:codi#raw = 0
    1              0.000000 endif
                            
                            " Force sync?
    1              0.000001 if !exists('g:codi#sync')
    1              0.000001   let g:codi#sync = 0
    1              0.000000 endif
                            
                            " Start REPL from the directory of the buffer being edited?
    1              0.000001 if !exists('g:codi#use_buffer_dir')
    1              0.000002   let g:codi#use_buffer_dir = 1
    1              0.000000 endif
                            
                            " Path for the file where Codi log information. Logging is disabled by default 
    1              0.000001 if !exists('g:codi#log')
    1              0.000001   let g:codi#log = ''
    1              0.000000 endif
                            
                            " Toggle virtual text
    1              0.000001 if !exists('g:codi#virtual_text')
    1              0.000004   if has('nvim')
    1              0.000001     let g:codi#virtual_text = 1
                              else
                                let g:codi#virtual_text = 0
    1              0.000000   endif
    1              0.000000 endif
                            
                            " Character prepended on every virtual text
    1              0.000002 if !exists('g:codi#virtual_text_prefix')
                              let g:codi#virtual_text_prefix = "❯ "
    1              0.000000 endif
                            
                            " Highlight group for virtual text output
    1              0.000003 highlight default link CodiVirtualText Statement
                            
    1              0.000007 command! -nargs=? -bang -bar -complete=customlist,codi#complete Codi call codi#run(<bang>0, <f-args>)
    1              0.000014 command! -bar CodiUpdate call codi#update()

SCRIPT  /home/tony/.config/nvim/autoload/plugged/nerdcommenter/plugin/nerdcommenter.vim
Sourced 1 time
Total time:   0.001623
 Self time:   0.000281

count  total (s)   self (s)
    1              0.000005 if exists('loaded_nerd_comments')
                            
                                finish
    1              0.000001 endif
    1              0.000002 if v:version < 700
                                echoerr "NERDCommenter: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
                                finish
    1              0.000000 endif
    1              0.000002 let loaded_nerd_comments = 1
                            
                            " Function: s:InitVariable() function
                            " This function is used to initialise a given variable to a given value. The
                            " variable is only initialised if it does not exist prior
                            "
                            " Args:
                            "   -var: the name of the var to be initialised
                            "   -value: the value to initialise var to
                            "
                            " Returns:
                            "   0
    1              0.000003 function s:InitVariable(var, value)
                                if !exists(a:var)
                                    execute 'let ' . a:var . ' = ' . string(a:value)
                                endif
                            endfunction
                            
                            " Section: variable initialization
    1   0.000017   0.000008 call s:InitVariable('g:NERDAllowAnyVisualDelims', 1)
    1   0.000009   0.000004 call s:InitVariable('g:NERDBlockComIgnoreEmpty', 0)
    1   0.000008   0.000003 call s:InitVariable('g:NERDCommentWholeLinesInVMode', 0)
    1   0.000007   0.000003 call s:InitVariable('g:NERDCommentEmptyLines', 0)
    1   0.000008   0.000004 call s:InitVariable('g:NERDCompactSexyComs', 0)
    1   0.000007   0.000003 call s:InitVariable('g:NERDCreateDefaultMappings', 1)
    1   0.000007   0.000003 call s:InitVariable('g:NERDDefaultNesting', 1)
    1   0.000006   0.000003 call s:InitVariable('g:NERDMenuMode', 3)
    1   0.000006   0.000003 call s:InitVariable('g:NERDLPlace', '[>')
    1   0.000007   0.000003 call s:InitVariable('g:NERDUsePlaceHolders', 1)
    1   0.000006   0.000003 call s:InitVariable('g:NERDRemoveAltComs', 1)
    1   0.000007   0.000003 call s:InitVariable('g:NERDRemoveExtraSpaces', 0)
    1   0.000006   0.000003 call s:InitVariable('g:NERDRPlace', '<]')
    1   0.000006   0.000003 call s:InitVariable('g:NERDSpaceDelims', 0)
    1   0.000006   0.000003 call s:InitVariable('g:NERDDefaultAlign', 'none')
    1   0.000007   0.000003 call s:InitVariable('g:NERDTrimTrailingWhitespace', 0)
    1   0.000007   0.000003 call s:InitVariable('g:NERDToggleCheckAllLines', 0)
    1   0.000007   0.000003 call s:InitVariable('g:NERDDisableTabsInBlockComm', 0)
    1   0.000007   0.000003 call s:InitVariable('g:NERDSuppressWarnings', 0)
                            
                            " Section: Comment mapping and menu item setup
                            " ===========================================================================
                            
                            " Create menu items for the specified modes.  If a:combo is not empty, then
                            " also define mappings and show a:combo in the menu items.
    1              0.000002 function! s:CreateMaps(modes, target, desc, combo)
                                " Build up a map command like
                                " 'noremap <silent> <Plug>NERDCommenterComment :call nerdcommenter#Comment("n", "Comment")'
                                let plug = '<Plug>NERDCommenter' . a:target
                                let plug_start = 'noremap <silent> ' . plug . ' :call nerdcommenter#Comment("'
                                let plug_end = '", "' . a:target . '")<CR>'
                                " Build up a menu command like
                                " 'menu <silent> comment.Comment<Tab>\\cc <Plug>NERDCommenterComment'
                                let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment', '&Plugin.Nerd\ &Commenter'],
                                            \ g:NERDMenuMode, '')
                                let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')
                                if strlen(a:combo)
                                    let leader = exists('g:mapleader') ? g:mapleader : '\'
                                    let menu_command .= '<Tab>' . escape(leader, '\') . a:combo
                                endif
                                let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)
                                " Execute the commands built above for each requested mode.
                                for mode in (a:modes ==# '') ? [''] : split(a:modes, '\zs')
                                    if strlen(a:combo)
                                        execute mode . plug_start . mode . plug_end
                                        if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)
                                            execute mode . 'map <leader>' . a:combo . ' ' . plug
                                        endif
                                    endif
                                    " Check if the user wants the menu to be displayed.
                                    if g:NERDMenuMode !=# 0
                                        execute mode . menu_command
                                    endif
                                endfor
                            endfunction
                            
    1   0.000126   0.000005 call s:CreateMaps('nx', 'Comment',    'Comment', 'cc')
    1   0.000097   0.000006 call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<Space>')
    1   0.000094   0.000006 call s:CreateMaps('nx', 'Minimal',    'Minimal', 'cm')
    1   0.000090   0.000006 call s:CreateMaps('nx', 'Nested',     'Nested', 'cn')
    1   0.000063   0.000006 call s:CreateMaps('n',  'ToEOL',      'To EOL', 'c$')
    1   0.000089   0.000005 call s:CreateMaps('nx', 'Invert',     'Invert', 'ci')
    1   0.000090   0.000006 call s:CreateMaps('nx', 'Sexy',       'Sexy', 'cs')
    1   0.000095   0.000010 call s:CreateMaps('nx', 'Yank',       'Yank then comment', 'cy')
    1   0.000064   0.000006 call s:CreateMaps('n',  'Append',     'Append', 'cA')
    1   0.000042   0.000005 call s:CreateMaps('',   ':',          '-Sep-', '')
    1   0.000092   0.000005 call s:CreateMaps('nx', 'AlignLeft',  'Left aligned', 'cl')
    1   0.000097   0.000008 call s:CreateMaps('nx', 'AlignBoth',  'Left and right aligned', 'cb')
    1   0.000062   0.000023 call s:CreateMaps('',   ':',          '-Sep2-', '')
    1   0.000096   0.000005 call s:CreateMaps('nx', 'Uncomment',  'Uncomment', 'cu')
    1   0.000067   0.000007 call s:CreateMaps('n',  'AltDelims',  'Switch Delimiters', 'ca')
    1   0.000046   0.000007 call s:CreateMaps('i',  'Insert',     'Insert Comment Here', '')
    1   0.000039   0.000005 call s:CreateMaps('',   ':',          '-Sep3-', '')
    1   0.000040   0.000006 call s:CreateMaps('',   ':help NERDCommenterContents<CR>', 'Help', '')
                            
                            " Shim functions so old code gets passed through to the autoload functions
    1              0.000001 function! NERDComment(mode, type) range
                                if !g:NERDSuppressWarnings
                                    echom 'Function NERDComment() has been deprecated, please use nerdcommenter#Comment() instead'
                                endif
                            	if a:firstline != a:lastline
                            		echoerr "Sorry! We can't pass a range through this deprecation shim, please update your code."
                            		return v:false
                            	endif
                                return nerdcommenter#Comment(a:mode, a:type)
                            endfunction
                            
    1              0.000001 function! NERDCommentIsLineCommented(lineNo)
                                if !g:NERDSuppressWarnings
                                    echom 'Function NERDCommentIsLineCommented() has been deprecated, please use nerdcommenter#IsLineCommented() instead'
                                endif
                                return nerdcommenter#IsLineCommented(a:lineNo)
                            endfunction
                            
    1              0.000001 function! NERDCommentIsCharCommented(line, col)
                                if !g:NERDSuppressWarnings
                                    echom 'Function NERDCommentIsCharCommented() has been deprecated, please use nerdcommenter#IsCharCommented() instead'
                                endif
                                return nerdcommenter#IsCharCommented(a:line, a:col)
                            endfunction
                            
    1              0.000008 inoremap <silent> <Plug>NERDCommenterInsert <C-\><C-O>:call nerdcommenter#Comment('i', "Insert")<CR>
                            
                            " switch to/from alternative delimiters (does not use wrapper function)
    1              0.000024 nnoremap <Plug>NERDCommenterAltDelims :call nerdcommenter#SwitchToAlternativeDelimiters(1)<CR>

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-commentary/plugin/commentary.vim
Sourced 1 time
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
                            " commentary.vim - Comment stuff out
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      1.3
                            " GetLatestVimScripts: 3695 1 :AutoInstall: commentary.vim
                            
    1              0.000004 if exists("g:loaded_commentary") || v:version < 700
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_commentary = 1
                            
    1              0.000002 function! s:surroundings() abort
                              return split(get(b:, 'commentary_format', substitute(substitute(substitute(
                                    \ &commentstring, '^$', '%s', ''), '\S\zs%s',' %s', '') ,'%s\ze\S', '%s ', '')), '%s', 1)
                            endfunction
                            
    1              0.000002 function! s:strip_white_space(l,r,line) abort
                              let [l, r] = [a:l, a:r]
                              if l[-1:] ==# ' ' && stridx(a:line,l) == -1 && stridx(a:line,l[0:-2]) == 0
                                let l = l[:-2]
                              endif
                              if r[0] ==# ' ' && a:line[-strlen(r):] != r && a:line[1-strlen(r):] == r[1:]
                                let r = r[1:]
                              endif
                              return [l, r]
                            endfunction
                            
    1              0.000001 function! s:go(...) abort
                              if !a:0
                                let &operatorfunc = matchstr(expand('<sfile>'), '[^. ]*$')
                                return 'g@'
                              elseif a:0 > 1
                                let [lnum1, lnum2] = [a:1, a:2]
                              else
                                let [lnum1, lnum2] = [line("'["), line("']")]
                              endif
                            
                              let [l, r] = s:surroundings()
                              let uncomment = 2
                              let force_uncomment = a:0 > 2 && a:3
                              for lnum in range(lnum1,lnum2)
                                let line = matchstr(getline(lnum),'\S.*\s\@<!')
                                let [l, r] = s:strip_white_space(l,r,line)
                                if len(line) && (stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
                                  let uncomment = 0
                                endif
                              endfor
                            
                              if get(b:, 'commentary_startofline')
                                let indent = '^'
                              else
                                let indent = '^\s*'
                              endif
                            
                              let lines = []
                              for lnum in range(lnum1,lnum2)
                                let line = getline(lnum)
                                if strlen(r) > 2 && l.r !~# '\\'
                                  let line = substitute(line,
                                        \'\M' . substitute(l, '\ze\S\s*$', '\\zs\\d\\*\\ze', '') . '\|' . substitute(r, '\S\zs', '\\zs\\d\\*\\ze', ''),
                                        \'\=substitute(submatch(0)+1-uncomment,"^0$\\|^-\\d*$","","")','g')
                                endif
                                if force_uncomment
                                  if line =~ '^\s*' . l
                                    let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
                                  endif
                                elseif uncomment
                                  let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
                                else
                                  let line = substitute(line,'^\%('.matchstr(getline(lnum1),indent).'\|\s*\)\zs.*\S\@<=','\=l.submatch(0).r','')
                                endif
                                call add(lines, line)
                              endfor
                              call setline(lnum1, lines)
                              let modelines = &modelines
                              try
                                set modelines=0
                                silent doautocmd User CommentaryPost
                              finally
                                let &modelines = modelines
                              endtry
                              return ''
                            endfunction
                            
    1              0.000001 function! s:textobject(inner) abort
                              let [l, r] = s:surroundings()
                              let lnums = [line('.')+1, line('.')-2]
                              for [index, dir, bound, line] in [[0, -1, 1, ''], [1, 1, line('$'), '']]
                                while lnums[index] != bound && line ==# '' || !(stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
                                  let lnums[index] += dir
                                  let line = matchstr(getline(lnums[index]+dir),'\S.*\s\@<!')
                                  let [l, r] = s:strip_white_space(l,r,line)
                                endwhile
                              endfor
                              while (a:inner || lnums[1] != line('$')) && empty(getline(lnums[0]))
                                let lnums[0] += 1
                              endwhile
                              while a:inner && empty(getline(lnums[1]))
                                let lnums[1] -= 1
                              endwhile
                              if lnums[0] <= lnums[1]
                                execute 'normal! 'lnums[0].'GV'.lnums[1].'G'
                              endif
                            endfunction
                            
    1              0.000006 command! -range -bar -bang Commentary call s:go(<line1>,<line2>,<bang>0)
    1              0.000006 xnoremap <expr>   <Plug>Commentary     <SID>go()
    1              0.000005 nnoremap <expr>   <Plug>Commentary     <SID>go()
    1              0.000005 nnoremap <expr>   <Plug>CommentaryLine <SID>go() . '_'
    1              0.000007 onoremap <silent> <Plug>Commentary        :<C-U>call <SID>textobject(get(v:, 'operator', '') ==# 'c')<CR>
    1              0.000005 nnoremap <silent> <Plug>ChangeCommentary c:<C-U>call <SID>textobject(1)<CR>
    1              0.000009 nmap <silent> <Plug>CommentaryUndo :echoerr "Change your <Plug>CommentaryUndo map to <Plug>Commentary<Plug>Commentary"<CR>
                            
    1              0.000009 if !hasmapto('<Plug>Commentary') || maparg('gc','n') ==# ''
    1              0.000004   xmap gc  <Plug>Commentary
    1              0.000003   nmap gc  <Plug>Commentary
    1              0.000003   omap gc  <Plug>Commentary
    1              0.000003   nmap gcc <Plug>CommentaryLine
    1              0.000005   if maparg('c','n') ==# '' && !exists('v:operator')
                                nmap cgc <Plug>ChangeCommentary
    1              0.000001   endif
    1              0.000004   nmap gcu <Plug>Commentary<Plug>Commentary
    1              0.000000 endif
                            
                            " vim:set et sw=2:

SCRIPT  /home/tony/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim
Sourced 1 time
Total time:   0.000289
 Self time:   0.000289

count  total (s)   self (s)
                            " Insert or delete brackets, parens, quotes in pairs.
                            " Maintainer:	JiangMiao <jiangfriend@gmail.com>
                            " Contributor: camthompson
                            " Last Change:  2019-02-02
                            " Version: 2.0.0
                            " Homepage: http://www.vim.org/scripts/script.php?script_id=3599
                            " Repository: https://github.com/jiangmiao/auto-pairs
                            " License: MIT
                            
    1              0.000008 if exists('g:AutoPairsLoaded') || &cp
                              finish
    1              0.000000 end
    1              0.000002 let g:AutoPairsLoaded = 1
                            
    1              0.000001 if !exists('g:AutoPairs')
    1              0.000005   let g:AutoPairs = {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '```':'```', '"""':'"""', "'''":"'''", "`":"`"}
    1              0.000000 end
                            
                            " default pairs base on filetype
    1              0.000001 func! AutoPairsDefaultPairs()
                              if exists('b:autopairs_defaultpairs')
                                return b:autopairs_defaultpairs
                              end
                              let r = copy(g:AutoPairs)
                              let allPairs = {
                                    \ 'vim': {'\v^\s*\zs"': ''},
                                    \ 'rust': {'\w\zs<': '>', '&\zs''': ''},
                                    \ 'php': {'<?': '?>//k]', '<?php': '?>//k]'}
                                    \ }
                              for [filetype, pairs] in items(allPairs)
                                if &filetype == filetype
                                  for [open, close] in items(pairs)
                                    let r[open] = close
                                  endfor
                                end
                              endfor
                              let b:autopairs_defaultpairs = r
                              return r
                            endf
                            
    1              0.000001 if !exists('g:AutoPairsMapBS')
    1              0.000001   let g:AutoPairsMapBS = 1
    1              0.000000 end
                            
                            " Map <C-h> as the same BS
    1              0.000001 if !exists('g:AutoPairsMapCh')
    1              0.000001   let g:AutoPairsMapCh = 1
    1              0.000000 end
                            
    1              0.000001 if !exists('g:AutoPairsMapCR')
    1              0.000001   let g:AutoPairsMapCR = 1
    1              0.000000 end
                            
    1              0.000001 if !exists('g:AutoPairsWildClosedPair')
    1              0.000001   let g:AutoPairsWildClosedPair = ''
    1              0.000000 end
                            
    1              0.000001 if !exists('g:AutoPairsMapSpace')
    1              0.000001   let g:AutoPairsMapSpace = 1
    1              0.000001 end
                            
    1              0.000001 if !exists('g:AutoPairsCenterLine')
    1              0.000001   let g:AutoPairsCenterLine = 1
    1              0.000000 end
                            
    1              0.000001 if !exists('g:AutoPairsShortcutToggle')
    1              0.000001   let g:AutoPairsShortcutToggle = '<M-p>'
    1              0.000000 end
                            
    1              0.000001 if !exists('g:AutoPairsShortcutFastWrap')
    1              0.000001   let g:AutoPairsShortcutFastWrap = '<M-e>'
    1              0.000000 end
                            
    1              0.000001 if !exists('g:AutoPairsMoveCharacter')
    1              0.000001   let g:AutoPairsMoveCharacter = "()[]{}\"'"
    1              0.000000 end
                            
    1              0.000001 if !exists('g:AutoPairsShortcutJump')
    1              0.000001   let g:AutoPairsShortcutJump = '<M-n>'
    1              0.000000 endif
                            
                            " Fly mode will for closed pair to jump to closed pair instead of insert.
                            " also support AutoPairsBackInsert to insert pairs where jumped.
    1              0.000001 if !exists('g:AutoPairsFlyMode')
    1              0.000001   let g:AutoPairsFlyMode = 0
    1              0.000000 endif
                            
                            " When skipping the closed pair, look at the current and
                            " next line as well.
    1              0.000001 if !exists('g:AutoPairsMultilineClose')
    1              0.000001   let g:AutoPairsMultilineClose = 1
    1              0.000000 endif
                            
                            " Work with Fly Mode, insert pair where jumped
    1              0.000001 if !exists('g:AutoPairsShortcutBackInsert')
    1              0.000001   let g:AutoPairsShortcutBackInsert = '<M-b>'
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:AutoPairsSmartQuotes')
    1              0.000001   let g:AutoPairsSmartQuotes = 1
    1              0.000000 endif
                            
                            " 7.4.849 support <C-G>U to avoid breaking '.'
                            " Issue talk: https://github.com/jiangmiao/auto-pairs/issues/3
                            " Vim note: https://github.com/vim/vim/releases/tag/v7.4.849
    1              0.000002 if v:version > 704 || v:version == 704 && has("patch849")
    1              0.000001   let s:Go = "\<C-G>U"
                            else
                              let s:Go = ""
    1              0.000000 endif
                            
    1              0.000002 let s:Left = s:Go."\<LEFT>"
    1              0.000001 let s:Right = s:Go."\<RIGHT>"
                            
                            
                            
                            
                            " unicode len
    1              0.000002 func! s:ulen(s)
                              return len(split(a:s, '\zs'))
                            endf
                            
    1              0.000001 func! s:left(s)
                              return repeat(s:Left, s:ulen(a:s))
                            endf
                            
    1              0.000001 func! s:right(s)
                              return repeat(s:Right, s:ulen(a:s))
                            endf
                            
    1              0.000001 func! s:delete(s)
                              return repeat("\<DEL>", s:ulen(a:s))
                            endf
                            
    1              0.000001 func! s:backspace(s)
                              return repeat("\<BS>", s:ulen(a:s))
                            endf
                            
    1              0.000001 func! s:getline()
                              let line = getline('.')
                              let pos = col('.') - 1
                              let before = strpart(line, 0, pos)
                              let after = strpart(line, pos)
                              let afterline = after
                              if g:AutoPairsMultilineClose
                                let n = line('$')
                                let i = line('.')+1
                                while i <= n
                                  let line = getline(i)
                                  let after = after.' '.line
                                  if !(line =~ '\v^\s*$')
                                    break
                                  end
                                  let i = i+1
                                endwhile
                              end
                              return [before, after, afterline]
                            endf
                            
                            " split text to two part
                            " returns [orig, text_before_open, open]
    1              0.000001 func! s:matchend(text, open)
                                let m = matchstr(a:text, '\V'.a:open.'\v$')
                                if m == ""
                                  return []
                                end
                                return [a:text, strpart(a:text, 0, len(a:text)-len(m)), m]
                            endf
                            
                            " returns [orig, close, text_after_close]
    1              0.000001 func! s:matchbegin(text, close)
                                let m = matchstr(a:text, '^\V'.a:close)
                                if m == ""
                                  return []
                                end
                                return [a:text, m, strpart(a:text, len(m), len(a:text)-len(m))]
                            endf
                            
                            " add or delete pairs base on g:AutoPairs
                            " AutoPairsDefine(addPairs:dict[, removeOpenPairList:list])
                            "
                            " eg:
                            "   au FileType html let b:AutoPairs = AutoPairsDefine({'<!--' : '-->'}, ['{'])
                            "   add <!-- --> pair and remove '{' for html file
    1              0.000001 func! AutoPairsDefine(pairs, ...)
                              let r = AutoPairsDefaultPairs()
                              if a:0 > 0
                                for open in a:1
                                  unlet r[open]
                                endfor
                              end
                              for [open, close] in items(a:pairs)
                                let r[open] = close
                              endfor
                              return r
                            endf
                            
    1              0.000001 func! AutoPairsInsert(key)
                              if !b:autopairs_enabled
                                return a:key
                              end
                            
                              let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
                              let [before, after, afterline] = s:getline()
                            
                              " Ignore auto close if prev character is \
                              if before[-1:-1] == '\'
                                return a:key
                              end
                            
                              " check open pairs
                              for [open, close, opt] in b:AutoPairsList
                                let ms = s:matchend(before.a:key, open)
                                let m = matchstr(afterline, '^\v\s*\zs\V'.close)
                                if len(ms) > 0
                                  " process the open pair
                                  
                                  " remove inserted pair
                                  " eg: if the pairs include < > and  <!-- --> 
                                  " when <!-- is detected the inserted pair < > should be clean up 
                                  let target = ms[1]
                                  let openPair = ms[2]
                                  if len(openPair) == 1 && m == openPair
                                    break
                                  end
                                  let bs = ''
                                  let del = ''
                                  while len(before) > len(target)
                                    let found = 0
                                    " delete pair
                                    for [o, c, opt] in b:AutoPairsList
                                      let os = s:matchend(before, o)
                                      if len(os) && len(os[1]) < len(target)
                                        " any text before openPair should not be deleted
                                        continue
                                      end
                                      let cs = s:matchbegin(afterline, c)
                                      if len(os) && len(cs)
                                        let found = 1
                                        let before = os[1]
                                        let afterline = cs[2]
                                        let bs = bs.s:backspace(os[2])
                                        let del = del.s:delete(cs[1])
                                        break
                                      end
                                    endfor
                                    if !found
                                      " delete charactor
                                      let ms = s:matchend(before, '\v.')
                                      if len(ms)
                                        let before = ms[1]
                                        let bs = bs.s:backspace(ms[2])
                                      end
                                    end
                                  endwhile
                                  return bs.del.openPair.close.s:left(close)
                                end
                              endfor
                            
                              " check close pairs
                              for [open, close, opt] in b:AutoPairsList
                                if close == ''
                                  continue
                                end
                                if a:key == g:AutoPairsWildClosedPair || opt['mapclose'] && opt['key'] == a:key
                                  " the close pair is in the same line
                                  let m = matchstr(afterline, '^\v\s*\V'.close)
                                  if m != ''
                                    if before =~ '\V'.open.'\v\s*$' && m[0] =~ '\v\s'
                                      " remove the space we inserted if the text in pairs is blank
                                      return "\<DEL>".s:right(m[1:])
                                    else
                                      return s:right(m)
                                    end
                                  end
                                  let m = matchstr(after, '^\v\s*\zs\V'.close)
                                  if m != ''
                                    if a:key == g:AutoPairsWildClosedPair || opt['multiline']
                                      if b:autopairs_return_pos == line('.') && getline('.') =~ '\v^\s*$'
                                        normal! ddk$
                                      end
                                      call search(m, 'We')
                                      return "\<Right>"
                                    else
                                      break
                                    end
                                  end
                                end
                              endfor
                            
                            
                              " Fly Mode, and the key is closed-pairs, search closed-pair and jump
                              if g:AutoPairsFlyMode &&  a:key =~ '\v[\}\]\)]'
                                if search(a:key, 'We')
                                  return "\<Right>"
                                endif
                              endif
                            
                              return a:key
                            endf
                            
    1              0.000001 func! AutoPairsDelete()
                              if !b:autopairs_enabled
                                return "\<BS>"
                              end
                            
                              let [before, after, ig] = s:getline()
                              for [open, close, opt] in b:AutoPairsList
                                let b = matchstr(before, '\V'.open.'\v\s?$')
                                let a = matchstr(after, '^\v\s*\V'.close)
                                if b != '' && a != ''
                                  if b[-1:-1] == ' '
                                    if a[0] == ' '
                                      return "\<BS>\<DELETE>"
                                    else
                                      return "\<BS>"
                                    end
                                  end
                                  return s:backspace(b).s:delete(a)
                                end
                              endfor
                            
                              return "\<BS>"
                              " delete the pair foo[]| <BS> to foo
                              for [open, close, opt] in b:AutoPairsList
                                let m = s:matchend(before, '\V'.open.'\v\s*'.'\V'.close.'\v$')
                                if len(m) > 0
                                  return s:backspace(m[2])
                                end
                              endfor
                              return "\<BS>"
                            endf
                            
                            
                            " Fast wrap the word in brackets
    1              0.000001 func! AutoPairsFastWrap()
                              let c = @"
                              normal! x
                              let [before, after, ig] = s:getline()
                              if after[0] =~ '\v[\{\[\(\<]'
                                normal! %
                                normal! p
                              else
                                for [open, close, opt] in b:AutoPairsList
                                  if close == ''
                                    continue
                                  end
                                  if after =~ '^\s*\V'.open
                                    call search(close, 'We')
                                    normal! p
                                    let @" = c
                                    return ""
                                  end
                                endfor
                                if after[1:1] =~ '\v\w'
                                  normal! e
                                  normal! p
                                else
                                  normal! p
                                end
                              end
                              let @" = c
                              return ""
                            endf
                            
    1              0.000001 func! AutoPairsJump()
                              call search('["\]'')}]','W')
                            endf
                            
    1              0.000001 func! AutoPairsMoveCharacter(key)
                              let c = getline(".")[col(".")-1]
                              let escaped_key = substitute(a:key, "'", "''", 'g')
                              return "\<DEL>\<ESC>:call search("."'".escaped_key."'".")\<CR>a".c."\<LEFT>"
                            endf
                            
    1              0.000001 func! AutoPairsBackInsert()
                              let pair = b:autopairs_saved_pair[0]
                              let pos  = b:autopairs_saved_pair[1]
                              call setpos('.', pos)
                              return pair
                            endf
                            
    1              0.000001 func! AutoPairsReturn()
                              if b:autopairs_enabled == 0
                                return ''
                              end
                              let b:autopairs_return_pos = 0
                              let before = getline(line('.')-1)
                              let [ig, ig, afterline] = s:getline()
                              let cmd = ''
                              for [open, close, opt] in b:AutoPairsList
                                if close == ''
                                  continue
                                end
                            
                                if before =~ '\V'.open.'\v\s*$' && afterline =~ '^\s*\V'.close
                                  let b:autopairs_return_pos = line('.')
                                  if g:AutoPairsCenterLine && winline() * 3 >= winheight(0) * 2
                                    " Recenter before adding new line to avoid replacing line content
                                    let cmd = "zz"
                                  end
                            
                                  " If equalprg has been set, then avoid call =
                                  " https://github.com/jiangmiao/auto-pairs/issues/24
                                  if &equalprg != ''
                                    return "\<ESC>".cmd."O"
                                  endif
                            
                                  " conflict with javascript and coffee
                                  " javascript   need   indent new line
                                  " coffeescript forbid indent new line
                                  if &filetype == 'coffeescript' || &filetype == 'coffee'
                                    return "\<ESC>".cmd."k==o"
                                  else
                                    return "\<ESC>".cmd."=ko"
                                  endif
                                end
                              endfor
                              return ''
                            endf
                            
    1              0.000001 func! AutoPairsSpace()
                              if !b:autopairs_enabled
                                return "\<SPACE>"
                              end
                            
                              let [before, after, ig] = s:getline()
                            
                              for [open, close, opt] in b:AutoPairsList
                                if close == ''
                                  continue
                                end
                                if before =~ '\V'.open.'\v$' && after =~ '^\V'.close
                                  if close =~ '\v^[''"`]$'
                                    return "\<SPACE>"
                                  else
                                    return "\<SPACE>\<SPACE>".s:Left
                                  end
                                end
                              endfor
                              return "\<SPACE>"
                            endf
                            
    1              0.000001 func! AutoPairsMap(key)
                              " | is special key which separate map command from text
                              let key = a:key
                              if key == '|'
                                let key = '<BAR>'
                              end
                              let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
                              execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
                            endf
                            
    1              0.000001 func! AutoPairsToggle()
                              if b:autopairs_enabled
                                let b:autopairs_enabled = 0
                                echo 'AutoPairs Disabled.'
                              else
                                let b:autopairs_enabled = 1
                                echo 'AutoPairs Enabled.'
                              end
                              return ''
                            endf
                            
    1              0.000001 func! s:sortByLength(i1, i2)
                              return len(a:i2[0])-len(a:i1[0])
                            endf
                            
    1              0.000001 func! AutoPairsInit()
                              let b:autopairs_loaded  = 1
                              if !exists('b:autopairs_enabled')
                                let b:autopairs_enabled = 1
                              end
                            
                              if !exists('b:AutoPairs')
                                let b:AutoPairs = AutoPairsDefaultPairs()
                              end
                            
                              if !exists('b:AutoPairsMoveCharacter')
                                let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
                              end
                            
                              let b:autopairs_return_pos = 0
                              let b:autopairs_saved_pair = [0, 0]
                              let b:AutoPairsList = []
                            
                              " buffer level map pairs keys
                              " n - do not map the first charactor of closed pair to close key
                              " m - close key jumps through multi line
                              " s - close key jumps only in the same line
                              for [open, close] in items(b:AutoPairs)
                                let o = open[-1:-1]
                                let c = close[0]
                                let opt = {'mapclose': 1, 'multiline':1}
                                let opt['key'] = c
                                if o == c
                                  let opt['multiline'] = 0
                                end
                                let m = matchlist(close, '\v(.*)//(.*)$')
                                if len(m) > 0 
                                  if m[2] =~ 'n'
                                    let opt['mapclose'] = 0
                                  end
                                  if m[2] =~ 'm'
                                    let opt['multiline'] = 1
                                  end
                                  if m[2] =~ 's'
                                    let opt['multiline'] = 0
                                  end
                                  let ks = matchlist(m[2], '\vk(.)')
                                  if len(ks) > 0
                                    let opt['key'] = ks[1]
                                    let c = opt['key']
                                  end
                                  let close = m[1]
                                end
                                call AutoPairsMap(o)
                                if o != c && c != '' && opt['mapclose']
                                  call AutoPairsMap(c)
                                end
                                let b:AutoPairsList += [[open, close, opt]]
                              endfor
                            
                              " sort pairs by length, longer pair should have higher priority
                              let b:AutoPairsList = sort(b:AutoPairsList, "s:sortByLength")
                            
                              for item in b:AutoPairsList
                                let [open, close, opt] = item
                                if open == "'" && open == close
                                  let item[0] = '\v(^|\W)\zs'''
                                end
                              endfor
                            
                            
                              for key in split(b:AutoPairsMoveCharacter, '\s*')
                                let escaped_key = substitute(key, "'", "''", 'g')
                                execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
                              endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
                              if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
                                execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
                              end
                            
                              if g:AutoPairsMapCh
                                execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
                              endif
                            
                              if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
                                let do_abbrev = ""
                                if v:version == 703 && has("patch489") || v:version > 703
                                  let do_abbrev = "<C-]>"
                                endif
                                execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
                              end
                            
                              if g:AutoPairsShortcutFastWrap != ''
                                execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
                              end
                            
                              if g:AutoPairsShortcutBackInsert != ''
                                execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
                              end
                            
                              if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
                                execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
                                execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
                              end
                            
                              if g:AutoPairsShortcutJump != ''
                                execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
                                execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
                              end
                            
                              if &keymap != ''
                                let l:imsearch = &imsearch
                                let l:iminsert = &iminsert
                                let l:imdisable = &imdisable
                                execute 'setlocal keymap=' . &keymap
                                execute 'setlocal imsearch=' . l:imsearch
                                execute 'setlocal iminsert=' . l:iminsert
                                if l:imdisable
                                  execute 'setlocal imdisable'
                                else
                                  execute 'setlocal noimdisable'
                                end
                              end
                            
                            endf
                            
    1              0.000001 func! s:ExpandMap(map)
                              let map = a:map
                              let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
                              let map = substitute(map, '\(<Plug>([^)]*)\)', '\=maparg(submatch(1), "i")', 'g')
                              return map
                            endf
                            
    1              0.000001 func! AutoPairsTryInit()
                              if exists('b:autopairs_loaded')
                                return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
                              if g:AutoPairsMapCR
                                if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
                                  let info = maparg('<CR>', 'i', 0, 1)
                                  if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
                                if old_cr !~ 'AutoPairsReturn'
                                  if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
                                  execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
                                end
                              endif
                              call AutoPairsInit()
                            endf
                            
                            " Always silent the command
    1              0.000012 inoremap <silent> <SID>AutoPairsReturn <C-R>=AutoPairsReturn()<CR>
    1              0.000005 imap <script> <Plug>AutoPairsReturn <SID>AutoPairsReturn
                            
                            
    1              0.000017 au BufEnter * :call AutoPairsTryInit()

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-closetag/plugin/closetag.vim
Sourced 1 time
Total time:   0.000291
 Self time:   0.000145

count  total (s)   self (s)
                            " {{{
                            "
                            "      Modifier:  Alvan
                            "   Description:  Auto close tag.
                            "                 Based on xml.vim(http://www.vim.org/scripts/script.php?script_id=1397)
                            "
                            " }}}
                            "
    1              0.000006 if exists("g:loaded_closetag") | fini | en | let g:loaded_closetag = "1.8.11"
                            
    1              0.000002 fun! s:Initial()
                                call s:Declare('g:closetag_filetypes', 'html,xhtml,phtml')
                                call s:Declare('g:closetag_xhtml_filetypes', 'xhtml')
                            
                                call s:Declare('g:closetag_filenames', '*.html,*.xhtml,*.phtml')
                                call s:Declare('g:closetag_xhtml_filenames', '*.xhtml')
                            
                                call s:Declare('g:closetag_shortcut', '>')
                                call s:Declare('g:closetag_close_shortcut', '')
                            
                                call s:Declare('g:closetag_emptyTags_caseSensitive', 0)
                            
                                call s:Declare('g:closetag_regions', {
                                    \ 'typescript.tsx': 'jsxRegion,tsxRegion',
                                    \ 'javascript.jsx': 'jsxRegion',
                                    \ 'typescriptreact': 'jsxRegion,tsxRegion',
                                    \ 'javascriptreact': 'jsxRegion',
                                    \ })
                            
                                let g:closetag_filenames = substitute(g:closetag_filenames, '\s*,\s\+', ',', 'g')
                                let g:closetag_xhtml_filenames = substitute(g:closetag_xhtml_filenames, '\s*,\s\+', ',', 'g')
                                let g:closetag_filetypes = substitute(g:closetag_filetypes, '\s*,\s\+', ',', 'g')
                                let g:closetag_xhtml_filetypes = substitute(g:closetag_xhtml_filetypes, '\s*,\s\+', ',', 'g')
                            
                                if g:closetag_shortcut != ''
                                    exec "au User vim-closetag inoremap <silent> <buffer> " . g:closetag_shortcut . " ><Esc>:call <SID>CloseIt()<Cr>"
                            
                                    if g:closetag_filetypes != ''
                                        exec "au FileType " . g:closetag_filetypes . " inoremap <silent> <buffer> " . g:closetag_shortcut . " ><Esc>:call <SID>CloseIt()<Cr>"
                                    en
                                    if g:closetag_filenames != ''
                                        exec "au BufNewFile,Bufread " . g:closetag_filenames . " inoremap <silent> <buffer> " . g:closetag_shortcut . " ><Esc>:call <SID>CloseIt()<Cr>"
                                    en
                                en
                            
                                if g:closetag_close_shortcut != ''
                                    if g:closetag_filetypes != ''
                                        exec "au FileType " . g:closetag_filetypes . " inoremap <silent> <buffer> " . g:closetag_close_shortcut . " >"
                                    en
                                    if g:closetag_filenames != ''
                                        exec "au BufNewFile,Bufread " . g:closetag_filenames . " inoremap <silent> <buffer> " . g:closetag_close_shortcut . " >"
                                    en
                                en
                            
                                if g:closetag_xhtml_filetypes != ''
                                    exec "au FileType " . g:closetag_xhtml_filetypes . " call <SID>Declare('b:closetag_use_xhtml', 1)"
                                en
                                if g:closetag_xhtml_filenames != ''
                                    exec "au BufNewFile,Bufread " . g:closetag_xhtml_filenames . " call <SID>Declare('b:closetag_use_xhtml', 1)"
                                en
                            
                                com! -nargs=* -complete=file CloseTagEnableBuffer let b:closetag_disabled = 0
                                com! -nargs=* -complete=file CloseTagDisableBuffer let b:closetag_disabled = 1
                                com! -nargs=* -complete=file CloseTagToggleBuffer let b:closetag_disabled = exists('b:closetag_disabled') && b:closetag_disabled ? 0 : 1
                            
                                " Script rgular expresion used. Documents those nasty criters
                                " Don't check for quotes around attributes!!!
                                let s:ReqAttrib = '\(\(\s\|\n\)\+\([^>= \t]\+=[^>&]\+\)\(\s\|\n\)*\)\+\(\/\)\@\<!>'
                                let s:EndofName = '\($\|\s\|>\)'
                            endf
                            
                            " Define default variables
    1              0.000001 fun! s:Declare(var, def)
                                if !exists(a:var)
                                    let {a:var} = a:def
                                en
                            endf
                            
                            " Buffer variables
    1              0.000001 fun! s:InitBuf()
                                call s:Declare('b:did_ftplugin_closetag', 1)
                                call s:Declare('b:closetag_emptyTags', '^\(area\|base\|br\|col\|command\|embed\|hr\|img\|input\|keygen\|link\|meta\|param\|source\|track\|wbr\)$')
                                call s:Declare('b:closetag_firstWasEndTag', 0)
                                call s:Declare('b:closetag_html_mode', 1)
                                call s:Declare('b:closetag_haveAtt', 0)
                                call s:Declare('b:closetag_use_xhtml', &filetype == 'xhtml' ? 1 : 0)
                            endf
                            
    1              0.000001 fun! s:SavePos()
                                retu 'call cursor('.line('.').','. col('.'). ')'
                            endf
                            
    1              0.000001 fun! s:Handler(xml_tag, isHtml)
                                let text = 0
                                if a:isHtml == 1 && exists("*HtmlAttribCallback")
                                    let text = HtmlAttribCallback(a:xml_tag)
                                elseif exists("*XmlAttribCallback")
                                    let text = XmlAttribCallback(a:xml_tag)
                                en
                                if text != '0'
                                    execute "normal! i " . text ."\<Esc>l"
                                en
                            endf
                            
                            " Gets the tagname from start position.
                            "
                            " Now lets go for the name part. The namepart are xmlnamechars which
                            " is quite a big range. We assume that everything after '<' or '</'
                            " until the first 'space', 'forward slash' or '>' ends de name part.
    1              0.000001 fun! s:TagName(from)
                                let l:end = match(getline('.'), s:EndofName,a:from)
                                let l:tag = strpart(getline('.'),a:from, l:end - a:from)
                                if strridx(l:tag, "\\") == strlen(l:tag) - 1
                                    let l:tag = ''
                                en
                            
                                retu l:tag
                            endf
                            
                            " Looks for attribute in open tag
                            " expect cursor to be on <
    1              0.000001 fun! s:HaveAtt()
                                "Check if this open tag has attributes
                                let l:line = line('.') | let l:col = col('.')
                                if search(b:closetag_tagName . s:ReqAttrib,'W') > 0
                                    if l:line == line('.') && l:col == (col('.')-1)
                                        let b:closetag_haveAtt = 1
                                    en
                                en
                            endf
                            
                            " Should the tag be treated as an non closing) tag?
                            " check the current tag with the set of tags defined in b:closetag_emptyTags
                            " closetag_emptyTags_caseSensitive defines if the check is case sensitive
    1              0.000001 fun! s:AsEmpty()
                                retu g:closetag_emptyTags_caseSensitive == 1
                                            \ ? b:closetag_tagName =~# b:closetag_emptyTags
                                            \ : b:closetag_tagName =~? b:closetag_emptyTags
                            endf
                            
                            " Is there a tag under the cursor?
                            " Set bufer wide variable
                            "  - b:closetag_firstWasEndTag
                            "  - b:closetag_tagName
                            "  - b:gotoCloseTag (if the tag under the cursor is one)
                            "  - b:gotoOpenTag  (if the tag under the cursor is one)
                            " on exit
                            "    - returns 1 (true)  or 0 (false)
                            "    - position is at '<'
    1              0.000001 fun! s:FindTag()
                                let b:closetag_firstWasEndTag = 0
                                let b:closetag_haveAtt = 0
                                let l:haveTag = 0
                                let l:stayCol = col('.')
                            
                                "Lets find forward a < or a >.  If we first find a > we might be in a tag.
                                "If we find a < first or nothing we are definitly not in a tag
                            
                                " if getline('.')[col('.') - 1] != '>'
                                " search('[<>]','W')
                                " en
                            
                                if getline('.')[col('.') - 1] == '>'
                                    " we don't work with:
                                    " blank string, empty tags, jsp %> tags, php ?> tags, operator =>, operator ->
                                    if index([' ', '/', '%', '?', '=', '-'], getline('.')[col('.')-2]) >= 0
                                        retu l:haveTag
                                    en
                                el
                                    retu l:haveTag
                                en
                            
                                if search('[<>]','bW') >=0
                                    if getline('.')[col('.')-1] == '<'
                                        if getline('.')[col('.')] == '/'
                                            let b:closetag_firstWasEndTag = 1
                                            let b:gotoCloseTag = s:SavePos()
                                        elseif getline('.')[col('.')] == '?' ||  getline('.')[col('.')] == '!'
                                            "we don't deal with processing instructions or dtd
                                            "related definitions
                                            retu l:haveTag
                                        el
                                            let b:gotoOpenTag = s:SavePos()
                                        en
                                    el
                                        retu l:haveTag
                                    en
                                el
                                    retu l:haveTag
                                en
                            
                                "we don't deal with the first > in quotes
                                let l:str = strpart(getline('.'),col('.'), l:stayCol - col('.'))
                                if (strlen(l:str) - strlen(substitute(substitute(substitute(l:str, '\\\\', '', 'g'), '\\"', '', 'g'), '"', '', 'g'))) % 2
                                    retu l:haveTag
                                en
                            
                                "we have established that we are between something like
                                "'</\?[^>]*>'
                            
                                let b:closetag_tagName = s:TagName(col('.') + b:closetag_firstWasEndTag)
                                "echo 'Tag ' . b:closetag_tagName
                            
                                "begin: gwang customization, do not work with an empty tag name
                                if b:closetag_tagName == ''
                                    retu l:haveTag
                                en
                                "end: gwang customization, do not work with an empty tag name
                            
                                let l:haveTag = 1
                                if b:closetag_firstWasEndTag == 0
                                    call s:HaveAtt()
                                    if exists('b:gotoOpenTag') && b:gotoOpenTag != ''
                                        exe b:gotoOpenTag
                                    en
                                en
                                retu l:haveTag
                            endf
                            
    1              0.000001 fun! s:InValidRegion()
                                let l:regions = get(g:closetag_regions, &filetype, '')
                                if l:regions == ''
                                    " no restrictions? no problem
                                    return 1
                                en
                            
                                " make sure we're in a valid region type
                                let l:regionStack = synstack(line('.'), col('.'))
                                for id in l:regionStack
                                    let l:regionName = synIDattr(id, "name")
                                    if stridx(l:regions, l:regionName) != -1
                                        retu 1
                                    en
                                endfor
                            
                                " not in a valid region; cancel
                                retu 0
                            endf
                            
    1              0.000001 fun! s:CloseIt()
                                if !exists("b:did_ftplugin_closetag")
                                    call s:InitBuf()
                                en
                            
                                if !(exists("b:closetag_disabled") && b:closetag_disabled) && s:InValidRegion()
                                    let l:restore = s:SavePos()
                            
                                    let l:endOfLine = ((col('.')+1) == col('$'))
                                    if col('.') > 1 && getline('.')[col('.')-2] == '>'
                                        let l:line = line('.')
                                        "Multiline request. <t>></t> -->
                                        "<t>
                                        "        cursor comes here
                                        "</t>
                                        normal! h
                                        if s:FindTag()
                                            if b:closetag_firstWasEndTag == 0
                                                if l:line > 0 && l:line != line('.')
                                                    exe "normal! " . l:line . "gg"
                                                en
                                                if exists('b:did_indent') && b:did_indent == 1
                                                    exe "normal! 2f>a\<Cr>\<Esc>k$i\<Cr>\<Esc>$"
                                                else
                                                    exe "normal! 2f>a\<Cr>\<Esc>k$i\<Cr>\<Esc>>>$"
                                                en
                                                call setline('.', strpart(getline('.'), 0, strlen(getline('.'))-1))
                            
                                                if col('.') >= col('$') | start | el | start! | en
                                                retu
                                            en
                                        en
                                    elseif s:FindTag()
                                        if b:closetag_firstWasEndTag == 0
                                            exe "silent normal! />\<Cr>"
                                            if b:closetag_html_mode && s:AsEmpty()
                                                if b:closetag_haveAtt == 0
                                                    call s:Handler(b:closetag_tagName, b:closetag_html_mode)
                                                en
                                                if b:closetag_use_xhtml
                                                    exe "normal! i/\<Esc>l"
                                                en
                                                if l:endOfLine
                                                    start!
                                                    retu
                                                el
                                                    normal! l
                                                    start
                                                    retu
                                                en
                                            el
                                                if b:closetag_haveAtt == 0
                                                    call s:Handler(b:closetag_tagName, b:closetag_html_mode)
                                                en
                                                exe "normal! a</" . b:closetag_tagName . ">\<Esc>F<"
                                                start
                                                retu
                                            en
                                        en
                                    en
                                    exe l:restore
                                en
                            
                                if (col('.')+1) == col("$")
                                    startinsert!
                                else
                                    normal! l
                                    startinsert
                                en
                            endf
                            
    1   0.000155   0.000010 call s:Initial()
                            " End of file : closetag.vim

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-surround/plugin/surround.vim
Sourced 1 time
Total time:   0.000324
 Self time:   0.000324

count  total (s)   self (s)
                            " surround.vim - Surroundings
                            " Author:       Tim Pope <http://tpo.pe/>
                            " Version:      2.2
                            " GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim
                            
    1              0.000008 if exists("g:loaded_surround") || &cp || v:version < 700
                              finish
    1              0.000000 endif
    1              0.000005 let g:loaded_surround = 1
                            
                            " Input functions {{{1
                            
    1              0.000002 function! s:getchar()
                              let c = getchar()
                              if c =~ '^\d\+$'
                                let c = nr2char(c)
                              endif
                              return c
                            endfunction
                            
    1              0.000001 function! s:inputtarget()
                              let c = s:getchar()
                              while c =~ '^\d\+$'
                                let c .= s:getchar()
                              endwhile
                              if c == " "
                                let c .= s:getchar()
                              endif
                              if c =~ "\<Esc>\|\<C-C>\|\0"
                                return ""
                              else
                                return c
                              endif
                            endfunction
                            
    1              0.000001 function! s:inputreplacement()
                              let c = s:getchar()
                              if c == " "
                                let c .= s:getchar()
                              endif
                              if c =~ "\<Esc>" || c =~ "\<C-C>"
                                return ""
                              else
                                return c
                              endif
                            endfunction
                            
    1              0.000001 function! s:beep()
                              exe "norm! \<Esc>"
                              return ""
                            endfunction
                            
    1              0.000001 function! s:redraw()
                              redraw
                              return ""
                            endfunction
                            
                            " }}}1
                            
                            " Wrapping functions {{{1
                            
    1              0.000001 function! s:extractbefore(str)
                              if a:str =~ '\r'
                                return matchstr(a:str,'.*\ze\r')
                              else
                                return matchstr(a:str,'.*\ze\n')
                              endif
                            endfunction
                            
    1              0.000001 function! s:extractafter(str)
                              if a:str =~ '\r'
                                return matchstr(a:str,'\r\zs.*')
                              else
                                return matchstr(a:str,'\n\zs.*')
                              endif
                            endfunction
                            
    1              0.000001 function! s:fixindent(str,spc)
                              let str = substitute(a:str,'\t',repeat(' ',&sw),'g')
                              let spc = substitute(a:spc,'\t',repeat(' ',&sw),'g')
                              let str = substitute(str,'\(\n\|\%^\).\@=','\1'.spc,'g')
                              if ! &et
                                let str = substitute(str,'\s\{'.&ts.'\}',"\t",'g')
                              endif
                              return str
                            endfunction
                            
    1              0.000001 function! s:process(string)
                              let i = 0
                              for i in range(7)
                                let repl_{i} = ''
                                let m = matchstr(a:string,nr2char(i).'.\{-\}\ze'.nr2char(i))
                                if m != ''
                                  let m = substitute(strpart(m,1),'\r.*','','')
                                  let repl_{i} = input(match(m,'\w\+$') >= 0 ? m.': ' : m)
                                endif
                              endfor
                              let s = ""
                              let i = 0
                              while i < strlen(a:string)
                                let char = strpart(a:string,i,1)
                                if char2nr(char) < 8
                                  let next = stridx(a:string,char,i+1)
                                  if next == -1
                                    let s .= char
                                  else
                                    let insertion = repl_{char2nr(char)}
                                    let subs = strpart(a:string,i+1,next-i-1)
                                    let subs = matchstr(subs,'\r.*')
                                    while subs =~ '^\r.*\r'
                                      let sub = matchstr(subs,"^\r\\zs[^\r]*\r[^\r]*")
                                      let subs = strpart(subs,strlen(sub)+1)
                                      let r = stridx(sub,"\r")
                                      let insertion = substitute(insertion,strpart(sub,0,r),strpart(sub,r+1),'')
                                    endwhile
                                    let s .= insertion
                                    let i = next
                                  endif
                                else
                                  let s .= char
                                endif
                                let i += 1
                              endwhile
                              return s
                            endfunction
                            
    1              0.000001 function! s:wrap(string,char,type,removed,special)
                              let keeper = a:string
                              let newchar = a:char
                              let s:input = ""
                              let type = a:type
                              let linemode = type ==# 'V' ? 1 : 0
                              let before = ""
                              let after  = ""
                              if type ==# "V"
                                let initspaces = matchstr(keeper,'\%^\s*')
                              else
                                let initspaces = matchstr(getline('.'),'\%^\s*')
                              endif
                              let pairs = "b()B{}r[]a<>"
                              let extraspace = ""
                              if newchar =~ '^ '
                                let newchar = strpart(newchar,1)
                                let extraspace = ' '
                              endif
                              let idx = stridx(pairs,newchar)
                              if newchar == ' '
                                let before = ''
                                let after  = ''
                              elseif exists("b:surround_".char2nr(newchar))
                                let all    = s:process(b:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif exists("g:surround_".char2nr(newchar))
                                let all    = s:process(g:surround_{char2nr(newchar)})
                                let before = s:extractbefore(all)
                                let after  =  s:extractafter(all)
                              elseif newchar ==# "p"
                                let before = "\n"
                                let after  = "\n\n"
                              elseif newchar ==# 's'
                                let before = ' '
                                let after  = ''
                              elseif newchar ==# ':'
                                let before = ':'
                                let after = ''
                              elseif newchar =~# "[tT\<C-T><]"
                                let dounmapp = 0
                                let dounmapb = 0
                                if !maparg(">","c")
                                  let dounmapb = 1
                                  " Hide from AsNeeded
                                  exe "cn"."oremap > ><CR>"
                                endif
                                let default = ""
                                if newchar ==# "T"
                                  if !exists("s:lastdel")
                                    let s:lastdel = ""
                                  endif
                                  let default = matchstr(s:lastdel,'<\zs.\{-\}\ze>')
                                endif
                                let tag = input("<",default)
                                if dounmapb
                                  silent! cunmap >
                                endif
                                let s:input = tag
                                if tag != ""
                                  let keepAttributes = ( match(tag, ">$") == -1 )
                                  let tag = substitute(tag,'>*$','','')
                                  let attributes = ""
                                  if keepAttributes
                                    let attributes = matchstr(a:removed, '<[^ \t\n]\+\zs\_.\{-\}\ze>')
                                  endif
                                  let s:input = tag . '>'
                                  if tag =~ '/$'
                                    let tag = substitute(tag, '/$', '', '')
                                    let before = '<'.tag.attributes.' />'
                                    let after = ''
                                  else
                                    let before = '<'.tag.attributes.'>'
                                    let after  = '</'.substitute(tag,' .*','','').'>'
                                  endif
                                  if newchar == "\<C-T>"
                                    if type ==# "v" || type ==# "V"
                                      let before .= "\n\t"
                                    endif
                                    if type ==# "v"
                                      let after  = "\n". after
                                    endif
                                  endif
                                endif
                              elseif newchar ==# 'l' || newchar == '\'
                                " LaTeX
                                let env = input('\begin{')
                                if env != ""
                                  let s:input = env."\<CR>"
                                  let env = '{' . env
                                  let env .= s:closematch(env)
                                  echo '\begin'.env
                                  let before = '\begin'.env
                                  let after  = '\end'.matchstr(env,'[^}]*').'}'
                                endif
                              elseif newchar ==# 'f' || newchar ==# 'F'
                                let fnc = input('function: ')
                                if fnc != ""
                                  let s:input = fnc."\<CR>"
                                  let before = substitute(fnc,'($','','').'('
                                  let after  = ')'
                                  if newchar ==# 'F'
                                    let before .= ' '
                                    let after = ' ' . after
                                  endif
                                endif
                              elseif newchar ==# "\<C-F>"
                                let fnc = input('function: ')
                                let s:input = fnc."\<CR>"
                                let before = '('.fnc.' '
                                let after = ')'
                              elseif idx >= 0
                                let spc = (idx % 3) == 1 ? " " : ""
                                let idx = idx / 3 * 3
                                let before = strpart(pairs,idx+1,1) . spc
                                let after  = spc . strpart(pairs,idx+2,1)
                              elseif newchar == "\<C-[>" || newchar == "\<C-]>"
                                let before = "{\n\t"
                                let after  = "\n}"
                              elseif newchar !~ '\a'
                                let before = newchar
                                let after  = newchar
                              else
                                let before = ''
                                let after  = ''
                              endif
                              let after  = substitute(after ,'\n','\n'.initspaces,'g')
                              if type ==# 'V' || (a:special && type ==# "v")
                                let before = substitute(before,' \+$','','')
                                let after  = substitute(after ,'^ \+','','')
                                if after !~ '^\n'
                                  let after  = initspaces.after
                                endif
                                if keeper !~ '\n$' && after !~ '^\n'
                                  let keeper .= "\n"
                                elseif keeper =~ '\n$' && after =~ '^\n'
                                  let after = strpart(after,1)
                                endif
                                if keeper !~ '^\n' && before !~ '\n\s*$'
                                  let before .= "\n"
                                  if a:special
                                    let before .= "\t"
                                  endif
                                elseif keeper =~ '^\n' && before =~ '\n\s*$'
                                  let keeper = strcharpart(keeper,1)
                                endif
                                if type ==# 'V' && keeper =~ '\n\s*\n$'
                                  let keeper = strcharpart(keeper,0,strchars(keeper) - 1)
                                endif
                              endif
                              if type ==# 'V'
                                let before = initspaces.before
                              endif
                              if before =~ '\n\s*\%$'
                                if type ==# 'v'
                                  let keeper = initspaces.keeper
                                endif
                                let padding = matchstr(before,'\n\zs\s\+\%$')
                                let before  = substitute(before,'\n\s\+\%$','\n','')
                                let keeper = s:fixindent(keeper,padding)
                              endif
                              if type ==# 'V'
                                let keeper = before.keeper.after
                              elseif type =~ "^\<C-V>"
                                " Really we should be iterating over the buffer
                                let repl = substitute(before,'[\\~]','\\&','g').'\1'.substitute(after,'[\\~]','\\&','g')
                                let repl = substitute(repl,'\n',' ','g')
                                let keeper = substitute(keeper."\n",'\(.\{-\}\)\(\n\)',repl.'\n','g')
                                let keeper = substitute(keeper,'\n\%$','','')
                              else
                                let keeper = before.extraspace.keeper.extraspace.after
                              endif
                              return keeper
                            endfunction
                            
    1              0.000001 function! s:wrapreg(reg,char,removed,special)
                              let orig = getreg(a:reg)
                              let type = substitute(getregtype(a:reg),'\d\+$','','')
                              let new = s:wrap(orig,a:char,type,a:removed,a:special)
                              call setreg(a:reg,new,type)
                            endfunction
                            " }}}1
                            
    1              0.000001 function! s:insert(...) " {{{1
                              " Optional argument causes the result to appear on 3 lines, not 1
                              let linemode = a:0 ? a:1 : 0
                              let char = s:inputreplacement()
                              while char == "\<CR>" || char == "\<C-S>"
                                " TODO: use total count for additional blank lines
                                let linemode += 1
                                let char = s:inputreplacement()
                              endwhile
                              if char == ""
                                return ""
                              endif
                              let cb_save = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let reg_save = @@
                              call setreg('"',"\r",'v')
                              call s:wrapreg('"',char,"",linemode)
                              " If line mode is used and the surrounding consists solely of a suffix,
                              " remove the initial newline.  This fits a use case of mine but is a
                              " little inconsistent.  Is there anyone that would prefer the simpler
                              " behavior of just inserting the newline?
                              if linemode && match(getreg('"'),'^\n\s*\zs.*') == 0
                                call setreg('"',matchstr(getreg('"'),'^\n\s*\zs.*'),getregtype('"'))
                              endif
                              " This can be used to append a placeholder to the end
                              if exists("g:surround_insert_tail")
                                call setreg('"',g:surround_insert_tail,"a".getregtype('"'))
                              endif
                              if &ve != 'all' && col('.') >= col('$')
                                if &ve == 'insert'
                                  let extra_cols = virtcol('.') - virtcol('$')
                                  if extra_cols > 0
                                    let [regval,regtype] = [getreg('"',1,1),getregtype('"')]
                                    call setreg('"',join(map(range(extra_cols),'" "'),''),'v')
                                    norm! ""p
                                    call setreg('"',regval,regtype)
                                  endif
                                endif
                                norm! ""p
                              else
                                norm! ""P
                              endif
                              if linemode
                                call s:reindent()
                              endif
                              norm! `]
                              call search('\r','bW')
                              let @@ = reg_save
                              let &clipboard = cb_save
                              return "\<Del>"
                            endfunction " }}}1
                            
    1              0.000001 function! s:reindent() abort " {{{1
                              if get(b:, 'surround_indent', get(g:, 'surround_indent', 1)) && (!empty(&equalprg) || !empty(&indentexpr) || &cindent || &smartindent || &lisp)
                                silent norm! '[=']
                              endif
                            endfunction " }}}1
                            
    1              0.000001 function! s:dosurround(...) " {{{1
                              let scount = v:count1
                              let char = (a:0 ? a:1 : s:inputtarget())
                              let spc = ""
                              if char =~ '^\d\+'
                                let scount = scount * matchstr(char,'^\d\+')
                                let char = substitute(char,'^\d\+','','')
                              endif
                              if char =~ '^ '
                                let char = strpart(char,1)
                                let spc = 1
                              endif
                              if char == 'a'
                                let char = '>'
                              endif
                              if char == 'r'
                                let char = ']'
                              endif
                              let newchar = ""
                              if a:0 > 1
                                let newchar = a:2
                                if newchar == "\<Esc>" || newchar == "\<C-C>" || newchar == ""
                                  return s:beep()
                                endif
                              endif
                              let cb_save = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let append = ""
                              let original = getreg('"')
                              let otype = getregtype('"')
                              call setreg('"',"")
                              let strcount = (scount == 1 ? "" : scount)
                              if char == '/'
                                exe 'norm! '.strcount.'[/d'.strcount.']/'
                              elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>"''`]'
                                exe 'norm! T'.char
                                if getline('.')[col('.')-1] == char
                                  exe 'norm! l'
                                endif
                                exe 'norm! dt'.char
                              else
                                exe 'norm! d'.strcount.'i'.char
                              endif
                              let keeper = getreg('"')
                              let okeeper = keeper " for reindent below
                              if keeper == ""
                                call setreg('"',original,otype)
                                let &clipboard = cb_save
                                return ""
                              endif
                              let oldline = getline('.')
                              let oldlnum = line('.')
                              if char ==# "p"
                                call setreg('"','','V')
                              elseif char ==# "s" || char ==# "w" || char ==# "W"
                                " Do nothing
                                call setreg('"','')
                              elseif char =~ "[\"'`]"
                                exe "norm! i \<Esc>d2i".char
                                call setreg('"',substitute(getreg('"'),' ','',''))
                              elseif char == '/'
                                norm! "_x
                                call setreg('"','/**/',"c")
                                let keeper = substitute(substitute(keeper,'^/\*\s\=','',''),'\s\=\*$','','')
                              elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>]'
                                exe 'norm! F'.char
                                exe 'norm! df'.char
                              else
                                " One character backwards
                                call search('\m.', 'bW')
                                exe "norm! da".char
                              endif
                              let removed = getreg('"')
                              let rem2 = substitute(removed,'\n.*','','')
                              let oldhead = strpart(oldline,0,strlen(oldline)-strlen(rem2))
                              let oldtail = strpart(oldline,  strlen(oldline)-strlen(rem2))
                              let regtype = getregtype('"')
                              if char =~# '[\[({<T]' || spc
                                let keeper = substitute(keeper,'^\s\+','','')
                                let keeper = substitute(keeper,'\s\+$','','')
                              endif
                              if col("']") == col("$") && virtcol('.') + 1 == virtcol('$')
                                if oldhead =~# '^\s*$' && a:0 < 2
                                  let keeper = substitute(keeper,'\%^\n'.oldhead.'\(\s*.\{-\}\)\n\s*\%$','\1','')
                                endif
                                let pcmd = "p"
                              else
                                let pcmd = "P"
                              endif
                              if line('.') + 1 < oldlnum && regtype ==# "V"
                                let pcmd = "p"
                              endif
                              call setreg('"',keeper,regtype)
                              if newchar != ""
                                let special = a:0 > 2 ? a:3 : 0
                                call s:wrapreg('"',newchar,removed,special)
                              endif
                              silent exe 'norm! ""'.pcmd.'`['
                              if removed =~ '\n' || okeeper =~ '\n' || getreg('"') =~ '\n'
                                call s:reindent()
                              endif
                              if getline('.') =~ '^\s\+$' && keeper =~ '^\s*\n'
                                silent norm! cc
                              endif
                              call setreg('"',original,otype)
                              let s:lastdel = removed
                              let &clipboard = cb_save
                              if newchar == ""
                                silent! call repeat#set("\<Plug>Dsurround".char,scount)
                              else
                                silent! call repeat#set("\<Plug>C".(a:0 > 2 && a:3 ? "S" : "s")."urround".char.newchar.s:input,scount)
                              endif
                            endfunction " }}}1
                            
    1              0.000001 function! s:changesurround(...) " {{{1
                              let a = s:inputtarget()
                              if a == ""
                                return s:beep()
                              endif
                              let b = s:inputreplacement()
                              if b == ""
                                return s:beep()
                              endif
                              call s:dosurround(a,b,a:0 && a:1)
                            endfunction " }}}1
                            
    1              0.000001 function! s:opfunc(type, ...) abort " {{{1
                              if a:type ==# 'setup'
                                let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w\+$')
                                return 'g@'
                              endif
                              let char = s:inputreplacement()
                              if char == ""
                                return s:beep()
                              endif
                              let reg = '"'
                              let sel_save = &selection
                              let &selection = "inclusive"
                              let cb_save  = &clipboard
                              set clipboard-=unnamed clipboard-=unnamedplus
                              let reg_save = getreg(reg)
                              let reg_type = getregtype(reg)
                              let type = a:type
                              if a:type == "char"
                                silent exe 'norm! v`[o`]"'.reg.'y'
                                let type = 'v'
                              elseif a:type == "line"
                                silent exe 'norm! `[V`]"'.reg.'y'
                                let type = 'V'
                              elseif a:type ==# "v" || a:type ==# "V" || a:type ==# "\<C-V>"
                                let &selection = sel_save
                                let ve = &virtualedit
                                if !(a:0 && a:1)
                                  set virtualedit=
                                endif
                                silent exe 'norm! gv"'.reg.'y'
                                let &virtualedit = ve
                              elseif a:type =~ '^\d\+$'
                                let type = 'v'
                                silent exe 'norm! ^v'.a:type.'$h"'.reg.'y'
                                if mode() ==# 'v'
                                  norm! v
                                  return s:beep()
                                endif
                              else
                                let &selection = sel_save
                                let &clipboard = cb_save
                                return s:beep()
                              endif
                              let keeper = getreg(reg)
                              if type ==# "v" && a:type !=# "v"
                                let append = matchstr(keeper,'\_s\@<!\s*$')
                                let keeper = substitute(keeper,'\_s\@<!\s*$','','')
                              endif
                              call setreg(reg,keeper,type)
                              call s:wrapreg(reg,char,"",a:0 && a:1)
                              if type ==# "v" && a:type !=# "v" && append != ""
                                call setreg(reg,append,"ac")
                              endif
                              silent exe 'norm! gv'.(reg == '"' ? '' : '"' . reg).'p`['
                              if type ==# 'V' || (getreg(reg) =~ '\n' && type ==# 'v')
                                call s:reindent()
                              endif
                              call setreg(reg,reg_save,reg_type)
                              let &selection = sel_save
                              let &clipboard = cb_save
                              if a:type =~ '^\d\+$'
                                silent! call repeat#set("\<Plug>Y".(a:0 && a:1 ? "S" : "s")."surround".char.s:input,a:type)
                              else
                                silent! call repeat#set("\<Plug>SurroundRepeat".char.s:input)
                              endif
                            endfunction
                            
    1              0.000001 function! s:opfunc2(...) abort
                              if !a:0 || a:1 ==# 'setup'
                                let &opfunc = matchstr(expand('<sfile>'), '<SNR>\w\+$')
                                return 'g@'
                              endif
                              call s:opfunc(a:1, 1)
                            endfunction " }}}1
                            
    1              0.000001 function! s:closematch(str) " {{{1
                              " Close an open (, {, [, or < on the command line.
                              let tail = matchstr(a:str,'.[^\[\](){}<>]*$')
                              if tail =~ '^\[.\+'
                                return "]"
                              elseif tail =~ '^(.\+'
                                return ")"
                              elseif tail =~ '^{.\+'
                                return "}"
                              elseif tail =~ '^<.+'
                                return ">"
                              else
                                return ""
                              endif
                            endfunction " }}}1
                            
    1              0.000008 nnoremap <silent> <Plug>SurroundRepeat .
    1              0.000007 nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround(<SID>inputtarget())<CR>
    1              0.000005 nnoremap <silent> <Plug>Csurround  :<C-U>call <SID>changesurround()<CR>
    1              0.000004 nnoremap <silent> <Plug>CSurround  :<C-U>call <SID>changesurround(1)<CR>
    1              0.000004 nnoremap <expr>   <Plug>Yssurround '^'.v:count1.<SID>opfunc('setup').'g_'
    1              0.000004 nnoremap <expr>   <Plug>YSsurround <SID>opfunc2('setup').'_'
    1              0.000017 nnoremap <expr>   <Plug>Ysurround  <SID>opfunc('setup')
    1              0.000004 nnoremap <expr>   <Plug>YSurround  <SID>opfunc2('setup')
    1              0.000007 vnoremap <silent> <Plug>VSurround  :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 1 : 0)<CR>
    1              0.000006 vnoremap <silent> <Plug>VgSurround :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 0 : 1)<CR>
    1              0.000005 inoremap <silent> <Plug>Isurround  <C-R>=<SID>insert()<CR>
    1              0.000004 inoremap <silent> <Plug>ISurround  <C-R>=<SID>insert(1)<CR>
                            
    1              0.000003 if !exists("g:surround_no_mappings") || ! g:surround_no_mappings
    1              0.000004   nmap ds  <Plug>Dsurround
    1              0.000003   nmap cs  <Plug>Csurround
    1              0.000003   nmap cS  <Plug>CSurround
    1              0.000003   nmap ys  <Plug>Ysurround
    1              0.000003   nmap yS  <Plug>YSurround
    1              0.000003   nmap yss <Plug>Yssurround
    1              0.000003   nmap ySs <Plug>YSsurround
    1              0.000003   nmap ySS <Plug>YSsurround
    1              0.000004   xmap S   <Plug>VSurround
    1              0.000004   xmap gS  <Plug>VgSurround
    1              0.000002   if !exists("g:surround_no_insert_mappings") || ! g:surround_no_insert_mappings
    1              0.000009     if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")
    1              0.000004       imap    <C-S> <Plug>Isurround
    1              0.000001     endif
    1              0.000005     imap      <C-G>s <Plug>Isurround
    1              0.000003     imap      <C-G>S <Plug>ISurround
    1              0.000000   endif
    1              0.000000 endif
                            
                            " vim:set ft=vim sw=2 sts=2 et:

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-prettier/plugin/prettier.vim
Sourced 1 time
Total time:   0.000557
 Self time:   0.000557

count  total (s)   self (s)
                            " vim-prettier: A vim plugin wrapper for prettier, pre-configured with custom default prettier settings.
                            "
                            " Script Info  {{{
                            "==========================================================================================================
                            " Name Of File: prettier.vim
                            "  Description: A vim plugin wrapper for prettier, pre-configured with custom default prettier settings.
                            "   Maintainer: Mitermayer Reis <mitermayer.reis at gmail.com>
                            "      Version: 1.0.0-beta
                            "        Usage: Use :help vim-prettier-usage, or visit https://github.com/prettier/vim-prettier
                            "
                            "==========================================================================================================
                            " }}}
                            
    1              0.000003 if exists('g:loaded_prettier')
                              finish
    1              0.000000 endif
    1              0.000007 let g:loaded_prettier = 1
                            
                            " => Plugin config
                            " autoformating disabled by default upon saving
    1              0.000005 let g:prettier#autoformat = get(g:, 'prettier#autoformat', 0)
                            
                            " autoformating requires pragma by default
    1              0.000004 let g:prettier#autoformat_require_pragma = get(g:, 'prettier#autoformat_require_pragma', 1)
                            
                            " whether to turn autoformatting on if a prettier config file is found
    1              0.000004 let g:prettier#autoformat_config_present = get(g:, 'prettier#autoformat_config_present', 0)
                            
                            " prettier config files to search current directory and parent directories for
    1              0.000007 let g:prettier#autoformat_config_files = get(g:, 'prettier#autoformat_config_files', [
                                  \'.prettierrc',
                                  \'.prettierrc.yml',
                                  \'.prettierrc.yaml',
                                  \'.prettierrc.js',
                                  \'.prettierrc.config.js',
                                  \'.prettierrc.json',
                                  \'.prettierrc.toml'])
                            
                            " path to prettier cli
    1              0.000004 let g:prettier#exec_cmd_path = get(g:, 'prettier#exec_cmd_path', 0)
                            
                            " calling :Prettier by default runs synchronous
    1              0.000005 let g:prettier#exec_cmd_async = get(g:, 'prettier#exec_cmd_async', 0)
                            
                            " when having formatting errors will open the quickfix by default
    1              0.000004 let g:prettier#quickfix_enabled = get(g:, 'prettier#quickfix_enabled', 1)
                            
                            " Don't leave the quicklist focused on error.
    1              0.000003 let g:prettier#quickfix_auto_focus = get(g:, 'prettier#quickfix_auto_focus', 1)
                            
                            " Send to prettier entire buffer and use --range-start and --range-end as delimter
    1              0.000003 let g:prettier#partial_format = get(g:, 'prettier#partial_format', 0)
                            
                            " default|fb
                            " Use prettier defaults
    1              0.000003 let g:prettier#preset#config = get(g:,'prettier#preset#config', 'default')
                            
                            " => Prettier CLI config
                            " Max line length that prettier will wrap on: a number or 'auto' (use
                            " textwidth).
                            " default: 'auto'
                            " See more: https://prettier.io/docs/en/options.html#print-width
    1              0.000003 let g:prettier#config#print_width = get(g:, 'prettier#config#print_width', 'auto')
                            
                            " number of spaces per indentation level: a number or 'auto' (use
                            " softtabstop)
                            " default: 'auto'
                            " See more: https://prettier.io/docs/en/options.html#tab-width
    1              0.000003 let g:prettier#config#tab_width = get(g:,'prettier#config#tab_width', 'auto')
                            
                            " use tabs instead of spaces: true, false, or auto (use the expandtab setting).
                            " default: 'auto'
                            " See more: https://prettier.io/docs/en/options.html#tabs
    1              0.000003 let g:prettier#config#use_tabs = get(g:,'prettier#config#use_tabs', 'auto')
                            
                            " flow|babylon|typescript|css|less|scss|json|graphql|markdown or empty string
                            " (let prettier choose).
                            " default: ''
                            " See more: https://prettier.io/docs/en/options.html#parser
    1              0.000003 let g:prettier#config#parser = get(g:,'prettier#config#parser', '')
                            
                            " cli-override|file-override|prefer-file
                            " default: 'file-override'
                            " See more: https://prettier.io/docs/en/cli.html#--config-precedence
    1              0.000004 let g:prettier#config#config_precedence = get(g:, 'prettier#config#config_precedence', 'file-override')
                            
                            " always|never|preserve
                            " default: 'preserve'
                            " See more: https://prettier.io/docs/en/options.html#prose-wrap
    1              0.000003 let g:prettier#config#prose_wrap = get(g:, 'prettier#config#prose_wrap', 'preserve')
                            
                            " css|strict|ignore
                            " default: 'css'
                            " See more: https://prettier.io/docs/en/options.html#html-whitespace-sensitivity
    1              0.000004 let g:prettier#config#html_whitespace_sensitivity = get(g:, 'prettier#config#html_whitespace_sensitivity', 'css')
                            
                            " print semicolons
                            " default: 'true'
                            " See more: https://prettier.io/docs/en/options.html#semicolons
    1              0.000005 let g:prettier#config#semi = get(g:,'prettier#config#semi', 'true')
                            
                            " Use single quotes instead of double quotes.
                            " default: 'false'
                            " See more: https://prettier.io/docs/en/options.html#quotes
    1              0.000007 let g:prettier#config#single_quote = get(g:,'prettier#config#single_quote', 'false')
                            
                            " print spaces between brackets
                            " default: 'true'
                            " See more: https://prettier.io/docs/en/options.html#bracket-spacing
    1              0.000004 let g:prettier#config#bracket_spacing = get(g:,'prettier#config#bracket_spacing', 'true')
                            
                            " put > on the last line instead of new line
                            " default: 'false'
                            " See more: https://prettier.io/docs/en/options.html#jsx-brackets
    1              0.000004 let g:prettier#config#jsx_bracket_same_line = get(g:,'prettier#config#jsx_bracket_same_line', 'false')
                            
                            " avoid wrapping a single arrow function param in parens
                            " avoid|always
                            " default: 'always'
                            " See more: https://prettier.io/docs/en/options.html#arrow-function-parentheses
    1              0.000004 let g:prettier#config#arrow_parens = get(g:,'prettier#config#arrow_parens', 'always')
                            
                            " Define the flavor of line endings
                            " lf|crlf|cr|all
                            " defaut: 'lf' 
    1              0.000004 let g:prettier#config#end_of_line = get(g:, 'prettier#config#end_of_line', 'lf')
                            
                            " Print trailing commas wherever possible when multi-line.
                            " none|es5|all
                            " default: 'es5'
                            " See more: https://prettier.io/docs/en/options.html#trailing-commas
    1              0.000003 let g:prettier#config#trailing_comma = get(g:,'prettier#config#trailing_comma', 'es5')
                            
                            " restrict itself to only format files that contain a special comment @prettier or @format
                            " See more: https://prettier.io/docs/en/options.html#require-pragma
    1              0.000004 let g:prettier#config#require_pragma=  get(g:, 'prettier#config#require_pragma', 'false')
                            
                            " synchronous by default
    1              0.000007 command! -nargs=? -range=% Prettier call prettier#Prettier(g:prettier#exec_cmd_async, <line1>, <line2>, g:prettier#partial_format)
                            
                            " prettier async
    1              0.000005 command! -nargs=? -range=% PrettierAsync call prettier#Prettier(1, <line1>, <line2>, g:prettier#partial_format)
                            
                            " prints vim-prettier version
    1              0.000002 command! -nargs=? -range=% PrettierVersion echom '1.0.0-beta'
                            
                            " call prettier cli
    1              0.000003 command! -nargs=? -range=% PrettierCli call prettier#PrettierCli(<q-args>)
                            
                            " call prettier cli to get its version
    1              0.000004 command! -nargs=? -range=% PrettierCliVersion call prettier#PrettierCli('--version')
                            
                            " prints prettier resolved cli path
    1              0.000002 command! -nargs=? -range=% PrettierCliPath call prettier#PrettierCliPath()
                            
                            " sends selected text to prettier cli for formatting
    1              0.000005 command! -nargs=? -range=% PrettierFragment call prettier#Prettier(g:prettier#exec_cmd_async, <line1>, <line2>, 0)
                            
                            " sends entire buffer to prettier cli but format just selection 
    1              0.000004 command! -nargs=? -range=% PrettierPartial call prettier#Prettier(g:prettier#exec_cmd_async, <line1>, <line2>, 1)
                            
                            " map command
    1              0.000015 if !hasmapto('<Plug>(Prettier)') && maparg('<Leader>p', 'n') ==# ''
    1              0.000006   nmap <unique> <Leader>p <Plug>(Prettier)
    1              0.000001 endif
    1              0.000004 nnoremap <silent> <Plug>(Prettier) :Prettier<CR>
    1              0.000004 nnoremap <silent> <Plug>(PrettierAsync) :PrettierAsync<CR>
    1              0.000005 nnoremap <silent> <Plug>(PrettierFragment) :PrettierFragment<CR>
    1              0.000004 nnoremap <silent> <Plug>(PrettierPartial) :PrettierPartial<CR>
    1              0.000004 nnoremap <silent> <Plug>(PrettierVersion) :PrettierVersion<CR>
    1              0.000003 nnoremap <silent> <Plug>(PrettierCli) :PrettierCli<CR>
    1              0.000004 nnoremap <silent> <Plug>(PrettierCliVersion) :PrettierCliVersion<CR>
    1              0.000004 nnoremap <silent> <Plug>(PrettierCliPath) :PrettierCliPath<CR>
                            
    1              0.000001 augroup Prettier
    1              0.000262   autocmd!
    1              0.000027   autocmd BufWritePre *.js,*.jsx,*.mjs,*.ts,*.tsx,*.css,*.less,*.scss,*.json,*.graphql,*.gql,*.markdown,*.md,*.mdown,*.mkd,*.mkdn,*.mdx,*.vue,*.svelte,*.yml,*.yaml,*.html,*.php,*.rb,*.ruby,*.xml noautocmd call prettier#Autoformat()
    1              0.000017 augroup end

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-signature/plugin/signature.vim
Sourced 1 time
Total time:   0.001491
 Self time:   0.000825

count  total (s)   self (s)
                            " vim: fdm=marker:et:ts=4:sw=2:sts=2
                            
                            " Description: vim-signature is a plugin to toggle, display and navigate marks.
                            "
                            " Maintainer: Kartik Shenoy
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            " Exit if the signs feature is not available or if the app has already been loaded (or "compatible" mode set)
    1              0.000011 if !has('signs') || &cp
                              finish
    1              0.000001 endif
    1              0.000002 if exists('g:loaded_Signature')
                              finish
    1              0.000000 endif
    1              0.000005 let g:loaded_Signature = 1
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            "" Global variables                                                                                                 {{{1
                            "
    1   0.000515   0.000369 call signature#utils#Set('g:SignaturePrioritizeMarks',         1                                                     )
    1   0.000021   0.000007 call signature#utils#Set('g:SignatureIncludeMarks',            'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
    1   0.000014   0.000004 call signature#utils#Set('g:SignatureIncludeMarkers',          ')!@#$%^&*('                                          )
    1   0.000013   0.000004 call signature#utils#Set('g:SignatureMarkTextHL',              "SignatureMarkText"                                   )
    1   0.000011   0.000004 call signature#utils#Set('g:SignatureMarkTextHLDynamic',       0                                                     )
    1   0.000010   0.000003 call signature#utils#Set('g:SignatureMarkLineHL',              "SignatureMarkLine"                                   )
    1   0.000010   0.000003 call signature#utils#Set('g:SignatureMarkerTextHL',            "SignatureMarkerText"                                 )
    1   0.000010   0.000003 call signature#utils#Set('g:SignatureMarkerTextHLDynamic',     0                                                     )
    1   0.000010   0.000003 call signature#utils#Set('g:SignatureMarkerLineHL',            "SignatureMarkerLine"                                 )
    1   0.000010   0.000003 call signature#utils#Set('g:SignatureWrapJumps',               1                                                     )
    1   0.000010   0.000003 call signature#utils#Set('g:SignatureMarkOrder',               "\p\m"                                                )
    1   0.000010   0.000003 call signature#utils#Set('g:SignatureDeleteConfirmation',      0                                                     )
    1   0.000010   0.000003 call signature#utils#Set('g:SignaturePurgeConfirmation',       0                                                     )
    1   0.000009   0.000003 call signature#utils#Set('g:SignaturePeriodicRefresh',         1                                                     )
    1   0.000009   0.000003 call signature#utils#Set('g:SignatureEnabledAtStartup',        1                                                     )
    1   0.000009   0.000003 call signature#utils#Set('g:SignatureDeferPlacement',          1                                                     )
    1   0.000009   0.000003 call signature#utils#Set('g:SignatureRecycleMarks',            0                                                     )
    1   0.000011   0.000004 call signature#utils#Set('g:SignatureErrorIfNoAvailableMarks', 1                                                     )
    1   0.000009   0.000003 call signature#utils#Set('g:SignatureForceRemoveGlobal',       0                                                     )
    1   0.000009   0.000003 call signature#utils#Set('g:SignatureForceMarkPlacement',      0                                                     )
    1   0.000009   0.000003 call signature#utils#Set('g:SignatureForceMarkerPlacement',    0                                                     )
    1   0.000011   0.000004 call signature#utils#Set('g:SignatureMap',                     {}                                                    )
                            
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            "" Commands, Autocmds and Maps                                                                                      {{{1
                            "
    1   0.000369   0.000004 call signature#utils#Maps('create')
                            
    1              0.000002 if has('autocmd')
    1              0.000002   augroup sig_autocmds
    1              0.000268     autocmd!
                            
                                " This needs to be called upon loading a colorscheme
                                " VimEnter is kind of a backup if no colorscheme is explicitly loaded and the default is used
    1              0.000008     autocmd VimEnter,ColorScheme * call signature#utils#SetupHighlightGroups()
                            
                                " This is required to remove signs for global marks that were removed when in another window
    1              0.000004     autocmd BufEnter,CmdwinEnter * call signature#sign#Refresh()
                            
    1              0.000004     autocmd CursorHold * if (g:SignaturePeriodicRefresh) | call signature#sign#Refresh() | endif
    1              0.000001   augroup END
    1              0.000000 endif
                            
    1              0.000004 command! -nargs=0 SignatureToggleSigns     call signature#utils#Toggle()
    1              0.000003 command! -nargs=0 SignatureRefresh         call signature#sign#Refresh(1)
    1              0.000003 command! -nargs=? SignatureListBufferMarks call signature#mark#List(0, <args>)
    1              0.000003 command! -nargs=? SignatureListGlobalMarks call signature#mark#List(1, <args>)
    1              0.000014 command! -nargs=* SignatureListMarkers     call signature#marker#List(<args>)

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-signature/autoload/signature/utils.vim
Sourced 1 time
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
                            " vim: fdm=marker:et:ts=4:sw=2:sts=2
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 function! signature#utils#Set(var, value, ...)                                                                    " {{{1
                              " Description: Assign value to var if var is unset or if an optional 3rd arg is provided to force
                            
                              if (!exists(a:var) || a:0 && a:1)
                                if type(a:value)
                                  execute 'let' a:var '=' string(a:value)
                                else
                                  execute 'let' a:var '=' a:value
                                endif
                              endif
                              return a:var
                            endfunction
                            
                            
    1              0.000002 function! signature#utils#NumericSort(x, y)                                                                       " {{{1
                              return a:x - a:y
                            endfunction
                            
                            
    1              0.000003 function! s:Map(mode, key, map_lhs_default, map_rhs)                                                              " {{{1
                              let l:map_lhs = get(g:SignatureMap, a:key, a:map_lhs_default)
                              if (l:map_lhs ==? '')
                                return
                              endif
                              if (a:mode ==? 'create')
                                silent! execute 'nnoremap <silent> <unique> ' . l:map_lhs . ' ' . ':<C-U>call signature#' . a:map_rhs . '<CR>'
                              elseif (a:mode ==? 'remove')
                                silent! execute 'nunmap ' . l:map_lhs
                              endif
                            endfunction
                            
    1              0.000001 function! signature#utils#Maps(mode)                                                                              " {{{1
                              " We create separate mappings for PlaceNextMark, mark#Purge('all') and PurgeMarkers instead of combining it with
                              " Leader/Input as if the user chooses to use some weird key like <BS> or <CR> for any of these 3, we need to be able
                              " to identify it. Eg. the nr2char(getchar()) will fail if the user presses a <BS>
                              let l:SignatureMapLeader = get(g:SignatureMap, 'Leader', 'm')
                              if (l:SignatureMapLeader == "")
                                echoe "Signature: g:SignatureMap.Leader shouldn't be left blank"
                              endif
                              call s:Map(a:mode, 'Leader'           , l:SignatureMapLeader            , 'utils#Input()'                       )
                              call s:Map(a:mode, 'PlaceNextMark'    , l:SignatureMapLeader . ","      , 'mark#Toggle("next")'                 )
                              call s:Map(a:mode, 'ToggleMarkAtLine' , l:SignatureMapLeader . "."      , 'mark#ToggleAtLine()'                 )
                              call s:Map(a:mode, 'PurgeMarksAtLine' , l:SignatureMapLeader . "-"      , 'mark#Purge("line")'                  )
                              call s:Map(a:mode, 'PurgeMarks'       , l:SignatureMapLeader . "<Space>", 'mark#Purge("all")'                   )
                              call s:Map(a:mode, 'PurgeMarkers'     , l:SignatureMapLeader . "<BS>"   , 'marker#Purge()'                      )
                              call s:Map(a:mode, 'DeleteMark'       , "dm"                            , 'utils#Remove(v:count)'               )
                              call s:Map(a:mode, 'GotoNextLineAlpha', "']"                            , 'mark#Goto("next", "line", "alpha")'  )
                              call s:Map(a:mode, 'GotoPrevLineAlpha', "'["                            , 'mark#Goto("prev", "line", "alpha")'  )
                              call s:Map(a:mode, 'GotoNextSpotAlpha', "`]"                            , 'mark#Goto("next", "spot", "alpha")'  )
                              call s:Map(a:mode, 'GotoPrevSpotAlpha', "`["                            , 'mark#Goto("prev", "spot", "alpha")'  )
                              call s:Map(a:mode, 'GotoNextLineByPos', "]'"                            , 'mark#Goto("next", "line", "pos")'    )
                              call s:Map(a:mode, 'GotoPrevLineByPos', "['"                            , 'mark#Goto("prev", "line", "pos")'    )
                              call s:Map(a:mode, 'GotoNextSpotByPos', "]`"                            , 'mark#Goto("next", "spot", "pos")'    )
                              call s:Map(a:mode, 'GotoPrevSpotByPos', "[`"                            , 'mark#Goto("prev", "spot", "pos")'    )
                              call s:Map(a:mode, 'GotoNextMarker'   , "]-"                            , 'marker#Goto("next", "same", v:count)')
                              call s:Map(a:mode, 'GotoPrevMarker'   , "[-"                            , 'marker#Goto("prev", "same", v:count)')
                              call s:Map(a:mode, 'GotoNextMarkerAny', "]="                            , 'marker#Goto("next", "any",  v:count)')
                              call s:Map(a:mode, 'GotoPrevMarkerAny', "[="                            , 'marker#Goto("prev", "any",  v:count)')
                              call s:Map(a:mode, 'ListBufferMarks'  , 'm/'                            , 'mark#List(0, 0)'                     )
                              call s:Map(a:mode, 'ListBufferMarkers', 'm?'                            , 'marker#List(v:count, 0)'             )
                            endfunction
                            
                            
    1              0.000001 function! signature#utils#Input()                                                                                 " {{{1
                              " Description: Grab input char
                            
                              if &ft ==# "netrw"
                                " Workaround for #104
                                return
                              endif
                            
                              " Obtain input from user ...
                              let l:in = nr2char(getchar())
                            
                              " ... if the input is not a number eg. '!' ==> Delete all '!' markers
                              if signature#utils#IsValidMarker(l:in)
                                return signature#marker#Purge(l:in)
                              endif
                            
                              " ... but if input is a number, convert it to corresponding marker before proceeding
                              if match(l:in, '\d') >= 0
                                let l:char = signature#utils#GetChar(b:SignatureIncludeMarkers, l:in)
                              else
                                let l:char = l:in
                              endif
                            
                              if signature#utils#IsValidMarker(l:char)
                                return signature#marker#Toggle(l:char)
                              elseif signature#utils#IsValidMark(l:char)
                                return signature#mark#Toggle(l:char)
                              else
                                " l:char is probably one of `'[]<> or a space from the gap in b:SignatureIncludeMarkers
                                execute 'normal! m' . l:in
                              endif
                            endfunction
                            
                            
    1              0.000001 function! signature#utils#Remove(lnum)                                                                            " {{{1
                              " Description: Obtain mark or marker from the user and remove it.
                              "              There can be multiple markers of the same type on different lines. If a line no. is provided
                              "              (non-zero), delete the marker from the specified line else delete it from the current line
                              "              NOTE: lnum is meaningless for a mark and will be ignored
                              " Arguments:   lnum - Line no. to delete the marker from
                            
                              let l:char = nr2char(getchar())
                            
                              if (l:char =~ '^\d$')
                                let l:lnum = (a:lnum == 0 ? line('.') : a:lnum)
                                let l:char = split(b:SignatureIncludeMarkers, '\zs')[l:char]
                                call signature#marker#Remove(lnum, l:char)
                              elseif (l:char =~? '^[a-z]$')
                                call signature#mark#Remove(l:char)
                              endif
                            endfunction
                            
                            
    1              0.000001 function! signature#utils#Toggle()                                                                                " {{{1
                              " Description: Toggles and refreshes sign display in the buffer.
                            
                              let b:sig_enabled = !b:sig_enabled
                            
                              if b:sig_enabled
                                " Signature enabled ==> Refresh signs
                                call signature#sign#Refresh()
                            
                                " Add signs for markers ...
                                for i in keys(b:sig_markers)
                                  call signature#sign#Place(b:sig_markers[i], i)
                                endfor
                              else
                                " Signature disabled ==> Remove signs
                                for l:lnum in keys(b:sig_markers)
                                  call signature#sign#Unplace(l:lnum)
                                endfor
                                for l:lnum in keys(b:sig_marks)
                                  call signature#sign#Unplace(l:lnum)
                                endfor
                                " Force removal. Simply toggling doesn't work as we check whether b:sig_markers and b:sig_marks are empty before
                                " removing the dummy and b:sig_markers won't be empty
                                call signature#sign#ToggleDummy(0)
                                unlet b:sig_marks
                              endif
                            endfunction
                            
                            
    1              0.000001 function! signature#utils#SetupHighlightGroups()                                                                  " {{{1
                              " Description: Sets up the highlight groups
                            
                              function! CheckAndSetHL(curr_hl, prefix, attr, targ_color)
                                let l:curr_color = synIDattr(synIDtrans(hlID(a:curr_hl)), a:attr, a:prefix)
                            
                                if (  (  (l:curr_color == "")
                                 \    || (l:curr_color  < 0)
                                 \    )
                                 \ && (a:targ_color != "")
                                 \ && (a:targ_color >= 0)
                                 \ )
                                  " echom "DEBUG: HL=" . a:curr_hl . " (" . a:prefix . a:attr . ") Curr=" . l:curr_color . ", To=" . a:targ_color
                                  execute 'highlight ' . a:curr_hl . ' ' . a:prefix . a:attr . '=' . a:targ_color
                                endif
                              endfunction
                            
                              let l:prefix = (has('gui_running') || (has('termguicolors') && &termguicolors) ? 'gui' : 'cterm')
                              let l:sign_col_color = synIDattr(synIDtrans(hlID('SignColumn')), 'bg', l:prefix)
                            
                              call CheckAndSetHL('SignatureMarkText',   l:prefix, 'fg', 'Red')
                              call CheckAndSetHL('SignatureMarkText',   l:prefix, 'bg', l:sign_col_color)
                              call CheckAndSetHL('SignatureMarkerText', l:prefix, 'fg', 'Green')
                              call CheckAndSetHL('SignatureMarkerText', l:prefix, 'bg', l:sign_col_color)
                            
                              delfunction CheckAndSetHL
                            endfunction
                            
                            
    1              0.000001 function! signature#utils#IsValidMark(mark)                                                                       " {{{1
                              return (b:SignatureIncludeMarks =~# a:mark)
                            endfunction
                            
                            
    1              0.000001 function! signature#utils#IsValidMarker(marker)                                                                   " {{{1
                              return (  (b:SignatureIncludeMarkers =~# a:marker)
                                     \ && (a:marker != ' ')
                                     \ )
                            endfunction
                            
                            
    1              0.000001 function! signature#utils#GetChar(string, pos)                                                                    " {{{1
                              if a:pos > strchars(a:string) - 1 | return "" | endif
                              let pattern = '.\{-' . a:pos . '}\(.\).*'
                              return substitute(a:string, pattern, '\1', '')
                            endfunction
                            

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-sneak/plugin/sneak.vim
Sourced 1 time
Total time:   0.001839
 Self time:   0.001752

count  total (s)   self (s)
                            " sneak.vim - The missing motion
                            " Author:       Justin M. Keyes
                            " Version:      1.8
                            " License:      MIT
                            
    1              0.000008 if exists('g:loaded_sneak_plugin') || &compatible || v:version < 700
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_sneak_plugin = 1
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
                            " Persist state for repeat.
                            "     opfunc    : &operatorfunc at g@ invocation.
                            "     opfunc_st : State during last 'operatorfunc' (g@) invocation.
    1              0.000007 let s:st = { 'rst':1, 'input':'', 'inputlen':0, 'reverse':0, 'bounds':[0,0],
                                  \'inclusive':0, 'label':'', 'opfunc':'', 'opfunc_st':{} }
                            
    1              0.000002 if exists('##OptionSet')
    1              0.000001   augroup sneak_optionset
    1              0.000239     autocmd!
    1              0.000005     autocmd OptionSet operatorfunc let s:st.opfunc = &operatorfunc | let s:st.opfunc_st = {}
    1              0.000001   augroup END
    1              0.000000 endif
                            
    1              0.000002 func! sneak#init() abort
                              unlockvar g:sneak#opt
                              "options                                 v-- for backwards-compatibility
                              let g:sneak#opt = { 'f_reset' : get(g:, 'sneak#nextprev_f', get(g:, 'sneak#f_reset', 1))
                                  \ ,'t_reset'      : get(g:, 'sneak#nextprev_t', get(g:, 'sneak#t_reset', 1))
                                  \ ,'s_next'       : get(g:, 'sneak#s_next', 0)
                                  \ ,'absolute_dir' : get(g:, 'sneak#absolute_dir', 0)
                                  \ ,'use_ic_scs'   : get(g:, 'sneak#use_ic_scs', 0)
                                  \ ,'map_netrw'    : get(g:, 'sneak#map_netrw', 1)
                                  \ ,'label'        : get(g:, 'sneak#label', get(g:, 'sneak#streak', 0)) && (v:version >= 703) && has("conceal")
                                  \ ,'label_esc'    : get(g:, 'sneak#label_esc', get(g:, 'sneak#streak_esc', "\<space>"))
                                  \ ,'prompt'       : get(g:, 'sneak#prompt', '>')
                                  \ }
                            
                              for k in ['f', 't'] "if user mapped f/t to Sneak, then disable f/t reset.
                                if maparg(k, 'n') =~# 'Sneak'
                                  let g:sneak#opt[k.'_reset'] = 0
                                endif
                              endfor
                              lockvar g:sneak#opt
                            endf
                            
    1   0.000871   0.000784 call sneak#init()
                            
    1              0.000002 func! sneak#state() abort
                              return deepcopy(s:st)
                            endf
                            
    1              0.000001 func! sneak#is_sneaking() abort
                              return exists("#sneak#CursorMoved")
                            endf
                            
    1              0.000001 func! sneak#cancel() abort
                              call sneak#util#removehl()
                              augroup sneak
                                autocmd!
                              augroup END
                              if maparg('<esc>', 'n') =~# "'s'\\.'neak#cancel'"  " Remove temporary mapping.
                                silent! unmap <esc>
                              endif
                              return ''
                            endf
                            
                            " Entrypoint for `s`.
    1              0.000003 func! sneak#wrap(op, inputlen, reverse, inclusive, label) abort
                              let [cnt, reg] = [v:count1, v:register] "get count and register before doing _anything_, else they get overwritten.
                              let is_similar_invocation = a:inputlen == s:st.inputlen && a:inclusive == s:st.inclusive
                            
                              if g:sneak#opt.s_next && is_similar_invocation && (sneak#util#isvisualop(a:op) || empty(a:op)) && sneak#is_sneaking()
                                " Repeat motion (clever-s).
                                call s:rpt(a:op, a:reverse)
                              elseif a:op ==# 'g@' && !empty(s:st.opfunc_st) && !empty(s:st.opfunc) && s:st.opfunc ==# &operatorfunc
                                " Replay state from the last 'operatorfunc'.
                                call sneak#to(a:op, s:st.opfunc_st.input, s:st.opfunc_st.inputlen, cnt, reg, 1, s:st.opfunc_st.reverse, s:st.opfunc_st.inclusive, s:st.opfunc_st.label)
                              else
                                if exists('#User#SneakEnter')
                                  doautocmd <nomodeline> User SneakEnter
                                  redraw
                                endif
                                " Prompt for input.
                                call sneak#to(a:op, s:getnchars(a:inputlen, a:op), a:inputlen, cnt, reg, 0, a:reverse, a:inclusive, a:label)
                                if exists('#User#SneakLeave')
                                  doautocmd <nomodeline> User SneakLeave
                                endif
                              endif
                            endf
                            
                            " Repeats the last motion.
    1              0.000003 func! s:rpt(op, reverse) abort
                              if s:st.rst "reset by f/F/t/T
                                exec "norm! ".(sneak#util#isvisualop(a:op) ? "gv" : "").v:count1.(a:reverse ? "," : ";")
                                return
                              endif
                            
                              let l:relative_reverse = (a:reverse && !s:st.reverse) || (!a:reverse && s:st.reverse)
                              call sneak#to(a:op, s:st.input, s:st.inputlen, v:count1, v:register, 1,
                                    \ (g:sneak#opt.absolute_dir ? a:reverse : l:relative_reverse), s:st.inclusive, 0)
                            endf
                            
                            " input:      may be shorter than inputlen if the user pressed <enter> at the prompt.
                            " inclusive:  0: t-like, 1: f-like, 2: /-like
    1              0.000002 func! sneak#to(op, input, inputlen, count, register, repeatmotion, reverse, inclusive, label) abort "{{{
                              if empty(a:input) "user canceled
                                if a:op ==# 'c'  " user <esc> during change-operation should return to previous mode.
                                  call feedkeys((col('.') > 1 && col('.') < col('$') ? "\<RIGHT>" : '') . "\<C-\>\<C-G>", 'n')
                                endif
                                redraw | echo '' | return
                              endif
                            
                              let is_v  = sneak#util#isvisualop(a:op)
                              let [curlin, curcol] = [line('.'), virtcol('.')] "initial position
                              let is_op = !empty(a:op) && !is_v "operator-pending invocation
                              let s = g:sneak#search#instance
                              call s.init(a:input, a:repeatmotion, a:reverse)
                            
                              if is_v && a:repeatmotion
                                norm! gv
                              endif
                            
                              " [count] means 'skip to this match' _only_ for operators/repeat-motion/1-char-search
                              "   sanity check: max out at 999, to avoid searchpos() OOM.
                              let skip = (is_op || a:repeatmotion || a:inputlen < 2) ? min([999, a:count]) : 0
                            
                              let l:gt_lt = a:reverse ? '<' : '>'
                              let bounds = a:repeatmotion ? s:st.bounds : [0,0] " [left_bound, right_bound]
                              let l:scope_pattern = '' " pattern used to highlight the vertical 'scope'
                              let l:match_bounds  = ''
                            
                              "scope to a column of width 2*(v:count1)+1 _except_ for operators/repeat-motion/1-char-search
                              if ((!skip && a:count > 1) || max(bounds)) && !is_op
                                if !max(bounds) "derive bounds from count (_logical_ bounds highlighted in 'scope')
                                  let bounds[0] = max([0, (virtcol('.') - a:count - 1)])
                                  let bounds[1] = a:count + virtcol('.') + 1
                                endif
                                "Match *all* chars in scope. Use \%<42v (virtual column) instead of \%<42c (byte column).
                                let l:scope_pattern .= '\%>'.bounds[0].'v\%<'.bounds[1].'v'
                              endif
                            
                              if max(bounds)
                                "adjust logical left-bound for the _match_ pattern by -length(s) so that if _any_
                                "char is within the logical bounds, it is considered a match.
                                let l:leftbound = max([0, (bounds[0] - a:inputlen) + 1])
                                let l:match_bounds   = '\%>'.l:leftbound.'v\%<'.bounds[1].'v'
                                let s.match_pattern .= l:match_bounds
                              endif
                            
                              "TODO: refactor vertical scope calculation into search.vim,
                              "      so this can be done in s.init() instead of here.
                              call s.initpattern()
                            
                              let s:st.rptreverse = a:reverse
                              if !a:repeatmotion "this is a new (not repeat) invocation
                                "persist even if the search fails, because the _reverse_ direction might have a match.
                                let s:st.rst = 0 | let s:st.input = a:input | let s:st.inputlen = a:inputlen
                                let s:st.reverse = a:reverse | let s:st.bounds = bounds | let s:st.inclusive = a:inclusive
                            
                                " Set temporary hooks on f/F/t/T so that we know when to reset Sneak.
                                call s:ft_hook()
                              endif
                            
                              let nextchar = searchpos('\_.', 'n'.(s.search_options_no_s))
                              let nudge = !a:inclusive && a:repeatmotion && nextchar == s.dosearch('n')
                              if nudge
                                let nudge = sneak#util#nudge(!a:reverse) "special case for t
                              endif
                            
                              for i in range(1, max([1, skip])) "jump to the [count]th match
                                let matchpos = s.dosearch()
                                if 0 == max(matchpos)
                                  break
                                else
                                  let nudge = !a:inclusive
                                endif
                              endfor
                            
                              if 0 == max(matchpos)
                                if nudge
                                  call sneak#util#nudge(a:reverse) "undo nudge for t
                                endif
                            
                                let km = empty(&keymap) ? '' : ' ('.&keymap.' keymap)'
                                call sneak#util#echo('not found'.(max(bounds) ? printf(km.' (in columns %d-%d): %s', bounds[0], bounds[1], a:input) : km.': '.a:input))
                                return
                              endif
                              "search succeeded
                            
                              call sneak#util#removehl()
                            
                              if (!is_op || a:op ==# 'y') "position _after_ search
                                let curlin = string(line('.'))
                                let curcol = string(virtcol('.') + (a:reverse ? -1 : 1))
                              endif
                            
                              "Might as well scope to window height (+/- 99).
                              let l:top = max([0, line('w0')-99])
                              let l:bot = line('w$')+99
                              let l:restrict_top_bot = '\%'.l:gt_lt.curlin.'l\%>'.l:top.'l\%<'.l:bot.'l'
                              let l:scope_pattern .= l:restrict_top_bot
                              let s.match_pattern .= l:restrict_top_bot
                              let curln_pattern  = l:match_bounds.'\%'.curlin.'l\%'.l:gt_lt.curcol.'v'
                            
                              "highlight the vertical 'tunnel' that the search is scoped-to
                              if max(bounds) "perform the scoped highlight...
                                let w:sneak_sc_hl = matchadd('SneakScope', l:scope_pattern)
                              endif
                            
                              call s:attach_autocmds()
                            
                              "highlight actual matches at or beyond the cursor position
                              "  - store in w: because matchadd() highlight is per-window.
                              let w:sneak_hl_id = matchadd('Sneak',
                                    \ (s.prefix).(s.match_pattern).(s.search).'\|'.curln_pattern.(s.search))
                            
                              " Clear with <esc>. Use a funny mapping to avoid false positives. #287
                              if (has('nvim') || has('gui_running')) && maparg('<esc>', 'n') ==# ""
                                nnoremap <expr> <silent> <esc> call('s'.'neak#cancel',[]) . "\<esc>"
                              endif
                            
                              " Operators always invoke label-mode.
                              " If a:label is a string set it as the target, without prompting.
                              let label = a:label !~# '[012]' ? a:label : ''
                              let target = (2 == a:label || !empty(label) || (a:label && g:sneak#opt.label && (is_op || s.hasmatches(1)))) && !max(bounds)
                                    \ ? sneak#label#to(s, is_v, label) : ""
                            
                              if nudge
                                call sneak#util#nudge(a:reverse) "undo nudge for t
                              endif
                            
                              if is_op && 2 != a:inclusive && !a:reverse
                                " f/t operations do not apply to the current character; nudge the cursor.
                                call sneak#util#nudge(1)
                              endif
                            
                              if is_op || '' != target
                                call sneak#util#removehl()
                              endif
                            
                              if is_op && a:op !=# 'y'
                                let change = a:op !=? "c" ? "" : "\<c-r>.\<esc>"
                                let seq = a:op."\<Plug>SneakRepeat".sneak#util#strlen(a:input).a:reverse.a:inclusive.(2*!empty(target)).a:input.target.change
                                silent! call repeat#setreg(seq, a:register)
                                silent! call repeat#set(seq, a:count)
                            
                                let s:st.label = target
                                if empty(s:st.opfunc_st)
                                  let s:st.opfunc_st = filter(deepcopy(s:st), 'v:key !=# "opfunc_st"')
                                endif
                              endif
                            endf "}}}
                            
    1              0.000001 func! s:attach_autocmds() abort
                              augroup sneak
                                autocmd!
                                autocmd InsertEnter,WinLeave,BufLeave * call sneak#cancel()
                                "_nested_ autocmd to skip the _first_ CursorMoved event.
                                "NOTE: CursorMoved is _not_ triggered if there is typeahead during a macro/script...
                                autocmd CursorMoved * autocmd sneak CursorMoved * call sneak#cancel()
                              augroup END
                            endf
                            
    1              0.000001 func! sneak#reset(key) abort
                              let c = sneak#util#getchar()
                            
                              let s:st.rst = 1
                              let s:st.reverse = 0
                              for k in ['f', 't'] "unmap the temp mappings
                                if g:sneak#opt[k.'_reset']
                                  silent! exec 'unmap '.k
                                  silent! exec 'unmap '.toupper(k)
                                endif
                              endfor
                            
                              "count is prepended implicitly by the <expr> mapping
                              return a:key.c
                            endf
                            
    1              0.000001 func! s:map_reset_key(key, mode) abort
                              exec printf("%snoremap <silent> <expr> %s sneak#reset('%s')", a:mode, a:key, a:key)
                            endf
                            
                            " Sets temporary mappings to 'hook' into f/F/t/T.
    1              0.000001 func! s:ft_hook() abort
                              for k in ['f', 't']
                                for m in ['n', 'x']
                                  "if user mapped anything to f or t, do not map over it; unfortunately this
                                  "also means we cannot reset ; or , when f or t is invoked.
                                  if g:sneak#opt[k.'_reset'] && maparg(k, m) ==# ''
                                    call s:map_reset_key(k, m) | call s:map_reset_key(toupper(k), m)
                                  endif
                                endfor
                              endfor
                            endf
                            
    1              0.000001 func! s:getnchars(n, mode) abort
                              let s = ''
                              echo g:sneak#opt.prompt
                              for i in range(1, a:n)
                                if sneak#util#isvisualop(a:mode) | exe 'norm! gv' | endif "preserve selection
                                let c = sneak#util#getchar()
                                if -1 != index(["\<esc>", "\<c-c>", "\<c-g>", "\<backspace>",  "\<del>"], c)
                                  return ""
                                endif
                                if c == "\<CR>"
                                  if i > 1 "special case: accept the current input (#15)
                                    break
                                  else "special case: repeat the last search (useful for label-mode).
                                    return s:st.input
                                  endif
                                else
                                  let s .= c
                                  if 1 == &iminsert && sneak#util#strlen(s) >= a:n
                                    "HACK: this can happen if the user entered multiple characters while we
                                    "were waiting to resolve a multi-char keymap.
                                    "example for keymap 'bulgarian-phonetic':
                                    "    e:: => ё    | resolved, strwidth=1
                                    "    eo  => eo   | unresolved, strwidth=2
                                    break
                                  endif
                                endif
                                redraw | echo g:sneak#opt.prompt . s
                              endfor
                              return s
                            endf
                            
                            " 2-char sneak
    1              0.000013 nnoremap <silent> <Plug>Sneak_s :<c-u>call sneak#wrap('', 2, 0, 2, 1)<cr>
    1              0.000006 nnoremap <silent> <Plug>Sneak_S :<c-u>call sneak#wrap('', 2, 1, 2, 1)<cr>
    1              0.000007 xnoremap <silent> <Plug>Sneak_s :<c-u>call sneak#wrap(visualmode(), 2, 0, 2, 1)<cr>
    1              0.000005 xnoremap <silent> <Plug>Sneak_S :<c-u>call sneak#wrap(visualmode(), 2, 1, 2, 1)<cr>
    1              0.000007 onoremap <silent> <Plug>Sneak_s :<c-u>call sneak#wrap(v:operator, 2, 0, 2, 1)<cr>
    1              0.000005 onoremap <silent> <Plug>Sneak_S :<c-u>call sneak#wrap(v:operator, 2, 1, 2, 1)<cr>
                            
    1              0.000007 onoremap <silent> <Plug>SneakRepeat :<c-u>call sneak#wrap(v:operator, sneak#util#getc(), sneak#util#getc(), sneak#util#getc(), sneak#util#getc())<cr>
                            
                            " repeat motion (explicit--as opposed to implicit 'clever-s')
    1              0.000006 nnoremap <silent> <Plug>Sneak_; :<c-u>call <SID>rpt('', 0)<cr>
    1              0.000004 nnoremap <silent> <Plug>Sneak_, :<c-u>call <SID>rpt('', 1)<cr>
    1              0.000005 xnoremap <silent> <Plug>Sneak_; :<c-u>call <SID>rpt(visualmode(), 0)<cr>
    1              0.000004 xnoremap <silent> <Plug>Sneak_, :<c-u>call <SID>rpt(visualmode(), 1)<cr>
    1              0.000004 onoremap <silent> <Plug>Sneak_; :<c-u>call <SID>rpt(v:operator, 0)<cr>
    1              0.000004 onoremap <silent> <Plug>Sneak_, :<c-u>call <SID>rpt(v:operator, 1)<cr>
                            
                            " 1-char 'enhanced f' sneak
    1              0.000005 nnoremap <silent> <Plug>Sneak_f :<c-u>call sneak#wrap('', 1, 0, 1, 0)<cr>
    1              0.000004 nnoremap <silent> <Plug>Sneak_F :<c-u>call sneak#wrap('', 1, 1, 1, 0)<cr>
    1              0.000005 xnoremap <silent> <Plug>Sneak_f :<c-u>call sneak#wrap(visualmode(), 1, 0, 1, 0)<cr>
    1              0.000004 xnoremap <silent> <Plug>Sneak_F :<c-u>call sneak#wrap(visualmode(), 1, 1, 1, 0)<cr>
    1              0.000004 onoremap <silent> <Plug>Sneak_f :<c-u>call sneak#wrap(v:operator, 1, 0, 1, 0)<cr>
    1              0.000004 onoremap <silent> <Plug>Sneak_F :<c-u>call sneak#wrap(v:operator, 1, 1, 1, 0)<cr>
                            
                            " 1-char 'enhanced t' sneak
    1              0.000004 nnoremap <silent> <Plug>Sneak_t :<c-u>call sneak#wrap('', 1, 0, 0, 0)<cr>
    1              0.000004 nnoremap <silent> <Plug>Sneak_T :<c-u>call sneak#wrap('', 1, 1, 0, 0)<cr>
    1              0.000004 xnoremap <silent> <Plug>Sneak_t :<c-u>call sneak#wrap(visualmode(), 1, 0, 0, 0)<cr>
    1              0.000004 xnoremap <silent> <Plug>Sneak_T :<c-u>call sneak#wrap(visualmode(), 1, 1, 0, 0)<cr>
    1              0.000006 onoremap <silent> <Plug>Sneak_t :<c-u>call sneak#wrap(v:operator, 1, 0, 0, 0)<cr>
    1              0.000004 onoremap <silent> <Plug>Sneak_T :<c-u>call sneak#wrap(v:operator, 1, 1, 0, 0)<cr>
                            
    1              0.000004 nnoremap <silent> <Plug>SneakLabel_s :<c-u>call sneak#wrap('', 2, 0, 2, 2)<cr>
    1              0.000004 nnoremap <silent> <Plug>SneakLabel_S :<c-u>call sneak#wrap('', 2, 1, 2, 2)<cr>
    1              0.000005 xnoremap <silent> <Plug>SneakLabel_s :<c-u>call sneak#wrap(visualmode(), 2, 0, 2, 2)<cr>
    1              0.000005 xnoremap <silent> <Plug>SneakLabel_S :<c-u>call sneak#wrap(visualmode(), 2, 1, 2, 2)<cr>
    1              0.000004 onoremap <silent> <Plug>SneakLabel_s :<c-u>call sneak#wrap(v:operator, 2, 0, 2, 2)<cr>
    1              0.000004 onoremap <silent> <Plug>SneakLabel_S :<c-u>call sneak#wrap(v:operator, 2, 1, 2, 2)<cr>
                            
    1              0.000022 if !hasmapto('<Plug>SneakForward') && !hasmapto('<Plug>Sneak_s', 'n') && mapcheck('s', 'n') ==# ''
                              nmap s <Plug>Sneak_s
    1              0.000001 endif
    1              0.000015 if !hasmapto('<Plug>SneakBackward') && !hasmapto('<Plug>Sneak_S', 'n') && mapcheck('S', 'n') ==# ''
    1              0.000005   nmap S <Plug>Sneak_S
    1              0.000000 endif
    1              0.000009 if !hasmapto('<Plug>Sneak_s', 'o') && mapcheck('z', 'o') ==# ''
    1              0.000004   omap z <Plug>Sneak_s
    1              0.000000 endif
    1              0.000007 if !hasmapto('<Plug>Sneak_S', 'o') && mapcheck('Z', 'o') ==# ''
    1              0.000003   omap Z <Plug>Sneak_S
    1              0.000000 endif
                            
    1              0.000004 if !hasmapto('<Plug>Sneak_;', 'n') && !hasmapto('<Plug>SneakNext', 'n') && mapcheck(';', 'n') ==# ''
                              nmap ; <Plug>Sneak_;
                              omap ; <Plug>Sneak_;
                              xmap ; <Plug>Sneak_;
    1              0.000000 endif
    1              0.000003 if !hasmapto('<Plug>Sneak_,', 'n') && !hasmapto('<Plug>SneakPrevious', 'n')
                              if mapcheck(',', 'n') ==# ''
                                nmap , <Plug>Sneak_,
                                omap , <Plug>Sneak_,
                                xmap , <Plug>Sneak_,
                              elseif mapcheck('\', 'n') ==# '' || mapcheck('\', 'n') ==# ','
                                nmap \ <Plug>Sneak_,
                                omap \ <Plug>Sneak_,
                                xmap \ <Plug>Sneak_,
                              endif
    1              0.000000 endif
                            
    1              0.000015 if !hasmapto('<Plug>VSneakForward') && !hasmapto('<Plug>Sneak_s', 'v') && mapcheck('s', 'x') ==# ''
    1              0.000004   xmap s <Plug>Sneak_s
    1              0.000000 endif
    1              0.000013 if !hasmapto('<Plug>VSneakBackward') && !hasmapto('<Plug>Sneak_S', 'v') && mapcheck('Z', 'x') ==# ''
    1              0.000004   xmap Z <Plug>Sneak_S
    1              0.000000 endif
                            
                            " redundant legacy mappings for backwards compatibility (must come _after_ the hasmapto('<Plug>Sneak_S') checks above)
    1              0.000005 nmap <Plug>SneakForward   <Plug>Sneak_s
    1              0.000005 nmap <Plug>SneakBackward  <Plug>Sneak_S
    1              0.000004 xmap <Plug>VSneakForward  <Plug>Sneak_s
    1              0.000004 xmap <Plug>VSneakBackward <Plug>Sneak_S
    1              0.000004 xmap <Plug>VSneakNext     <Plug>Sneak_;
    1              0.000004 xmap <Plug>VSneakPrevious <Plug>Sneak_,
    1              0.000005 nmap <Plug>(SneakStreak)         <Plug>SneakLabel_s
    1              0.000006 nmap <Plug>(SneakStreakBackward) <Plug>SneakLabel_S
    1              0.000008 xmap <Plug>(SneakStreak)         <Plug>SneakLabel_s
    1              0.000006 xmap <Plug>(SneakStreakBackward) <Plug>SneakLabel_S
    1              0.000006 omap <Plug>(SneakStreak)         <Plug>SneakLabel_s
    1              0.000102 omap <Plug>(SneakStreakBackward) <Plug>SneakLabel_S
    1              0.000011 nmap <Plug>SneakNext     <Plug>Sneak_;
    1              0.000011 nmap <Plug>SneakPrevious <Plug>Sneak_,
    1              0.000009 xmap <Plug>SneakNext     <Plug>Sneak_;
    1              0.000009 xmap <Plug>SneakPrevious <Plug>Sneak_,
    1              0.000008 omap <Plug>SneakNext     <Plug>Sneak_;
    1              0.000007 omap <Plug>SneakPrevious <Plug>Sneak_,
                            
    1              0.000015 if g:sneak#opt.map_netrw && -1 != stridx(maparg("s", "n"), "Sneak")
                              func! s:map_netrw_key(key) abort
                                let expanded_map = maparg(a:key,'n')
                                if !strlen(expanded_map) || expanded_map =~# '_Net\|FileBeagle'
                                  if strlen(expanded_map) > 0 "else, mapped to <nop>
                                    silent exe (expanded_map =~# '<Plug>' ? 'nmap' : 'nnoremap').' <buffer> <silent> <leader>'.a:key.' '.expanded_map
                                  endif
                                  "unmap the default buffer-local mapping to allow Sneak's global mapping.
                                  silent! exe 'nunmap <buffer> '.a:key
                                endif
                              endf
                            
                              augroup sneak_netrw
                                autocmd!
                                autocmd FileType netrw,filebeagle autocmd sneak_netrw CursorMoved <buffer>
                                      \ call <sid>map_netrw_key('s') | call <sid>map_netrw_key('S') | autocmd! sneak_netrw * <buffer>
                              augroup END
    1              0.000001 endif
                            
                            
    1              0.000012 let &cpo = s:cpo_save
    1              0.000018 unlet s:cpo_save

SCRIPT  /home/tony/.config/nvim/autoload/plugged/quick-scope/plugin/quick_scope.vim
Sourced 1 time
Total time:   0.000849
 Self time:   0.000806

count  total (s)   self (s)
                            " Initialize -----------------------------------------------------------------
    1              0.000004 let s:plugin_name = 'quick-scope'
                            
    1              0.000003 if exists('g:loaded_quick_scope')
                              finish
    1              0.000001 endif
                            
    1              0.000001 let g:loaded_quick_scope = 1
                            
    1              0.000001 if &compatible
                              echoerr s:plugin_name . " won't load in Vi-compatible mode."
                              finish
    1              0.000000 endif
                            
    1              0.000003 if v:version < 701 || (v:version == 701 && !has('patch040'))
                              echoerr s:plugin_name . ' requires Vim running in version 7.1.040 or later.'
                              finish
    1              0.000000 endif
                            
                            " Save cpoptions and reassign them later. See :h use-cpo-save.
    1              0.000005 let s:cpo_save = &cpo
    1              0.000005 set cpo&vim
                            
                            " Autocommands ---------------------------------------------------------------
    1              0.000002 augroup quick_scope
    1              0.000253   autocmd!
    1              0.000005   autocmd ColorScheme * call s:set_highlight_colors()
    1              0.000001 augroup END
                            
                            " Options --------------------------------------------------------------------
    1              0.000003 if !exists('g:qs_enable')
    1              0.000001   let g:qs_enable = 1
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:qs_lazy_highlight')
    1              0.000001   let g:qs_lazy_highlight = 0
    1              0.000000 endif
                            
    1              0.000002 if !exists('g:qs_second_highlight')
    1              0.000001   let g:qs_second_highlight = 1
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:qs_ignorecase')
    1              0.000001   let g:qs_ignorecase = 0
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:qs_max_chars')
                              " Disable on long lines for performance
                              let g:qs_max_chars = 1000
    1              0.000000 endif
                            
    1              0.000002 if !exists('g:qs_accepted_chars')
    1              0.000008   let g:qs_accepted_chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:qs_buftype_blacklist')
    1              0.000001   let g:qs_buftype_blacklist = []
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:qs_filetype_blacklist')
    1              0.000001   let g:qs_filetype_blacklist = []
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:qs_delay')
    1              0.000004   let g:qs_delay = has('timers') ? 50 : 0
    1              0.000000 endif
                            
    1              0.000002 if !exists('g:qs_highlight_on_keys')
                              " Vanilla mode. Highlight on cursor movement.
                              augroup quick_scope
                                if g:qs_lazy_highlight
                                  autocmd CursorHold,InsertLeave,ColorScheme,WinEnter,BufEnter,FocusGained * call quick_scope#UnhighlightLine() | call quick_scope#HighlightLine(2, g:qs_accepted_chars)
                                else
                                  autocmd CursorMoved,InsertLeave,ColorScheme,WinEnter,BufEnter,FocusGained * call quick_scope#HighlightLineDelay(2, g:qs_accepted_chars)
                                endif
                                autocmd InsertEnter,BufLeave,TabLeave,WinLeave,FocusLost * call quick_scope#StopTimer() | call quick_scope#UnhighlightLine()
                              augroup END
    1              0.000000 else
                              " Highlight on key press. Set an 'augmented' mapping for each defined key.
    5              0.000012   for motion in split('fFtT', '\zs')
   12              0.000009     for mapmode in ['onoremap', 'xnoremap']
    8              0.000091       execute printf(mapmode . ' <expr> <Plug>(QuickScope%s) quick_scope#Ready() . quick_scope#Aim("%s") . quick_scope#Reload() . quick_scope#DoubleTap()', motion, motion)
   12              0.000004     endfor
                                " Using <expr> for normal mode mappings can cause problems (#80)
    4              0.000049     execute printf('nnoremap <silent> <Plug>(QuickScope%s) :<C-U>call quick_scope#Ready() \| execute "normal!" v:count1 . quick_scope#Aim("%s") \| call quick_scope#Reload() \| call quick_scope#DoubleTap()<CR>', motion, motion)
    5              0.000002   endfor
    5              0.000019   for motion in filter(g:qs_highlight_on_keys, "v:val =~# '^[fFtT]$'")
   16              0.000010     for mapmode in ['nmap', 'omap', 'xmap']
   12              0.000060       if empty(mapcheck(motion, mapmode[0]))
   12              0.000075         execute printf(mapmode . ' <unique> %s <Plug>(QuickScope%s)', motion, motion)
   12              0.000003       endif
   16              0.000004     endfor
    5              0.000002   endfor
    1              0.000001 endif
                            
                            " User commands --------------------------------------------------------------
    1              0.000003 command! -nargs=0 QuickScopeToggle call quick_scope#Toggle()
                            
                            " Plug mappings --------------------------------------------------------------
    1              0.000008 nnoremap <silent> <plug>(QuickScopeToggle) :call quick_scope#Toggle()<cr>
    1              0.000007 xnoremap <silent> <plug>(QuickScopeToggle) :<c-u>call quick_scope#Toggle()<cr>
                            
                            " Colors ---------------------------------------------------------------------
                            " Set the colors used for highlighting.
    1              0.000003 function! s:set_highlight_colors()
                              " Priority for overruling other highlight matches.
                              let g:qs_hi_priority = get(g:, "qs_hi_priority", 1)
                            
                              " Highlight group marking first appearance of characters in a line.
                              let g:qs_hi_group_primary = 'QuickScopePrimary'
                              " Highlight group marking second appearance of characters in a line.
                              let g:qs_hi_group_secondary = 'QuickScopeSecondary'
                              " Highlight group marking dummy cursor when quick-scope is enabled on key
                              " press.
                              let g:qs_hi_group_cursor = 'QuickScopeCursor'
                            
                              if exists('g:qs_first_occurrence_highlight_color')
                                " backwards compatibility mode for old highlight configuration
                                augroup quick_scope_lazy_print
                                  if has('vim_starting')
                                    " register this as a lazy print error so as not to block Vim starting
                                    autocmd CursorHold,CursorHoldI * call quick_scope#lazy_print#err('option g:qs_first_occurrence_highlight_color is deprecated!')
                                  else
                                    echohl ErrorMsg
                                    echomsg s:plugin_name . ' option g:qs_first_occurrence_highlight_color is deprecated!'
                                    echohl None
                                  endif
                                augroup END
                            
                                let l:first_color = g:qs_first_occurrence_highlight_color
                                if l:first_color =~# '#'
                                  execute 'highlight default ' . g:qs_hi_group_primary . ' gui=underline guifg=' . l:first_color
                                else
                                  execute 'highlight default ' . g:qs_hi_group_primary . ' cterm=underline ctermfg=' . l:first_color
                                endif
                              else
                                execute 'highlight default link ' . g:qs_hi_group_primary . ' Function'
                              endif
                            
                              if exists('g:qs_second_occurrence_highlight_color')
                                " backwards compatibility mode for old highlight configuration
                                augroup quick_scope_lazy_print
                                  if has('vim_starting')
                                    " register this as a lazy print error so as not to block Vim starting
                                    autocmd CursorHold,CursorHoldI * call quick_scope#lazy_print#err('option g:qs_second_occurrence_highlight_color is deprecated!')
                                  else
                                    echohl ErrorMsg
                                    echomsg s:plugin_name . ' option g:qs_second_occurrence_highlight_color is deprecated!'
                                    echohl None
                                  endif
                                augroup END
                            
                                let l:second_color = g:qs_second_occurrence_highlight_color
                                if l:second_color =~# '#'
                                  execute 'highlight default ' . g:qs_hi_group_secondary . ' gui=underline guifg=' . l:second_color
                                else
                                  execute 'highlight default ' . g:qs_hi_group_secondary . ' cterm=underline ctermfg=' . l:second_color
                                endif
                              else
                                execute 'highlight default link ' . g:qs_hi_group_secondary . ' Define'
                              endif
                            
                              execute 'highlight default link ' . g:qs_hi_group_cursor . ' Cursor'
                            endfunction
                            
    1   0.000051   0.000008 call s:set_highlight_colors()
                            
    1              0.000006 let &cpo = s:cpo_save
    1              0.000014 unlet s:cpo_save

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-easymotion/plugin/EasyMotion.vim
Sourced 1 time
Total time:   0.003942
 Self time:   0.000592

count  total (s)   self (s)
    1              0.000003 scriptencoding utf-8
                            " EasyMotion - Vim motions on speed!
                            "
                            " Author: Kim Silkebækken <kim.silkebaekken+vim@gmail.com>
                            "         haya14busa <hayabusa1419@gmail.com>
                            " Source: https://github.com/easymotion/vim-easymotion
                            " == Script initialization {{{
    1              0.000032 if expand("%:p") ==# expand("<sfile>:p")
                              unlet! g:EasyMotion_loaded
    1              0.000001 endif
    1              0.000003 if exists('g:EasyMotion_loaded') || &compatible || version < 703
                                finish
    1              0.000000 endif
                            
    1              0.000002 let g:EasyMotion_loaded = 1
                            " }}}
                            
                            " == Saving 'cpoptions' {{{
    1              0.000003 let s:save_cpo = &cpo
    1              0.000004 set cpo&vim
                            " }}}
                            
                            " == Default configuration {{{
                            " -- Option ------------------------------ {{{
    1              0.000003 let g:EasyMotion_keys               = get(g:,
                                \ 'EasyMotion_keys', 'asdghklqwertyuiopzxcvbnmfj;')
                                " \ 'EasyMotion_keys', 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
    1              0.000002 let g:EasyMotion_do_mapping         = get(g: , 'EasyMotion_do_mapping'         , 1)
    1              0.000002 let g:EasyMotion_do_shade           = get(g: , 'EasyMotion_do_shade'           , 1)
    1              0.000002 let g:EasyMotion_grouping           = get(g: , 'EasyMotion_grouping'           , 1)
    1              0.000002 let g:EasyMotion_startofline        = get(g: , 'EasyMotion_startofline'        , 1)
    1              0.000002 let g:EasyMotion_smartcase          = get(g: , 'EasyMotion_smartcase'          , 0)
    1              0.000002 let g:EasyMotion_skipfoldedline     = get(g: , 'EasyMotion_skipfoldedline'     , 1)
    1              0.000002 let g:EasyMotion_use_migemo         = get(g: , 'EasyMotion_use_migemo'         , 0)
    1              0.000002 let g:EasyMotion_use_upper          = get(g: , 'EasyMotion_use_upper'          , 0)
    1              0.000002 let g:EasyMotion_enter_jump_first   = get(g: , 'EasyMotion_enter_jump_first'   , 0)
    1              0.000002 let g:EasyMotion_space_jump_first   = get(g: , 'EasyMotion_space_jump_first'   , 0)
    1              0.000002 let g:EasyMotion_inc_highlight      = get(g: , 'EasyMotion_inc_highlight'      , 1)
    1              0.000002 let g:EasyMotion_move_highlight     = get(g: , 'EasyMotion_move_highlight'     , 1)
    1              0.000002 let g:EasyMotion_landing_highlight  = get(g: , 'EasyMotion_landing_highlight'  , 0)
    1              0.000002 let g:EasyMotion_cursor_highlight   = get(g: , 'EasyMotion_cursor_highlight'   , 1)
    1              0.000002 let g:EasyMotion_use_regexp         = get(g: , 'EasyMotion_use_regexp'         , 1)
    1              0.000002 let g:EasyMotion_add_search_history = get(g: , 'EasyMotion_add_search_history' , 1)
    1              0.000002 let g:EasyMotion_off_screen_search  = get(g: , 'EasyMotion_off_screen_search'  , 1)
    1              0.000002 let g:EasyMotion_force_csapprox     = get(g: , 'EasyMotion_force_csapprox'     , 0)
    1              0.000002 let g:EasyMotion_show_prompt        = get(g: , 'EasyMotion_show_prompt'        , 1)
    1              0.000002 let g:EasyMotion_verbose            = get(g: , 'EasyMotion_verbose'            , 1)
    1              0.000002 let g:EasyMotion_prompt             =
                                \ get(g: , 'EasyMotion_prompt' , 'Search for {n} character(s): ')
    1              0.000003 let g:EasyMotion_command_line_key_mappings =
                                \ get(g: , 'EasyMotion_command_line_key_mappings' , {})
    1              0.000002 let g:EasyMotion_disable_two_key_combo     =
                                \ get(g: , 'EasyMotion_disable_two_key_combo' , 0)
                            
                            "}}}
                            
                            " }}}
                            
                            " == <Plug> Mapping {{{
                            " Note: bd is short for bidirectional
                            "       l is short for (within) line
                            
    1              0.000003 function! s:motion_map_helper(motions) "{{{
                                for [name, dict] in items(a:motions)
                                    let mapargs = []
                                    let xmapargs = []
                                    if dict.fnc ==# 'S' || dict.fnc ==# 'SL' || dict.fnc ==# 'T' || dict.fnc ==# 'TL'
                                        let mapargs  += [dict.cnt, 0, dict.direction]
                                        let xmapargs += [dict.cnt, 1, dict.direction]
                                    elseif dict.fnc ==# 'Search'
                                        let mapargs  += [0, dict.direction, dict.respect_direction]
                                        let xmapargs += [1, dict.direction, dict.respect_direction]
                                    else
                                        let mapargs  += [0, dict.direction]
                                        let xmapargs += [1, dict.direction]
                                    endif
                            
                                    silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' .
                                        \ '      :<C-u>call EasyMotion#' . dict.fnc . '('. join(mapargs, ',') . ')<CR>'
                                    silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' .
                                        \ ' <Esc>:<C-u>call EasyMotion#' . dict.fnc . '('. join(xmapargs, ',') . ')<CR>'
                                " Example:
                                " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
                                " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
                                endfor
                            endfunction "}}}
                            
                            " Find Motion: {{{
    1   0.001393   0.000086 call s:motion_map_helper({
                                \ 'f'               : {'fnc' : 'S'  , 'cnt' : 1, 'direction'  : 0},
                                \ 'F'               : {'fnc' : 'S'  , 'cnt' : 1, 'direction'  : 1},
                                \ 's'               : {'fnc' : 'S'  , 'cnt' : 1, 'direction'  : 2},
                                \ 'bd-f'            : {'fnc' : 'S'  , 'cnt' : 1, 'direction'  : 2},
                                \ 't'               : {'fnc' : 'T'  , 'cnt' : 1, 'direction'  : 0},
                                \ 'T'               : {'fnc' : 'T'  , 'cnt' : 1, 'direction'  : 1},
                                \ 'bd-t'            : {'fnc' : 'T'  , 'cnt' : 1, 'direction'  : 2},
                                \ 'fl'              : {'fnc' : 'SL' , 'cnt' : 1, 'direction'  : 0},
                                \ 'Fl'              : {'fnc' : 'SL' , 'cnt' : 1, 'direction'  : 1},
                                \ 'sl'              : {'fnc' : 'SL' , 'cnt' : 1, 'direction'  : 2},
                                \ 'bd-fl'           : {'fnc' : 'SL' , 'cnt' : 1, 'direction'  : 2},
                                \ 'tl'              : {'fnc' : 'TL' , 'cnt' : 1, 'direction'  : 0},
                                \ 'Tl'              : {'fnc' : 'TL' , 'cnt' : 1, 'direction'  : 1},
                                \ 'bd-tl'           : {'fnc' : 'TL' , 'cnt' : 1, 'direction'  : 2},
                                \
                                \ 'f2'              : {'fnc' : 'S'  , 'cnt' : 2, 'direction'  : 0},
                                \ 'F2'              : {'fnc' : 'S'  , 'cnt' : 2, 'direction'  : 1},
                                \ 's2'              : {'fnc' : 'S'  , 'cnt' : 2, 'direction'  : 2},
                                \ 'bd-f2'           : {'fnc' : 'S'  , 'cnt' : 2, 'direction'  : 2},
                                \ 't2'              : {'fnc' : 'T'  , 'cnt' : 2, 'direction'  : 0},
                                \ 'T2'              : {'fnc' : 'T'  , 'cnt' : 2, 'direction'  : 1},
                                \ 'bd-t2'           : {'fnc' : 'T'  , 'cnt' : 2, 'direction'  : 2},
                                \ 'fl2'             : {'fnc' : 'SL' , 'cnt' : 2, 'direction'  : 0},
                                \ 'Fl2'             : {'fnc' : 'SL' , 'cnt' : 2, 'direction'  : 1},
                                \ 'sl2'             : {'fnc' : 'SL' , 'cnt' : 2, 'direction'  : 2},
                                \ 'bd-fl2'          : {'fnc' : 'SL' , 'cnt' : 2, 'direction'  : 2},
                                \ 'tl2'             : {'fnc' : 'TL' , 'cnt' : 2, 'direction'  : 0},
                                \ 'Tl2'             : {'fnc' : 'TL' , 'cnt' : 2, 'direction'  : 1},
                                \ 'bd-tl2'          : {'fnc' : 'TL' , 'cnt' : 2, 'direction'  : 2},
                                \
                                \ 'fn'              : {'fnc' : 'S'  , 'cnt' : -1, 'direction' : 0},
                                \ 'Fn'              : {'fnc' : 'S'  , 'cnt' : -1, 'direction' : 1},
                                \ 'sn'              : {'fnc' : 'S'  , 'cnt' : -1, 'direction' : 2},
                                \ 'bd-fn'           : {'fnc' : 'S'  , 'cnt' : -1, 'direction' : 2},
                                \ 'tn'              : {'fnc' : 'T'  , 'cnt' : -1, 'direction' : 0},
                                \ 'Tn'              : {'fnc' : 'T'  , 'cnt' : -1, 'direction' : 1},
                                \ 'bd-tn'           : {'fnc' : 'T'  , 'cnt' : -1, 'direction' : 2},
                                \ 'fln'             : {'fnc' : 'SL' , 'cnt' : -1, 'direction' : 0},
                                \ 'Fln'             : {'fnc' : 'SL' , 'cnt' : -1, 'direction' : 1},
                                \ 'sln'             : {'fnc' : 'SL' , 'cnt' : -1, 'direction' : 2},
                                \ 'bd-fln'          : {'fnc' : 'SL' , 'cnt' : -1, 'direction' : 2},
                                \ 'tln'             : {'fnc' : 'TL' , 'cnt' : -1, 'direction' : 0},
                                \ 'Tln'             : {'fnc' : 'TL' , 'cnt' : -1, 'direction' : 1},
                                \ 'bd-tln'          : {'fnc' : 'TL' , 'cnt' : -1, 'direction' : 2},
                                \ })
                            
    1              0.000009 nnoremap <silent> <Plug>(easymotion-overwin-f) :<C-u>call EasyMotion#OverwinF(1)<CR>
    1              0.000007 nnoremap <silent> <Plug>(easymotion-overwin-f2) :<C-u>call EasyMotion#OverwinF(2)<CR>
    1              0.000007 nnoremap <silent> <Plug>(easymotion-overwin-line) :<C-u>call EasyMotion#overwin#line()<CR>
    1              0.000006 nnoremap <silent> <Plug>(easymotion-overwin-w) :<C-u>call EasyMotion#overwin#w()<CR>
                            
                            "}}}
                            
                            " -- Word Motion {{{
    1   0.000645   0.000042 call s:motion_map_helper({
                                \ 'w'               : {'fnc' : 'WB' , 'direction' : 0},
                                \ 'b'               : {'fnc' : 'WB' , 'direction' : 1},
                                \ 'bd-w'            : {'fnc' : 'WB' , 'direction' : 2},
                                \ 'W'               : {'fnc' : 'WBW', 'direction' : 0},
                                \ 'B'               : {'fnc' : 'WBW', 'direction' : 1},
                                \ 'bd-W'            : {'fnc' : 'WBW', 'direction' : 2},
                                \ 'iskeyword-w'     : {'fnc' : 'WBK', 'direction' : 0},
                                \ 'iskeyword-b'     : {'fnc' : 'WBK', 'direction' : 1},
                                \ 'iskeyword-bd-w'  : {'fnc' : 'WBK', 'direction' : 2},
                                \
                                \ 'e'               : {'fnc' : 'E'  , 'direction' : 0},
                                \ 'ge'              : {'fnc' : 'E'  , 'direction' : 1},
                                \ 'bd-e'            : {'fnc' : 'E'  , 'direction' : 2},
                                \ 'E'               : {'fnc' : 'EW' , 'direction' : 0},
                                \ 'gE'              : {'fnc' : 'EW' , 'direction' : 1},
                                \ 'bd-E'            : {'fnc' : 'EW' , 'direction' : 2},
                                \ 'iskeyword-e'     : {'fnc' : 'EK' , 'direction' : 0},
                                \ 'iskeyword-ge'    : {'fnc' : 'EK' , 'direction' : 1},
                                \ 'iskeyword-bd-e'  : {'fnc' : 'EK' , 'direction' : 2},
                                \ })
                            "}}}
                            
                            " -- JK Motion {{{
    1   0.000349   0.000023 call s:motion_map_helper({
                                \ 'j'               : {'fnc' : 'JK' , 'direction' : 0},
                                \ 'k'               : {'fnc' : 'JK' , 'direction' : 1},
                                \ 'bd-jk'           : {'fnc' : 'JK' , 'direction' : 2},
                                \ 'sol-j'           : {'fnc' : 'Sol', 'direction' : 0},
                                \ 'sol-k'           : {'fnc' : 'Sol', 'direction' : 1},
                                \ 'sol-bd-jk'       : {'fnc' : 'Sol', 'direction' : 2},
                                \ 'eol-j'           : {'fnc' : 'Eol', 'direction' : 0},
                                \ 'eol-k'           : {'fnc' : 'Eol', 'direction' : 1},
                                \ 'eol-bd-jk'       : {'fnc' : 'Eol', 'direction' : 2},
                                \ })
                            "}}}
                            
                            " -- Search Motion {{{
    1   0.000223   0.000022 call s:motion_map_helper({
                                \ 'n'               : {'fnc' : 'Search', 'direction': 0, 'respect_direction': 0},
                                \ 'N'               : {'fnc' : 'Search', 'direction': 1, 'respect_direction': 0},
                                \ 'bd-n'            : {'fnc' : 'Search', 'direction': 2, 'respect_direction': 0},
                                \ 'vim-n'           : {'fnc' : 'Search', 'direction': 0, 'respect_direction': 1},
                                \ 'vim-N'           : {'fnc' : 'Search', 'direction': 1, 'respect_direction': 1},
                                \ })
                            "}}}
                            
                            " -- Jump To Anywhere Motion {{{
    1   0.000069   0.000009 call s:motion_map_helper({
                                \ 'jumptoanywhere'  : {'fnc' : 'JumpToAnywhere', 'direction': 2},
                                \ })
                            "}}}
                            
                            " -- Line Motion {{{
    1   0.000352   0.000021 call s:motion_map_helper({
                                \ 'wl'              : {'fnc' : 'WBL', 'direction': 0},
                                \ 'bl'              : {'fnc' : 'WBL', 'direction': 1},
                                \ 'bd-wl'           : {'fnc' : 'WBL', 'direction': 2},
                                \ 'el'              : {'fnc' : 'EL' , 'direction': 0},
                                \ 'gel'             : {'fnc' : 'EL' , 'direction': 1},
                                \ 'bd-el'           : {'fnc' : 'EL' , 'direction': 2},
                                \ 'lineforward'     : {'fnc' : 'LineAnywhere', 'direction': 0},
                                \ 'linebackward'    : {'fnc' : 'LineAnywhere', 'direction': 1},
                                \ 'lineanywhere'    : {'fnc' : 'LineAnywhere', 'direction': 2},
                                \ })
                            "}}}
                            
                            " -- Next, Previous Motion {{{
    1              0.000011 noremap  <silent><Plug>(easymotion-next)
                                \      :<C-u>call EasyMotion#NextPrevious(0,0)<CR>
    1              0.000009 xnoremap <silent><Plug>(easymotion-next)
                                \      :<C-u>call EasyMotion#NextPrevious(1,0)<CR>
                            
    1              0.000008 noremap  <silent><Plug>(easymotion-prev)
                                \      :<C-u>call EasyMotion#NextPrevious(0,1)<CR>
    1              0.000007 xnoremap <silent><Plug>(easymotion-prev)
                                \      :<C-u>call EasyMotion#NextPrevious(1,1)<CR>
                            "}}}
                            
                            " -- Repeat Motion {{{
    1              0.000008 noremap  <silent><Plug>(easymotion-repeat)
                                \      :<C-u>call EasyMotion#Repeat(0)<CR>
    1              0.000007 xnoremap <silent><Plug>(easymotion-repeat)
                                \ <Esc>:<C-u>call EasyMotion#Repeat(1)<CR>
                            
    1              0.000008 noremap  <silent><Plug>(easymotion-dotrepeat)
                                \      :<C-u>call EasyMotion#DotRepeat()<CR>
                            "}}}
                            
    1              0.000008 noremap  <silent><Plug>(easymotion-activate) :<C-u>call EasyMotion#activate(0)<CR>
    1              0.000007 xnoremap <silent><Plug>(easymotion-activate) :<C-u>call EasyMotion#activate(1)<CR>
                            " }}}
                            
                            " == Default key mapping {{{
    1              0.000001 if g:EasyMotion_do_mapping == 1
                                " Prepare Prefix: {{{
    1              0.000003     if exists('g:EasyMotion_leader_key')
                                    exec 'map ' . g:EasyMotion_leader_key . ' <Plug>(easymotion-prefix)'
    1              0.000001     else
    1              0.000015         if !hasmapto('<Plug>(easymotion-prefix)')
    1              0.000009             map <Leader><Leader> <Plug>(easymotion-prefix)
    1              0.000000         endif
    1              0.000000     endif
                                "}}}
                            
    1              0.000003     function! s:default_mapping(motions, do_mapping) "{{{
                                    for motion in a:motions
                                        " Mapping {{{
                                        if exists('g:EasyMotion_mapping_' . motion)
                                            " Backward compatible mapping [deprecated]
                                            silent exec 'map <silent> ' .
                                                \ eval('g:EasyMotion_mapping_' . motion) . ' <Plug>(easymotion-' . motion . ')'
                                        elseif a:do_mapping
                                                \ && !hasmapto('<Plug>(easymotion-' . motion . ')')
                                                \ && empty(maparg('<Plug>(easymotion-prefix)' . motion, 'nov'))
                            
                                            " Do mapping
                                            silent exec 'map <silent> ' .
                                                \'<Plug>(easymotion-prefix)' . motion . ' <Plug>(easymotion-' . motion . ')'
                                        endif "}}}
                                    endfor
                                endfunction "}}}
                            
                                " Default Mapping:
    1   0.000535   0.000013     call s:default_mapping(
                                    \ ['f', 'F', 's', 't', 'T',
                                    \  'w', 'W', 'b', 'B', 'e', 'E', 'ge', 'gE',
                                    \  'j', 'k', 'n', 'N'], g:EasyMotion_do_mapping)
    1              0.000001 endif "}}}
                            
                            " == CommandLine Mapping {{{
    1              0.000006 command! -nargs=*
                            \   EMCommandLineNoreMap
                            \   call EasyMotion#command_line#cnoremap([<f-args>])
    1              0.000003 command! -nargs=*
                            \   EMCommandLineMap
                            \   call EasyMotion#command_line#cmap([<f-args>])
    1              0.000003 command! -nargs=1
                            \   EMCommandLineUnMap
                            \   call EasyMotion#command_line#cunmap(<f-args>)
                            "}}}
                            
                            " == Restore 'cpoptions' {{{
    1              0.000008 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            " }}}
                            " vim: fdm=marker:et:ts=4:sw=4:sts=4

SCRIPT  /home/tony/.config/nvim/autoload/plugged/rnvimr/plugin/rnvimr.vim
Sourced 1 time
Total time:   0.000343
 Self time:   0.000343

count  total (s)   self (s)
    1              0.000007 if exists('g:loaded_rnvimr')
                                finish
    1              0.000001 endif
                            
    1              0.000002 let g:loaded_rnvimr = 1
                            
    1              0.000004 command! -nargs=0 RnvimrToggle call rnvimr#toggle()
    1              0.000003 command! -nargs=* RnvimrResize call rnvimr#resize(<args>)
                            
                            " TODO rnvimr_ex_enable was desperated.
    1              0.000004 let g:rnvimr_enable_ex = get(g:, 'rnvimr_enable_ex', 0) || get(g:, 'rnvimr_ex_enable', 0)
                            
    1              0.000001 if get(g:, 'rnvimr_enable_ex', 0)
    1              0.000002     augroup RnvimrFileExplorer
    1              0.000266         autocmd!
    1              0.000007         autocmd VimEnter * ++once silent! autocmd! FileExplorer
    1              0.000004         autocmd VimEnter * ++once if isdirectory(expand('<amatch>')) |
                                                \ bwipeout! | call rnvimr#open(expand('<amatch>')) |
                                                \ endif |
                                                \ execute(printf("autocmd RnvimrFileExplorer BufEnter * %s",
                                                \ "call rnvimr#enter_dir(expand('<amatch>'), expand('<abuf>'))"))
    1              0.000001     augroup END
    1              0.000019 endif

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-startify/plugin/startify.vim
Sourced 1 time
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
                            " vim: et sw=2 sts=2
                            
                            " Plugin:      https://github.com/mhinz/vim-startify
                            " Description: A fancy start screen for Vim.
                            " Maintainer:  Marco Hinz <http://github.com/mhinz>
                            
    1              0.000011 if exists('g:loaded_startify') || &cp
                              finish
    1              0.000000 endif
    1              0.000003 let g:loaded_startify = 1
    1              0.000001 let g:startify_locked = 0
                            
    1              0.000008 if !get(g:, 'startify_disable_at_vimenter') && (!has('nvim') || has('nvim-0.3.5'))
                              " Only for Nvim v0.3.5+: https://github.com/neovim/neovim/issues/9885
    1              0.000008   set shortmess+=I
    1              0.000000 endif
                            
    1              0.000001 augroup startify
    1              0.000004   autocmd VimEnter    * nested call s:on_vimenter()
    1              0.000003   autocmd VimLeavePre * nested call s:on_vimleavepre()
    1              0.000003   autocmd QuickFixCmdPre  *vimgrep* let g:startify_locked = 1
    1              0.000002   autocmd QuickFixCmdPost *vimgrep* let g:startify_locked = 0
    1              0.000000 augroup END
                            
    1              0.000004 function! s:update_oldfiles(file)
                              if g:startify_locked || !exists('v:oldfiles')
                                return
                              endif
                              let idx = index(v:oldfiles, a:file)
                              if idx != -1
                                call remove(v:oldfiles, idx)
                              endif
                              call insert(v:oldfiles, a:file, 0)
                            endfunction
                            
    1              0.000001 function! s:on_vimenter()
                              if !argc() && line2byte('$') == -1
                                if get(g:, 'startify_session_autoload') && filereadable('Session.vim')
                                  source Session.vim
                                elseif !get(g:, 'startify_disable_at_vimenter')
                                  call startify#insane_in_the_membrane(1)
                                endif
                              endif
                              if get(g:, 'startify_update_oldfiles')
                                call map(v:oldfiles, 'fnamemodify(v:val, ":p")')
                                autocmd startify BufNewFile,BufRead,BufFilePre *
                                      \ call s:update_oldfiles(expand('<afile>:p'))
                              endif
                              autocmd! startify VimEnter
                            endfunction
                            
    1              0.000001 function! s:on_vimleavepre()
                              if get(g:, 'startify_session_persistence')
                                    \ && exists('v:this_session')
                                    \ && filewritable(v:this_session)
                                call startify#session_write(fnameescape(v:this_session))
                              endif
                            endfunction
                            
    1              0.000008 command! -nargs=? -bar -bang -complete=customlist,startify#session_list SLoad   call startify#session_load(<bang>0, <f-args>)
    1              0.000005 command! -nargs=? -bar -bang -complete=customlist,startify#session_list SSave   call startify#session_save(<bang>0, <f-args>)
    1              0.000003 command! -nargs=? -bar -bang -complete=customlist,startify#session_list SDelete call startify#session_delete(<bang>0, <f-args>)
    1              0.000003 command! -nargs=0 -bar SClose call startify#session_close()
    1              0.000003 command! -nargs=0 -bar Startify call startify#insane_in_the_membrane(0)
    1              0.000002 command! -nargs=0 -bar StartifyDebug call startify#debug()
                            
    1              0.000043 nnoremap <silent><plug>(startify-open-buffers) :<c-u>call startify#open_buffers()<cr>

SCRIPT  /home/tony/.config/nvim/autoload/plugged/fzf/plugin/fzf.vim
Sourced 1 time
Total time:   0.000779
 Self time:   0.000779

count  total (s)   self (s)
                            " Copyright (c) 2017 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000005 if exists('g:loaded_fzf')
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_fzf = 1
                            
    1              0.000005 let s:is_win = has('win32') || has('win64')
    1              0.000002 if s:is_win && &shellslash
                              set noshellslash
                              let s:base_dir = expand('<sfile>:h:h')
                              set shellslash
    1              0.000000 else
    1              0.000003   let s:base_dir = expand('<sfile>:h:h')
    1              0.000000 endif
    1              0.000001 if s:is_win
                              let s:term_marker = '&::FZF'
                            
                              function! s:fzf_call(fn, ...)
                                let shellslash = &shellslash
                                try
                                  set noshellslash
                                  return call(a:fn, a:000)
                                finally
                                  let &shellslash = shellslash
                                endtry
                              endfunction
                            
                              " Use utf-8 for fzf.vim commands
                              " Return array of shell commands for cmd.exe
                              function! s:enc_to_cp(str)
                                if !has('iconv')
                                  return a:str
                                endif
                                if !exists('s:codepage')
                                  let s:codepage = libcallnr('kernel32.dll', 'GetACP', 0)
                                endif
                                return iconv(a:str, &encoding, 'cp'.s:codepage)
                              endfunction
                              function! s:wrap_cmds(cmds)
                                return map([
                                  \ '@echo off',
                                  \ 'setlocal enabledelayedexpansion']
                                \ + (has('gui_running') ? ['set TERM= > nul'] : [])
                                \ + (type(a:cmds) == type([]) ? a:cmds : [a:cmds])
                                \ + ['endlocal'],
                                \ '<SID>enc_to_cp(v:val."\r")')
                              endfunction
    1              0.000000 else
    1              0.000001   let s:term_marker = ";#FZF"
                            
    1              0.000002   function! s:fzf_call(fn, ...)
                                return call(a:fn, a:000)
                              endfunction
                            
    1              0.000001   function! s:wrap_cmds(cmds)
                                return a:cmds
                              endfunction
                            
    1              0.000001   function! s:enc_to_cp(str)
                                return a:str
                              endfunction
    1              0.000000 endif
                            
    1              0.000001 function! s:shellesc_cmd(arg)
                              let escaped = substitute(a:arg, '[&|<>()@^]', '^&', 'g')
                              let escaped = substitute(escaped, '%', '%%', 'g')
                              let escaped = substitute(escaped, '"', '\\^&', 'g')
                              let escaped = substitute(escaped, '\(\\\+\)\(\\^\)', '\1\1\2', 'g')
                              return '^"'.substitute(escaped, '\(\\\+\)$', '\1\1', '').'^"'
                            endfunction
                            
    1              0.000001 function! fzf#shellescape(arg, ...)
                              let shell = get(a:000, 0, s:is_win ? 'cmd.exe' : 'sh')
                              if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
                              endif
                              return s:fzf_call('shellescape', a:arg)
                            endfunction
                            
    1              0.000001 function! s:fzf_getcwd()
                              return s:fzf_call('getcwd')
                            endfunction
                            
    1              0.000001 function! s:fzf_fnamemodify(fname, mods)
                              return s:fzf_call('fnamemodify', a:fname, a:mods)
                            endfunction
                            
    1              0.000001 function! s:fzf_expand(fmt)
                              return s:fzf_call('expand', a:fmt, 1)
                            endfunction
                            
    1              0.000001 function! s:fzf_tempname()
                              return s:fzf_call('tempname')
                            endfunction
                            
    1              0.000003 let s:layout_keys = ['window', 'tmux', 'up', 'down', 'left', 'right']
    1              0.000002 let s:fzf_go = s:base_dir.'/bin/fzf'
    1              0.000001 let s:fzf_tmux = s:base_dir.'/bin/fzf-tmux'
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000004 set cpo&vim
                            
    1              0.000001 function! s:popup_support()
                              return has('nvim') ? has('nvim-0.4') : has('popupwin') && has('patch-8.2.191')
                            endfunction
                            
    1              0.000001 function! s:default_layout()
                              return s:popup_support()
                                    \ ? { 'window' : { 'width': 0.9, 'height': 0.6 } }
                                    \ : { 'down': '~40%' }
                            endfunction
                            
    1              0.000001 function! fzf#install()
                              if s:is_win && !has('win32unix')
                                let script = s:base_dir.'/install.ps1'
                                if !filereadable(script)
                                  throw script.' not found'
                                endif
                                let script = 'powershell -ExecutionPolicy Bypass -file ' . script
                              else
                                let script = s:base_dir.'/install'
                                if !executable(script)
                                  throw script.' not found'
                                endif
                                let script .= ' --bin'
                              endif
                            
                              call s:warn('Running fzf installer ...')
                              call system(script)
                              if v:shell_error
                                throw 'Failed to download fzf: '.script
                              endif
                            endfunction
                            
    1              0.000002 let s:versions = {}
    1              0.000001 function s:get_version(bin)
                              if has_key(s:versions, a:bin)
                                return s:versions[a:bin]
                              end
                              let command = a:bin . ' --version --no-height'
                              let output = systemlist(command)
                              if v:shell_error || empty(output)
                                return ''
                              endif
                              let ver = matchstr(output[-1], '[0-9.]\+')
                              let s:versions[a:bin] = ver
                              return ver
                            endfunction
                            
    1              0.000001 function! s:compare_versions(a, b)
                              let a = split(a:a, '\.')
                              let b = split(a:b, '\.')
                              for idx in range(0, max([len(a), len(b)]) - 1)
                                let v1 = str2nr(get(a, idx, 0))
                                let v2 = str2nr(get(b, idx, 0))
                                if     v1 < v2 | return -1
                                elseif v1 > v2 | return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000001 function! s:compare_binary_versions(a, b)
                              return s:compare_versions(s:get_version(a:a), s:get_version(a:b))
                            endfunction
                            
    1              0.000001 let s:checked = {}
    1              0.000001 function! fzf#exec(...)
                              if !exists('s:exec')
                                let binaries = []
                                if executable('fzf')
                                  call add(binaries, 'fzf')
                                endif
                                if executable(s:fzf_go)
                                  call add(binaries, s:fzf_go)
                                endif
                            
                                if empty(binaries)
                                  if input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                    redraw
                                    call fzf#install()
                                    return fzf#exec()
                                  else
                                    redraw
                                    throw 'fzf executable not found'
                                  endif
                                elseif len(binaries) > 1
                                  call sort(binaries, 's:compare_binary_versions')
                                endif
                            
                                let s:exec = binaries[-1]
                              endif
                            
                              if a:0 && !has_key(s:checked, a:1)
                                let fzf_version = s:get_version(s:exec)
                                if empty(fzf_version)
                                  let message = printf('Failed to run "%s --version"', s:exec)
                                  unlet s:exec
                                  throw message
                                end
                            
                                if s:compare_versions(fzf_version, a:1) >= 0
                                  let s:checked[a:1] = 1
                                  return s:exec
                                elseif a:0 < 2 && input(printf('You need fzf %s or above. Found: %s. Download binary? (y/n) ', a:1, fzf_version)) =~? '^y'
                                  let s:versions = {}
                                  unlet s:exec
                                  redraw
                                  call fzf#install()
                                  return fzf#exec(a:1, 1)
                                else
                                  throw printf('You need to upgrade fzf (required: %s or above)', a:1)
                                endif
                              endif
                            
                              return s:exec
                            endfunction
                            
    1              0.000001 function! s:tmux_enabled()
                              if has('gui_running') || !exists('$TMUX')
                                return 0
                              endif
                            
                              if exists('s:tmux')
                                return s:tmux
                              endif
                            
                              let s:tmux = 0
                              if !executable(s:fzf_tmux)
                                if executable('fzf-tmux')
                                  let s:fzf_tmux = 'fzf-tmux'
                                else
                                  return 0
                                endif
                              endif
                            
                              let output = system('tmux -V')
                              let s:tmux = !v:shell_error && output >= 'tmux 1.7'
                              return s:tmux
                            endfunction
                            
    1              0.000001 function! s:escape(path)
                              let path = fnameescape(a:path)
                              return s:is_win ? escape(path, '$') : path
                            endfunction
                            
    1              0.000001 function! s:error(msg)
                              echohl ErrorMsg
                              echom a:msg
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:warn(msg)
                              echohl WarningMsg
                              echom a:msg
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:has_any(dict, keys)
                              for key in a:keys
                                if has_key(a:dict, key)
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000001 function! s:open(cmd, target)
                              if stridx('edit', a:cmd) == 0 && s:fzf_fnamemodify(a:target, ':p') ==# s:fzf_expand('%:p')
                                return
                              endif
                              execute a:cmd s:escape(a:target)
                            endfunction
                            
    1              0.000001 function! s:common_sink(action, lines) abort
                              if len(a:lines) < 2
                                return
                              endif
                              let key = remove(a:lines, 0)
                              let Cmd = get(a:action, key, 'e')
                              if type(Cmd) == type(function('call'))
                                return Cmd(a:lines)
                              endif
                              if len(a:lines) > 1
                                augroup fzf_swap
                                  autocmd SwapExists * let v:swapchoice='o'
                                        \| call s:warn('fzf: E325: swap file exists: '.s:fzf_expand('<afile>'))
                                augroup END
                              endif
                              try
                                let empty = empty(s:fzf_expand('%')) && line('$') == 1 && empty(getline(1)) && !&modified
                                " Preserve the current working directory in case it's changed during
                                " the execution (e.g. `set autochdir` or `autocmd BufEnter * lcd ...`)
                                let cwd = exists('w:fzf_pushd') ? w:fzf_pushd.dir : expand('%:p:h')
                                for item in a:lines
                                  if item[0] != '~' && item !~ (s:is_win ? '^[A-Z]:\' : '^/')
                                    let sep = s:is_win ? '\' : '/'
                                    let item = join([cwd, item], cwd[len(cwd)-1] == sep ? '' : sep)
                                  endif
                                  if empty
                                    execute 'e' s:escape(item)
                                    let empty = 0
                                  else
                                    call s:open(Cmd, item)
                                  endif
                                  if !has('patch-8.0.0177') && !has('nvim-0.2') && exists('#BufEnter')
                                        \ && isdirectory(item)
                                    doautocmd BufEnter
                                  endif
                                endfor
                              catch /^Vim:Interrupt$/
                              finally
                                silent! autocmd! fzf_swap
                              endtry
                            endfunction
                            
    1              0.000001 function! s:get_color(attr, ...)
                              let gui = !s:is_win && !has('win32unix') && has('termguicolors') && &termguicolors
                              let fam = gui ? 'gui' : 'cterm'
                              let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
                              for group in a:000
                                let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
                                if code =~? pat
                                  return code
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000001 function! s:defaults()
                              let rules = copy(get(g:, 'fzf_colors', {}))
                              let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
                              return empty(colors) ? '' : fzf#shellescape('--color='.colors)
                            endfunction
                            
    1              0.000001 function! s:validate_layout(layout)
                              for key in keys(a:layout)
                                if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s',
                                        \ key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
                                endif
                              endfor
                              return a:layout
                            endfunction
                            
    1              0.000001 function! s:evaluate_opts(options)
                              return type(a:options) == type([]) ?
                                    \ join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options
                            endfunction
                            
                            " [name string,] [opts dict,] [fullscreen boolean]
    1              0.000001 function! fzf#wrap(...)
                              let args = ['', {}, 0]
                              let expects = map(copy(args), 'type(v:val)')
                              let tidx = 0
                              for arg in copy(a:000)
                                let tidx = index(expects, type(arg) == 6 ? type(0) : type(arg), tidx)
                                if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
                                endif
                                let args[tidx] = arg
                                let tidx += 1
                                unlet arg
                              endfor
                              let [name, opts, bang] = args
                            
                              if len(name)
                                let opts.name = name
                              end
                            
                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
                              if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
                              elseif !s:has_any(opts, s:layout_keys)
                                if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
                                else
                                  let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout())))
                                endif
                              endif
                            
                              " Colors: g:fzf_colors
                              let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                            
                              " History: g:fzf_history_dir
                              if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
                              endif
                            
                              " Action: g:fzf_action
                              if !s:has_any(opts, ['sink', 'sinklist', 'sink*'])
                                let opts._action = get(g:, 'fzf_action', s:default_action)
                                let opts.options .= ' --expect='.join(keys(opts._action), ',')
                                function! opts.sinklist(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
                                let opts['sink*'] = opts.sinklist " For backward compatibility
                              endif
                            
                              return opts
                            endfunction
                            
    1              0.000001 function! s:use_sh()
                              let [shell, shellslash, shellcmdflag, shellxquote] = [&shell, &shellslash, &shellcmdflag, &shellxquote]
                              if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                                let &shellcmdflag = has('nvim') ? '/s /c' : '/c'
                                let &shellxquote = has('nvim') ? '"' : '('
                              else
                                set shell=sh
                              endif
                              return [shell, shellslash, shellcmdflag, shellxquote]
                            endfunction
                            
    1              0.000001 function! s:writefile(...)
                              if call('writefile', a:000) == -1
                                throw 'Failed to write temporary file. Check if you can write to the path tempname() returns.'
                              endif
                            endfunction
                            
    1              0.000001 function! fzf#run(...) abort
                            try
                              let [shell, shellslash, shellcmdflag, shellxquote] = s:use_sh()
                            
                              let dict   = exists('a:1') ? copy(a:1) : {}
                              let temps  = { 'result': s:fzf_tempname() }
                              let optstr = s:evaluate_opts(get(dict, 'options', ''))
                              try
                                let fzf_exec = fzf#shellescape(fzf#exec())
                              catch
                                throw v:exception
                              endtry
                            
                              if !s:present(dict, 'dir')
                                let dict.dir = s:fzf_getcwd()
                              endif
                              if has('win32unix') && s:present(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
                              endif
                            
                              if has_key(dict, 'source')
                                let source = remove(dict, 'source')
                                let type = type(source)
                                if type == 1
                                  let source_command = source
                                elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call s:writefile(source, temps.input)
                                  let source_command = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input)
                                else
                                  throw 'Invalid source type'
                                endif
                              else
                                let source_command = ''
                              endif
                            
                              let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0) || has_key(dict, 'tmux')
                              let use_height = has_key(dict, 'down') && !has('gui_running') &&
                                    \ !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) &&
                                    \ executable('tput') && filereadable('/dev/tty')
                              let has_vim8_term = has('terminal') && has('patch-8.0.995')
                              let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
                              let use_term = has_nvim_term ||
                                \ has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || s:present(dict, 'down', 'up', 'left', 'right', 'window'))
                              let use_tmux = (has_key(dict, 'tmux') || (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:splittable(dict)) && s:tmux_enabled()
                              if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
                              endif
                              if use_term
                                let optstr .= ' --no-height'
                              elseif use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
                              endif
                              let optstr .= s:border_opt(get(dict, 'window', 0))
                              let prev_default_command = $FZF_DEFAULT_COMMAND
                              if len(source_command)
                                let $FZF_DEFAULT_COMMAND = source_command
                              endif
                              let command = (use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
                              if use_term
                                return s:execute_term(dict, command, temps)
                              endif
                            
                              let lines = use_tmux ? s:execute_tmux(dict, command, temps)
                                             \ : s:execute(dict, command, use_height, temps)
                              call s:callback(dict, lines)
                              return lines
                            finally
                              if exists('source_command') && len(source_command)
                                if len(prev_default_command)
                                  let $FZF_DEFAULT_COMMAND = prev_default_command
                                else
                                  let $FZF_DEFAULT_COMMAND = ''
                                  silent! execute 'unlet $FZF_DEFAULT_COMMAND'
                                endif
                              endif
                              let [&shell, &shellslash, &shellcmdflag, &shellxquote] = [shell, shellslash, shellcmdflag, shellxquote]
                            endtry
                            endfunction
                            
    1              0.000001 function! s:present(dict, ...)
                              for key in a:000
                                if !empty(get(a:dict, key, ''))
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000001 function! s:fzf_tmux(dict)
                              let size = get(a:dict, 'tmux', '')
                              if empty(size)
                                for o in ['up', 'down', 'left', 'right']
                                  if s:present(a:dict, o)
                                    let spec = a:dict[o]
                                    if (o == 'up' || o == 'down') && spec[0] == '~'
                                      let size = '-'.o[0].s:calc_size(&lines, spec, a:dict)
                                    else
                                      " Legacy boolean option
                                      let size = '-'.o[0].(spec == 1 ? '' : substitute(spec, '^\~', '', ''))
                                    endif
                                    break
                                  endif
                                endfor
                              endif
                              return printf('LINES=%d COLUMNS=%d %s %s - --',
                                \ &lines, &columns, fzf#shellescape(s:fzf_tmux), size)
                            endfunction
                            
    1              0.000001 function! s:splittable(dict)
                              return s:present(a:dict, 'up', 'down') && &lines > 15 ||
                                    \ s:present(a:dict, 'left', 'right') && &columns > 40
                            endfunction
                            
    1              0.000001 function! s:pushd(dict)
                              if s:present(a:dict, 'dir')
                                let cwd = s:fzf_getcwd()
                                let w:fzf_pushd = {
                                \   'command': haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'),
                                \   'origin': cwd,
                                \   'bufname': bufname('')
                                \ }
                                execute 'lcd' s:escape(a:dict.dir)
                                let cwd = s:fzf_getcwd()
                                let w:fzf_pushd.dir = cwd
                                let a:dict.pushd = w:fzf_pushd
                                return cwd
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 augroup fzf_popd
    1              0.000254   autocmd!
    1              0.000008   autocmd WinEnter * call s:dopopd()
    1              0.000001 augroup END
                            
    1              0.000002 function! s:dopopd()
                              if !exists('w:fzf_pushd')
                                return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd
                            endfunction
                            
    1              0.000001 function! s:xterm_launcher()
                              let fmt = 'xterm -T "[fzf]" -bg "%s" -fg "%s" -geometry %dx%d+%d+%d -e bash -ic %%s'
                              if has('gui_macvim')
                                let fmt .= '&& osascript -e "tell application \"MacVim\" to activate"'
                              endif
                              return printf(fmt,
                                \ escape(synIDattr(hlID("Normal"), "bg"), '#'), escape(synIDattr(hlID("Normal"), "fg"), '#'),
                                \ &columns, &lines/2, getwinposx(), getwinposy())
                            endfunction
    1              0.000002 unlet! s:launcher
    1              0.000005 if s:is_win || has('win32unix')
                              let s:launcher = '%s'
    1              0.000001 else
    1              0.000004   let s:launcher = function('s:xterm_launcher')
    1              0.000000 endif
                            
    1              0.000001 function! s:exit_handler(code, command, ...)
                              if a:code == 130
                                return 0
                              elseif has('nvim') && a:code == 129
                                " When deleting the terminal buffer while fzf is still running,
                                " Nvim sends SIGHUP.
                                return 0
                              elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
                              endif
                              return 1
                            endfunction
                            
    1              0.000001 function! s:execute(dict, command, use_height, temps) abort
                              call s:pushd(a:dict)
                              if has('unix') && !a:use_height
                                silent! !clear 2> /dev/null
                              endif
                              let escaped = (a:use_height || s:is_win) ? a:command : escape(substitute(a:command, '\n', '\\n', 'g'), '%#!')
                              if has('gui_running')
                                let Launcher = get(a:dict, 'launcher', get(g:, 'Fzf_launcher', get(g:, 'fzf_launcher', s:launcher)))
                                let fmt = type(Launcher) == 2 ? call(Launcher, []) : Launcher
                                if has('unix')
                                  let escaped = "'".substitute(escaped, "'", "'\"'\"'", 'g')."'"
                                endif
                                let command = printf(fmt, escaped)
                              else
                                let command = escaped
                              endif
                              if s:is_win
                                let batchfile = s:fzf_tempname().'.bat'
                                call s:writefile(s:wrap_cmds(command), batchfile)
                                let command = batchfile
                                let a:temps.batchfile = batchfile
                                if has('nvim')
                                  let fzf = {}
                                  let fzf.dict = a:dict
                                  let fzf.temps = a:temps
                                  function! fzf.on_exit(job_id, exit_status, event) dict
                                    call s:pushd(self.dict)
                                    let lines = s:collect(self.temps)
                                    call s:callback(self.dict, lines)
                                  endfunction
                                  let cmd = 'start /wait cmd /c '.command
                                  call jobstart(cmd, fzf)
                                  return []
                                endif
                              elseif has('win32unix') && $TERM !=# 'cygwin'
                                let shellscript = s:fzf_tempname()
                                call s:writefile([command], shellscript)
                                let command = 'cmd.exe /C '.fzf#shellescape('set "TERM=" & start /WAIT sh -c '.shellscript)
                                let a:temps.shellscript = shellscript
                              endif
                              if a:use_height
                                call system(printf('tput cup %d > /dev/tty; tput cnorm > /dev/tty; %s < /dev/tty 2> /dev/tty', &lines, command))
                              else
                                execute 'silent !'.command
                              endif
                              let exit_status = v:shell_error
                              redraw!
                              let lines = s:collect(a:temps)
                              return s:exit_handler(exit_status, command) ? lines : []
                            endfunction
                            
    1              0.000001 function! s:execute_tmux(dict, command, temps) abort
                              let command = a:command
                              let cwd = s:pushd(a:dict)
                              if len(cwd)
                                " -c '#{pane_current_path}' is only available on tmux 1.9 or above
                                let command = join(['cd', fzf#shellescape(cwd), '&&', command])
                              endif
                            
                              call system(command)
                              let exit_status = v:shell_error
                              redraw!
                              let lines = s:collect(a:temps)
                              return s:exit_handler(exit_status, command) ? lines : []
                            endfunction
                            
    1              0.000001 function! s:calc_size(max, val, dict)
                              let val = substitute(a:val, '^\~', '', '')
                              if val =~ '%$'
                                let size = a:max * str2nr(val[:-2]) / 100
                              else
                                let size = min([a:max, str2nr(val)])
                              endif
                            
                              let srcsz = -1
                              if type(get(a:dict, 'source', 0)) == type([])
                                let srcsz = len(a:dict.source)
                              endif
                            
                              let opts = $FZF_DEFAULT_OPTS.' '.s:evaluate_opts(get(a:dict, 'options', ''))
                              if opts =~ 'preview'
                                return size
                              endif
                              let margin = match(opts, '--inline-info\|--info[^-]\{-}inline') > match(opts, '--no-inline-info\|--info[^-]\{-}\(default\|hidden\)') ? 1 : 2
                              let margin += stridx(opts, '--border') > stridx(opts, '--no-border') ? 2 : 0
                              if stridx(opts, '--header') > stridx(opts, '--no-header')
                                let margin += len(split(opts, "\n"))
                              endif
                              return srcsz >= 0 ? min([srcsz + margin, size]) : size
                            endfunction
                            
    1              0.000001 function! s:getpos()
                              return {'tab': tabpagenr(), 'win': winnr(), 'winid': win_getid(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}
                            endfunction
                            
    1              0.000001 function! s:border_opt(window)
                              if type(a:window) != type({})
                                return ''
                              endif
                            
                              " Border style
                              let style = tolower(get(a:window, 'border', 'rounded'))
                              if !has_key(a:window, 'border') && !get(a:window, 'rounded', 1)
                                let style = 'sharp'
                              endif
                              if style == 'none' || style == 'no'
                                return ''
                              endif
                            
                              " For --border styles, we need fzf 0.24.0 or above
                              call fzf#exec('0.24.0')
                              let opt = ' --border=' . style
                              if has_key(a:window, 'highlight')
                                let color = s:get_color('fg', a:window.highlight)
                                if len(color)
                                  let opt .= ' --color=border:' . color
                                endif
                              endif
                              return opt
                            endfunction
                            
    1              0.000001 function! s:split(dict)
                              let directions = {
                              \ 'up':    ['topleft', 'resize', &lines],
                              \ 'down':  ['botright', 'resize', &lines],
                              \ 'left':  ['vertical topleft', 'vertical resize', &columns],
                              \ 'right': ['vertical botright', 'vertical resize', &columns] }
                              let ppos = s:getpos()
                              let is_popup = 0
                              try
                                if s:present(a:dict, 'window')
                                  if type(a:dict.window) == type({})
                                    if !s:popup_support()
                                      throw 'Nvim 0.4+ or Vim 8.2.191+ with popupwin feature is required for pop-up window'
                                    end
                                    call s:popup(a:dict.window)
                                    let is_popup = 1
                                  else
                                    execute 'keepalt' a:dict.window
                                  endif
                                elseif !s:splittable(a:dict)
                                  execute (tabpagenr()-1).'tabnew'
                                else
                                  for [dir, triple] in items(directions)
                                    let val = get(a:dict, dir, '')
                                    if !empty(val)
                                      let [cmd, resz, max] = triple
                                      if (dir == 'up' || dir == 'down') && val[0] == '~'
                                        let sz = s:calc_size(max, val, a:dict)
                                      else
                                        let sz = s:calc_size(max, val, {})
                                      endif
                                      execute cmd sz.'new'
                                      execute resz sz
                                      return [ppos, {}, is_popup]
                                    endif
                                  endfor
                                endif
                                return [ppos, is_popup ? {} : { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }, is_popup]
                              finally
                                if !is_popup
                                  setlocal winfixwidth winfixheight
                                endif
                              endtry
                            endfunction
                            
    1              0.000028 nnoremap <silent> <Plug>(fzf-insert) i
    1              0.000007 nnoremap <silent> <Plug>(fzf-normal) <Nop>
    1              0.000002 if exists(':tnoremap')
    1              0.000007   tnoremap <silent> <Plug>(fzf-insert) <C-\><C-n>i
    1              0.000005   tnoremap <silent> <Plug>(fzf-normal) <C-\><C-n>
    1              0.000000 endif
                            
    1              0.000001 function! s:execute_term(dict, command, temps) abort
                              let winrest = winrestcmd()
                              let pbuf = bufnr('')
                              let [ppos, winopts, is_popup] = s:split(a:dict)
                              call s:use_sh()
                              let b:fzf = a:dict
                              let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps,
                                        \ 'winopts': winopts, 'winrest': winrest, 'lines': &lines,
                                        \ 'columns': &columns, 'command': a:command }
                              function! fzf.switch_back(inplace)
                                if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt keepjumps b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif
                              endfunction
                              function! fzf.on_exit(id, code, ...)
                                if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
                                  if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
                                    close
                                  endif
                                  silent! execute 'tabnext' self.ppos.tab
                                  silent! execute self.ppos.win.'wincmd w'
                                endif
                            
                                if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif
                            
                                if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                  execute self.winrest
                                endif
                            
                                let lines = s:collect(self.temps)
                                if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif
                            
                                call s:pushd(self.dict)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)
                            
                                if &buftype == 'terminal'
                                  call feedkeys(&filetype == 'fzf' ? "\<Plug>(fzf-insert)" : "\<Plug>(fzf-normal)")
                                endif
                              endfunction
                            
                              try
                                call s:pushd(a:dict)
                                if s:is_win
                                  let fzf.temps.batchfile = s:fzf_tempname().'.bat'
                                  call s:writefile(s:wrap_cmds(a:command), fzf.temps.batchfile)
                                  let command = fzf.temps.batchfile
                                else
                                  let command = a:command
                                endif
                                let command .= s:term_marker
                                if has('nvim')
                                  call termopen(command, fzf)
                                else
                                  let term_opts = {'exit_cb': function(fzf.on_exit)}
                                  if v:version >= 802
                                    let term_opts.term_kill = 'term'
                                  endif
                                  if is_popup
                                    let term_opts.hidden = 1
                                  else
                                    let term_opts.curwin = 1
                                  endif
                                  let fzf.buf = term_start([&shell, &shellcmdflag, command], term_opts)
                                  if is_popup && exists('#TerminalWinOpen')
                                    doautocmd <nomodeline> TerminalWinOpen
                                  endif
                                  if !has('patch-8.0.1261') && !s:is_win
                                    call term_wait(fzf.buf, 20)
                                  endif
                                endif
                                tnoremap <buffer> <c-z> <nop>
                                if exists('&termwinkey') && (empty(&termwinkey) || &termwinkey =~? '<c-w>')
                                  tnoremap <buffer> <c-w> <c-w>.
                                endif
                              finally
                                call s:dopopd()
                              endtry
                              setlocal nospell bufhidden=wipe nobuflisted nonumber
                              setf fzf
                              startinsert
                              return []
                            endfunction
                            
    1              0.000001 function! s:collect(temps) abort
                              try
                                return filereadable(a:temps.result) ? readfile(a:temps.result) : []
                              finally
                                for tf in values(a:temps)
                                  silent! call delete(tf)
                                endfor
                              endtry
                            endfunction
                            
    1              0.000001 function! s:callback(dict, lines) abort
                              let popd = has_key(a:dict, 'pushd')
                              if popd
                                let w:fzf_pushd = a:dict.pushd
                              endif
                            
                              try
                                if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
                                endif
                                if has_key(a:dict, 'sink*')
                                  call a:dict['sink*'](a:lines)
                                elseif has_key(a:dict, 'sinklist')
                                  call a:dict['sinklist'](a:lines)
                                endif
                              catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
                              endtry
                            
                              " We may have opened a new window or tab
                              if popd
                                let w:fzf_pushd = a:dict.pushd
                                call s:dopopd()
                              endif
                            endfunction
                            
    1              0.000002 if has('nvim')
    1              0.000001   function s:create_popup(hl, opts) abort
                                let buf = nvim_create_buf(v:false, v:true)
                                let opts = extend({'relative': 'editor', 'style': 'minimal'}, a:opts)
                                let win = nvim_open_win(buf, v:true, opts)
                                call setwinvar(win, '&winhighlight', 'NormalFloat:'..a:hl)
                                call setwinvar(win, '&colorcolumn', '')
                                return buf
                              endfunction
                            else
                              function! s:create_popup(hl, opts) abort
                                let s:popup_create = {buf -> popup_create(buf, #{
                                  \ line: a:opts.row,
                                  \ col: a:opts.col,
                                  \ minwidth: a:opts.width,
                                  \ maxwidth: a:opts.width,
                                  \ minheight: a:opts.height,
                                  \ maxheight: a:opts.height,
                                  \ zindex: 1000,
                                \ })}
                                autocmd TerminalOpen * ++once call s:popup_create(str2nr(expand('<abuf>')))
                              endfunction
    1              0.000001 endif
                            
    1              0.000001 function! s:popup(opts) abort
                              let xoffset = get(a:opts, 'xoffset', 0.5)
                              let yoffset = get(a:opts, 'yoffset', 0.5)
                              let relative = get(a:opts, 'relative', 0)
                            
                              " Use current window size for positioning relatively positioned popups
                              let columns = relative ? winwidth(0) : &columns
                              let lines = relative ? winheight(0) : (&lines - has('nvim'))
                            
                              " Size and position
                              let width = min([max([8, a:opts.width > 1 ? a:opts.width : float2nr(columns * a:opts.width)]), columns])
                              let height = min([max([4, a:opts.height > 1 ? a:opts.height : float2nr(lines * a:opts.height)]), lines])
                              let row = float2nr(yoffset * (lines - height)) + (relative ? win_screenpos(0)[0] - 1 : 0)
                              let col = float2nr(xoffset * (columns - width)) + (relative ? win_screenpos(0)[1] - 1 : 0)
                            
                              " Managing the differences
                              let row = min([max([0, row]), &lines - has('nvim') - height])
                              let col = min([max([0, col]), &columns - width])
                              let row += !has('nvim')
                              let col += !has('nvim')
                            
                              call s:create_popup('Normal', {
                                \ 'row': row, 'col': col, 'width': width, 'height': height
                              \ })
                            endfunction
                            
    1              0.000004 let s:default_action = {
                              \ 'ctrl-t': 'tab split',
                              \ 'ctrl-x': 'split',
                              \ 'ctrl-v': 'vsplit' }
                            
    1              0.000001 function! s:shortpath()
                              let short = fnamemodify(getcwd(), ':~:.')
                              if !has('win32unix')
                                let short = pathshorten(short)
                              endif
                              let slash = (s:is_win && !&shellslash) ? '\' : '/'
                              return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)
                            endfunction
                            
    1              0.000001 function! s:cmd(bang, ...) abort
                              let args = copy(a:000)
                              let opts = { 'options': ['--multi'] }
                              if len(args) && isdirectory(expand(args[-1]))
                                let opts.dir = substitute(substitute(remove(args, -1), '\\\(["'']\)', '\1', 'g'), '[/\\]*$', '/', '')
                                if s:is_win && !&shellslash
                                  let opts.dir = substitute(opts.dir, '/', '\\', 'g')
                                endif
                                let prompt = opts.dir
                              else
                                let prompt = s:shortpath()
                              endif
                              let prompt = strwidth(prompt) < &columns - 20 ? prompt : '> '
                              call extend(opts.options, ['--prompt', prompt])
                              call extend(opts.options, args)
                              call fzf#run(fzf#wrap('FZF', opts, a:bang))
                            endfunction
                            
    1              0.000006 command! -nargs=* -complete=dir -bang FZF call s:cmd(<bang>0, <f-args>)
                            
    1              0.000006 let &cpo = s:cpo_save
    1              0.000014 unlet s:cpo_save

SCRIPT  /home/tony/.config/nvim/autoload/plugged/fzf.vim/plugin/fzf.vim
Sourced 1 time
Total time:   0.001007
 Self time:   0.000709

count  total (s)   self (s)
                            " Copyright (c) 2015 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000005 if exists('g:loaded_fzf_vim')
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_fzf_vim = 1
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000004 set cpo&vim
    1              0.000005 let s:is_win = has('win32') || has('win64')
                            
    1              0.000002 function! s:defs(commands)
                              let prefix = get(g:, 'fzf_command_prefix', '')
                              if prefix =~# '^[^A-Z]'
                                echoerr 'g:fzf_command_prefix must start with an uppercase letter'
                                return
                              endif
                              for command in a:commands
                                let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
                                if 2 != exists(name)
                                  execute substitute(command, '\ze\C[A-Z]', prefix, '')
                                endif
                              endfor
                            endfunction
                            
    1   0.000344   0.000046 call s:defs([
                            \'command!      -bang -nargs=? -complete=dir Files       call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)',
                            \'command!      -bang -nargs=? GitFiles                  call fzf#vim#gitfiles(<q-args>, fzf#vim#with_preview(<q-args> == "?" ? { "placeholder": "" } : {}), <bang>0)',
                            \'command!      -bang -nargs=? GFiles                    call fzf#vim#gitfiles(<q-args>, fzf#vim#with_preview(<q-args> == "?" ? { "placeholder": "" } : {}), <bang>0)',
                            \'command! -bar -bang -nargs=? -complete=buffer Buffers  call fzf#vim#buffers(<q-args>, fzf#vim#with_preview({ "placeholder": "{1}" }), <bang>0)',
                            \'command!      -bang -nargs=* Lines                     call fzf#vim#lines(<q-args>, <bang>0)',
                            \'command!      -bang -nargs=* BLines                    call fzf#vim#buffer_lines(<q-args>, <bang>0)',
                            \'command! -bar -bang Colors                             call fzf#vim#colors(<bang>0)',
                            \'command!      -bang -nargs=+ -complete=dir Locate      call fzf#vim#locate(<q-args>, fzf#vim#with_preview(), <bang>0)',
                            \'command!      -bang -nargs=* Ag                        call fzf#vim#ag(<q-args>, fzf#vim#with_preview(), <bang>0)',
                            \'command!      -bang -nargs=* Rg                        call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case -- ".shellescape(<q-args>), 1, fzf#vim#with_preview(), <bang>0)',
                            \'command!      -bang -nargs=* Tags                      call fzf#vim#tags(<q-args>, fzf#vim#with_preview({ "placeholder": "--tag {2}:{-1}:{3..}" }), <bang>0)',
                            \'command!      -bang -nargs=* BTags                     call fzf#vim#buffer_tags(<q-args>, fzf#vim#with_preview({ "placeholder": "{2}:{3..}" }), <bang>0)',
                            \'command! -bar -bang Snippets                           call fzf#vim#snippets(<bang>0)',
                            \'command! -bar -bang Commands                           call fzf#vim#commands(<bang>0)',
                            \'command! -bar -bang Marks                              call fzf#vim#marks(<bang>0)',
                            \'command! -bar -bang Helptags                           call fzf#vim#helptags(fzf#vim#with_preview({ "placeholder": "--tag {2}:{3}:{4}" }), <bang>0)',
                            \'command! -bar -bang Windows                            call fzf#vim#windows(<bang>0)',
                            \'command! -bar -bang -range=% Commits                   let b:fzf_winview = winsaveview() | <line1>,<line2>call fzf#vim#commits(fzf#vim#with_preview({ "placeholder": "" }), <bang>0)',
                            \'command! -bar -bang -range=% BCommits                  let b:fzf_winview = winsaveview() | <line1>,<line2>call fzf#vim#buffer_commits(fzf#vim#with_preview({ "placeholder": "" }), <bang>0)',
                            \'command! -bar -bang Maps                               call fzf#vim#maps("n", <bang>0)',
                            \'command! -bar -bang Filetypes                          call fzf#vim#filetypes(<bang>0)',
                            \'command!      -bang -nargs=* History                   call s:history(<q-args>, fzf#vim#with_preview(), <bang>0)'])
                            
    1              0.000002 function! s:history(arg, extra, bang)
                              let bang = a:bang || a:arg[len(a:arg)-1] == '!'
                              if a:arg[0] == ':'
                                call fzf#vim#command_history(bang)
                              elseif a:arg[0] == '/'
                                call fzf#vim#search_history(bang)
                              else
                                call fzf#vim#history(a:extra, bang)
                              endif
                            endfunction
                            
    1              0.000001 function! fzf#complete(...)
                              return call('fzf#vim#complete', a:000)
                            endfunction
                            
    1              0.000006 if (has('nvim') || has('terminal') && has('patch-8.0.995')) && (get(g:, 'fzf_statusline', 1) || get(g:, 'fzf_nvim_statusline', 1))
    1              0.000001   function! s:fzf_restore_colors()
                                if exists('#User#FzfStatusLine')
                                  doautocmd User FzfStatusLine
                                else
                                  if $TERM !~ "256color"
                                    highlight default fzf1 ctermfg=1 ctermbg=8 guifg=#E12672 guibg=#565656
                                    highlight default fzf2 ctermfg=2 ctermbg=8 guifg=#BCDDBD guibg=#565656
                                    highlight default fzf3 ctermfg=7 ctermbg=8 guifg=#D9D9D9 guibg=#565656
                                  else
                                    highlight default fzf1 ctermfg=161 ctermbg=238 guifg=#E12672 guibg=#565656
                                    highlight default fzf2 ctermfg=151 ctermbg=238 guifg=#BCDDBD guibg=#565656
                                    highlight default fzf3 ctermfg=252 ctermbg=238 guifg=#D9D9D9 guibg=#565656
                                  endif
                                  setlocal statusline=%#fzf1#\ >\ %#fzf2#fz%#fzf3#f
                                endif
                              endfunction
                            
    1              0.000001   function! s:fzf_vim_term()
                                if get(w:, 'airline_active', 0)
                                  let w:airline_disabled = 1
                                  autocmd BufWinLeave <buffer> let w:airline_disabled = 0
                                endif
                                autocmd WinEnter,ColorScheme <buffer> call s:fzf_restore_colors()
                            
                                setlocal nospell
                                call s:fzf_restore_colors()
                              endfunction
                            
    1              0.000002   augroup _fzf_statusline
    1              0.000253     autocmd!
    1              0.000005     autocmd FileType fzf call s:fzf_vim_term()
    1              0.000001   augroup END
    1              0.000000 endif
                            
    1              0.000003 if !exists('g:fzf#vim#buffers')
    1              0.000002   let g:fzf#vim#buffers = {}
    1              0.000000 endif
                            
    1              0.000001 augroup fzf_buffers
    1              0.000159   autocmd!
    1              0.000005   if exists('*reltimefloat')
    1              0.000005     autocmd BufWinEnter,WinEnter * let g:fzf#vim#buffers[bufnr('')] = reltimefloat(reltime())
                              else
                                autocmd BufWinEnter,WinEnter * let g:fzf#vim#buffers[bufnr('')] = localtime()
    1              0.000000   endif
    1              0.000002   autocmd BufDelete * silent! call remove(g:fzf#vim#buffers, expand('<abuf>'))
    1              0.000001 augroup END
                            
    1              0.000029 inoremap <expr> <plug>(fzf-complete-word)        fzf#vim#complete#word()
    1              0.000001 if s:is_win
                              inoremap <expr> <plug>(fzf-complete-path)      fzf#vim#complete#path('dir /s/b')
                              inoremap <expr> <plug>(fzf-complete-file)      fzf#vim#complete#path('dir /s/b/a:-d')
    1              0.000001 else
    1              0.000010   inoremap <expr> <plug>(fzf-complete-path)      fzf#vim#complete#path("find . -path '*/\.*' -prune -o -print \| sed '1d;s:^..::'")
    1              0.000012   inoremap <expr> <plug>(fzf-complete-file)      fzf#vim#complete#path("find . -path '*/\.*' -prune -o -type f -print -o -type l -print \| sed 's:^..::'")
    1              0.000001 endif
    1              0.000007 inoremap <expr> <plug>(fzf-complete-file-ag)     fzf#vim#complete#path('ag -l -g ""')
    1              0.000006 inoremap <expr> <plug>(fzf-complete-line)        fzf#vim#complete#line()
    1              0.000006 inoremap <expr> <plug>(fzf-complete-buffer-line) fzf#vim#complete#buffer_line()
                            
    1              0.000011 nnoremap <silent> <plug>(fzf-maps-n) :<c-u>call fzf#vim#maps('n', 0)<cr>
    1              0.000006 inoremap <silent> <plug>(fzf-maps-i) <c-o>:call fzf#vim#maps('i', 0)<cr>
    1              0.000009 xnoremap <silent> <plug>(fzf-maps-x) :<c-u>call fzf#vim#maps('x', 0)<cr>
    1              0.000008 onoremap <silent> <plug>(fzf-maps-o) <c-c>:<c-u>call fzf#vim#maps('o', 0)<cr>
                            
    1              0.000008 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim
Sourced 1 time
Total time:   0.000389
 Self time:   0.000389

count  total (s)   self (s)
                            " Vim plugin to change the working directory to the project root.
                            "
                            " Copyright 2010-2020 Andrew Stewart, <boss@airbladesoftware.com>
                            " Released under the MIT licence.
                            
    1              0.000008 if exists('g:loaded_rooter') || &cp
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_rooter = 1
                            
    1              0.000003 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000002 if !exists('g:rooter_manual_only')
    1              0.000001   let g:rooter_manual_only = 0
    1              0.000000 endif
                            
    1              0.000002 if exists('+autochdir') && &autochdir && !g:rooter_manual_only
    1              0.000006   set noautochdir
    1              0.000000 endif
                            
    1              0.000001 if exists('g:rooter_use_lcd')
                              echoerr 'vim-rooter: please replace g:rooter_use_lcd=1 with g:rooter_cd_cmd="lcd"'
                              let g:rooter_cd_cmd = 'lcd'
    1              0.000000 endif
                            
    1              0.000002 if !exists('g:rooter_cd_cmd')
    1              0.000001   let g:rooter_cd_cmd = 'cd'
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:rooter_patterns')
    1              0.000003   let g:rooter_patterns = ['.git', '_darcs', '.hg', '.bzr', '.svn', 'Makefile', 'package.json']
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:rooter_targets')
    1              0.000001   let g:rooter_targets = '/,*'
    1              0.000000 endif
                            
    1              0.000002 if !exists('g:rooter_change_directory_for_non_project_files')
    1              0.000001   let g:rooter_change_directory_for_non_project_files = ''
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:rooter_silent_chdir')
    1              0.000001   let g:rooter_silent_chdir = 0
    1              0.000000 endif
                            
    1              0.000001 if !exists('g:rooter_resolve_links')
    1              0.000001   let g:rooter_resolve_links = 0
    1              0.000000 endif
                            
                            
                            " For third-parties.  Not used by plugin.
    1              0.000002 function! FindRootDirectory()
                              return s:root()
                            endfunction
                            
                            
    1              0.000006 command! -bar Rooter call <SID>rooter()
    1              0.000002 command! -bar RooterToggle call <SID>toggle()
                            
                            
    1              0.000001 augroup rooter
    1              0.000209   autocmd!
    1              0.000008   autocmd VimEnter,BufReadPost,BufEnter * nested if !g:rooter_manual_only | Rooter | endif
    1              0.000002   autocmd BufWritePost * nested if !g:rooter_manual_only | call setbufvar('%', 'rootDir', '') | Rooter | endif
    1              0.000001 augroup END
                            
                            
    1              0.000003 function! s:rooter()
                              if !s:activate() | return | endif
                            
                              let root = getbufvar('%', 'rootDir')
                              if empty(root)
                                let root = s:root()
                                call setbufvar('%', 'rootDir', root)
                              endif
                            
                              if empty(root)
                                call s:rootless()
                                return
                              endif
                            
                              call s:cd(root)
                            endfunction
                            
                            
                            " Returns true if we should change to the buffer's root directory, false otherwise.
    1              0.000001 function! s:activate()
                              " Directory browser plugins (e.g. vim-dirvish, NERDTree) tend to
                              " set a nofile buftype when you open a directory.
                              if &buftype != '' && &buftype != 'nofile' | return 0 | endif
                            
                              let patterns = split(g:rooter_targets, ',')
                              let fn = expand('%:p', 1)
                            
                              if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
                            
                              " directory
                              if empty(fn) || fn[-1:] == '/'
                                return index(patterns, '/') != -1
                              endif
                            
                              " file
                              if !filereadable(fn) | return 0 | endif
                              if !exists('*glob2regpat') | return 1 | endif
                            
                              for p in filter(copy(patterns), 'v:val != "/"')
                                if fn =~ glob2regpat(p)
                                  return 1
                                endif
                              endfor
                            
                              return 0
                            endfunction
                            
                            
                            " Returns the root directory or an empty string if no root directory found.
    1              0.000001 function! s:root()
                              let dir = s:current()
                            
                              " breadth-first search
                              while 1
                                for pattern in g:rooter_patterns
                                  if pattern[0] == '!'
                                    let [p, exclude] = [pattern[1:], 1]
                                  else
                                    let [p, exclude] = [pattern, 0]
                                  endif
                                  if s:match(dir, p)
                                    if exclude
                                      break
                                    else
                                      return dir
                                    endif
                                  endif
                                endfor
                            
                                let [current, dir] = [dir, s:parent(dir)]
                                if current == dir | break | endif
                              endwhile
                            
                              return ''
                            endfunction
                            
                            
    1              0.000001 function s:match(dir, pattern)
                              if a:pattern[0] == '='
                                return s:is(a:dir, a:pattern[1:])
                              elseif a:pattern[0] == '^'
                                return s:sub(a:dir, a:pattern[1:])
                              elseif a:pattern[0] == '>'
                                return s:child(a:dir, a:pattern[1:])
                              else
                                return s:has(a:dir, a:pattern)
                              endif
                            endfunction
                            
                            
                            " Returns true if dir is identifier, false otherwise.
                            "
                            " dir        - full path to a directory
                            " identifier - a directory name
    1              0.000001 function! s:is(dir, identifier)
                              let identifier = substitute(a:identifier, '/$', '', '')
                              return fnamemodify(a:dir, ':t') ==# identifier
                            endfunction
                            
                            
                            " Returns true if dir contains identifier, false otherwise.
                            "
                            " dir        - full path to a directory
                            " identifier - a file name or a directory name; may be a glob
    1              0.000018 function! s:has(dir, identifier)
                              " We do not want a:dir to be treated as a glob so escape any wildcards.
                              " If this approach is problematic (e.g. on Windows), an alternative
                              " might be to change directory to a:dir, call globpath() with just
                              " a:identifier, then restore the working directory.
                              return !empty(globpath(escape(a:dir, '?*[]'), a:identifier, 1))
                            endfunction
                            
                            
                            " Returns true if identifier is an ancestor of dir,
                            " i.e. dir is a subdirectory (no matter how many levels) of identifier;
                            " false otherwise.
                            "
                            " dir        - full path to a directory
                            " identifier - a directory name
    1              0.000001 function! s:sub(dir, identifier)
                              let path = s:parent(a:dir)
                              while 1
                                if fnamemodify(path, ':t') ==# a:identifier | return 1 | endif
                                let [current, path] = [path, s:parent(path)]
                                if current == path | break | endif
                              endwhile
                              return 0
                            endfunction
                            
                            " Return true if identifier is a direct ancestor (parent) of dir,
                            " i.e. dir is a direct subdirectory (child) of identifier; false otherwise
                            "
                            " dir        - full path to a directory
                            " identifier - a directory name
    1              0.000001 function! s:child(dir, identifier)
                              let path = s:parent(a:dir)
                              return fnamemodify(path, ':t') ==# a:identifier
                            endfunction
                            
                            " Returns full path of directory of current file name (which may be a directory).
    1              0.000001 function! s:current()
                              let fn = expand('%:p', 1)
                              if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
                              if empty(fn) | return getcwd() | endif  " opening vim without a file
                              if g:rooter_resolve_links | let fn = resolve(fn) | endif
                              return fnamemodify(fn, ':h')
                            endfunction
                            
                            
                            " Returns full path of dir's parent directory.
    1              0.000001 function! s:parent(dir)
                              return fnamemodify(a:dir, ':h')
                            endfunction
                            
                            
                            " Changes to the given directory unless it is already the current one.
    1              0.000001 function! s:cd(dir)
                              if a:dir == getcwd() | return | endif
                              execute g:rooter_cd_cmd fnameescape(a:dir)
                              if !g:rooter_silent_chdir | redraw | echo 'cwd: '.a:dir | endif
                              if exists('#User#RooterChDir')
                                execute 'doautocmd' s:nomodeline 'User RooterChDir'
                              endif
                            endfunction
                            
                            
    1              0.000001 function! s:rootless()
                              let dir = ''
                              if g:rooter_change_directory_for_non_project_files ==? 'current'
                                let dir = s:current()
                              elseif g:rooter_change_directory_for_non_project_files ==? 'home'
                                let dir = $HOME
                              endif
                              if !empty(dir) | call s:cd(dir) | endif
                            endfunction
                            
                            
    1              0.000001 function! s:toggle()
                              if g:rooter_manual_only | Rooter | endif
                              let g:rooter_manual_only = !g:rooter_manual_only
                            endfunction
                            
                            
                            " vim:set ft=vim sw=2 sts=2 et:

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-signify/plugin/signify.vim
Sourced 1 time
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
                            " vim: et sw=2 sts=2 fdm=marker
                            
    1              0.000003 scriptencoding utf-8
                            
    1              0.000009 if exists('g:loaded_signify') || !has('signs') || &compatible
                              finish
    1              0.000001 endif
                            
    1              0.000002 let g:loaded_signify = 1
    1              0.000001 let g:signify_locked = 0
    1              0.000001 let g:signify_detecting = 0
                            
                            " Commands {{{1
    1              0.000005 command! -nargs=0 -bar       SignifyList            call sy#debug#list_active_buffers()
    1              0.000002 command! -nargs=0 -bar       SignifyDebug           call sy#repo#debug_detection()
    1              0.000004 command! -nargs=0 -bar -bang SignifyFold            call sy#fold#dispatch(<bang>1)
    1              0.000002 command! -nargs=0 -bar -bang SignifyDiff            call sy#repo#diffmode(<bang>1)
    1              0.000002 command! -nargs=0 -bar       SignifyHunkDiff        call sy#repo#diff_hunk()
    1              0.000002 command! -nargs=0 -bar       SignifyHunkUndo        call sy#repo#undo_hunk()
    1              0.000002 command! -nargs=0 -bar       SignifyRefresh         call sy#util#refresh_windows()
                            
    1              0.000001 command! -nargs=0 -bar       SignifyEnable          call sy#start()
    1              0.000001 command! -nargs=0 -bar       SignifyDisable         call sy#stop()
    1              0.000001 command! -nargs=0 -bar       SignifyToggle          call sy#toggle()
    1              0.000002 command! -nargs=0 -bar       SignifyToggleHighlight call sy#highlight#line_toggle()
    1              0.000001 command! -nargs=0 -bar       SignifyEnableAll       call sy#start_all()
    1              0.000001 command! -nargs=0 -bar       SignifyDisableAll      call sy#stop_all()
                            
                            " Mappings {{{1
    1              0.000001 let s:cpoptions = &cpoptions
    1              0.000004 set cpoptions+=B
                            
                            " hunk jumping
    1              0.000032 nnoremap <silent> <expr> <plug>(signify-next-hunk) &diff
                                  \ ? ']c'
                                  \ : ":\<c-u>call sy#jump#next_hunk(v:count1)\<cr>"
    1              0.000011 nnoremap <silent> <expr> <plug>(signify-prev-hunk) &diff
                                  \ ? '[c'
                                  \ : ":\<c-u>call sy#jump#prev_hunk(v:count1)\<cr>"
                            
    1              0.000013 if empty(maparg(']c', 'n')) && !hasmapto('<plug>(signify-next-hunk)', 'n')
                              nmap ]c <plug>(signify-next-hunk)
                              if empty(maparg(']C', 'n')) && !hasmapto('9999]c', 'n')
                                nmap ]C 9999]c
                              endif
    1              0.000000 endif
    1              0.000009 if empty(maparg('[c', 'n')) && !hasmapto('<plug>(signify-prev-hunk)', 'n')
                              nmap [c <plug>(signify-prev-hunk)
                              if empty(maparg('[C', 'n')) && !hasmapto('9999[c', 'n')
                                nmap [C 9999[c
                              end
    1              0.000000 endif
                            
                            " hunk text object
    1              0.000010 onoremap <silent> <plug>(signify-motion-inner-pending) :<c-u>call sy#util#hunk_text_object(0)<cr>
    1              0.000009 xnoremap <silent> <plug>(signify-motion-inner-visual)  :<c-u>call sy#util#hunk_text_object(0)<cr>
    1              0.000008 onoremap <silent> <plug>(signify-motion-outer-pending) :<c-u>call sy#util#hunk_text_object(1)<cr>
    1              0.000008 xnoremap <silent> <plug>(signify-motion-outer-visual)  :<c-u>call sy#util#hunk_text_object(1)<cr>
                            
    1              0.000003 let &cpoptions = s:cpoptions
    1              0.000002 unlet s:cpoptions
                            
                            " Autocmds {{{1
    1              0.000004 if has('gui_running') && has('win32') && argc()
                              " Fix 'no signs at start' race.
                              autocmd GUIEnter * redraw
    1              0.000000 endif
                            
    1              0.000005 autocmd QuickFixCmdPre  *vimgrep* let g:signify_locked = 1
    1              0.000002 autocmd QuickFixCmdPost *vimgrep* let g:signify_locked = 0
                            
    1              0.000005 autocmd BufNewFile,BufRead * nested
                                  \ if !get(g:, 'signify_disable_by_default') |
                                  \   call sy#start({'bufnr': bufnr('')}) |
                                  \ endif
                            " 1}}}
                            
    1              0.000002 if exists('#User#SignifySetup')
                              doautocmd <nomodeline> User SignifySetup
    1              0.000015 endif

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim
Sourced 1 time
Total time:   0.001281
 Self time:   0.001166

count  total (s)   self (s)
                            " fugitive.vim - A Git wrapper so awesome, it should be illegal
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      3.6
                            " GetLatestVimScripts: 2975 1 :AutoInstall: fugitive.vim
                            
    1              0.000004 if exists('g:loaded_fugitive')
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_fugitive = 1
                            
    1              0.000001 let s:bad_git_dir = '/$\|^fugitive:'
                            
                            " FugitiveGitDir() returns the detected Git dir for the given buffer number,
                            " or the current buffer if no argument is passed.  This will be an empty
                            " string if no Git dir was found.  Use !empty(FugitiveGitDir()) to check if
                            " Fugitive is active in the current buffer.  Do not rely on this for direct
                            " filesystem access; use FugitiveFind('.git/whatever') instead.
    1              0.000002 function! FugitiveGitDir(...) abort
                              if v:version < 703
                                return ''
                              elseif !a:0 || type(a:1) == type(0) && a:1 < 0 || a:1 is# get(v:, 'true', -1)
                                if exists('g:fugitive_event')
                                  return g:fugitive_event
                                endif
                                let dir = get(b:, 'git_dir', '')
                                if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
                                elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                  return b:git_dir
                                endif
                                return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type(0) && a:1 isnot# 0
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'git_dir', '')
                              else
                                return ''
                              endif
                            endfunction
                            
                            " FugitiveReal() takes a fugitive:// URL and returns the corresponding path in
                            " the work tree.  This may be useful to get a cleaner path for inclusion in
                            " the statusline, for example.  Note that the file and its parent directories
                            " are not guaranteed to exist.
                            "
                            " This is intended as an abstract API to be used on any "virtual" path.  For a
                            " buffer named foo://bar, check for a function named FooReal(), and if it
                            " exists, call FooReal("foo://bar").
    1              0.000001 function! FugitiveReal(...) abort
                              let file = a:0 ? a:1 : @%
                              if type(file) ==# type({})
                                let dir = FugitiveGitDir(file)
                                let tree = s:Tree(dir)
                                return FugitiveVimPath(empty(tree) ? dir : tree)
                              elseif file =~# '^\a\a\+:' || a:0 > 1
                                return call('fugitive#Real', [file] + a:000[1:-1])
                              elseif file =~# '^/\|^\a:\|^$'
                                return file
                              else
                                return fnamemodify(file, ':p' . (file =~# '[\/]$' ? '' : ':s?[\/]$??'))
                              endif
                            endfunction
                            
                            " FugitiveFind() takes a Fugitive object and returns the appropriate Vim
                            " buffer name.  You can use this to generate Fugitive URLs ("HEAD:README") or
                            " to get the absolute path to a file in the Git dir (".git/HEAD"), the common
                            " dir (".git/config"), or the work tree (":(top)Makefile").
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000001 function! FugitiveFind(...) abort
                              if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type(0))
                                return call('fugitive#Find', a:000[1:-1] + [FugitiveGitDir(a:1)])
                              else
                                return fugitive#Find(a:0 ? a:1 : bufnr(''), FugitiveGitDir(a:0 > 1 ? a:2 : -1))
                              endif
                            endfunction
                            
                            " FugitiveParse() takes a fugitive:// URL and returns a 2 element list
                            " containing an object name ("commit:file") and the Git dir.  It's effectively
                            " the inverse of FugitiveFind().
    1              0.000001 function! FugitiveParse(...) abort
                              let path = s:Slash(a:0 ? a:1 : @%)
                              if path !~# '^fugitive:'
                                return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg
                            endfunction
                            
                            " FugitiveGitVersion() queries the version of Git in use.  Pass up to 3
                            " arguments to return a Boolean of whether a certain minimum version is
                            " available (FugitiveGitVersion(2,3,4) checks for 2.3.4 or higher) or no
                            " arguments to get a raw string.
    1              0.000001 function! FugitiveGitVersion(...) abort
                              return call('fugitive#GitVersion', a:000)
                            endfunction
                            
                            " FugitiveResult() returns an object encapsulating the result of the most
                            " recent :Git command.  Will be empty if no result is available.  During a
                            " User FugitiveChanged event, this is guaranteed to correspond to the :Git
                            " command that triggered the event, or be empty if :Git was not the trigger.
                            " Pass in the name of a temp buffer to get the result object for that command
                            " instead.  Contains the following keys:
                            "
                            " * "args": List of command arguments, starting with the subcommand.  Will be
                            "   empty for usages like :Git --help.
                            " * "git_dir": Git dir of the relevant repository.
                            " * "exit_status": The integer exit code of the process.
                            " * "flags": Flags passed directly to Git, like -c and --help.
                            " * "file": Path to file containing command output.  Not guaranteed to exist,
                            "   so verify with filereadable() before trying to access it.
    1              0.000001 function! FugitiveResult(...) abort
                              return call('fugitive#Result', a:000)
                            endfunction
                            
                            " FugitiveExecute() runs Git with a list of arguments and returns a dictionary
                            " with the following keys:
                            "
                            " * "exit_status": The integer exit code of the process.
                            " * "stdout": The stdout produced by the process, as a list of lines.
                            " * "stderr": The stdout produced by the process, as a list of lines.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
                            "
                            " An optional final argument is a callback Funcref, for asynchronous
                            " execution.
    1              0.000001 function! FugitiveExecute(args, ...) abort
                              return call('fugitive#Execute', [a:args] + a:000)
                            endfunction
                            
                            " FugitiveShellCommand() turns an array of arugments into a Git command string
                            " which can be executed with functions like system() and commands like :!.
                            " Integer arguments will be treated as buffer numbers, and the appropriate
                            " relative path inserted in their place.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000001 function! FugitiveShellCommand(...) abort
                              return call('fugitive#ShellCommand', a:000)
                            endfunction
                            
                            " FugitivePrepare() is a deprecated alias for FugitiveShellCommand().  If you
                            " are using this in conjunction with system(), consider using
                            " FugitiveExecute() instead.
    1              0.000001 function! FugitivePrepare(...) abort
                              if !exists('s:did_prepare_warning')
                                let s:did_prepare_warning = 1
                                echohl WarningMsg
                                unsilent echomsg 'FugitivePrepare() has been superseded by FugitiveShellCommand()'
                                echohl NONE
                              endif
                              return call('fugitive#ShellCommand', a:000)
                            endfunction
                            
                            " FugitiveConfig() get returns an opaque structure that can be passed to other
                            " FugitiveConfig functions in lieu of a Git directory.  This can be faster
                            " when performing multiple config queries.  Do not rely on the internal
                            " structure of the return value as it is not guaranteed.  If you want a full
                            " dictionary of every config value, use FugitiveConfigGetRegexp('.*').
                            "
                            " An optional argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.  Pass a blank
                            " string to limit to the global config.
    1              0.000001 function! FugitiveConfig(...) abort
                              return call('fugitive#Config', a:000)
                            endfunction
                            
                            " FugitiveConfigGet() retrieves a Git configuration value.  An optional second
                            " argument can be either the object returned by FugitiveConfig(), or a Git
                            " dir or buffer number to be passed along to FugitiveConfig().
    1              0.000001 function! FugitiveConfigGet(name, ...) abort
                              return get(call('FugitiveConfigGetAll', [a:name] + (a:0 ? [a:1] : [])), 0, get(a:, 2, ''))
                            endfunction
                            
                            " FugitiveConfigGetAll() is like FugitiveConfigGet() but returns a list of
                            " all values.
    1              0.000001 function! FugitiveConfigGetAll(name, ...) abort
                              return call('fugitive#ConfigGetAll', [a:name] + a:000)
                            endfunction
                            
                            " FugitiveConfigGetRegexp() retrieves a dictionary of all configuration values
                            " with a key matching the given pattern.  Like git config --get-regexp, but
                            " using a Vim regexp.  Second argument has same semantics as
                            " FugitiveConfigGet().
    1              0.000001 function! FugitiveConfigGetRegexp(pattern, ...) abort
                              return call('fugitive#ConfigGetRegexp', [a:pattern] + a:000)
                            endfunction
                            
                            " FugitiveRemoteUrl() retrieves the remote URL for the given remote name,
                            " defaulting to the current branch's remote or "origin" if no argument is
                            " given.  Similar to `git remote get-url`, but also attempts to resolve HTTP
                            " redirects and SSH host aliases.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000001 function! FugitiveRemoteUrl(...) abort
                              return call('fugitive#RemoteUrl', a:000)
                            endfunction
                            
                            " FugitiveRemote() returns a data structure parsed from the remote URL.
                            " For example, for remote URL "https://me@example.com:1234/repo.git", the
                            " returned dictionary will contain the following:
                            "
                            " * "scheme": "https"
                            " * "authority": "user@example.com:1234"
                            " * "path": "/repo.git" (for SSH URLs this may be a relative path)
                            " * "host": "example.com:1234"
                            " * "hostname": "example.com"
                            " * "port": "1234"
                            " * "user": "me"
                            " * "path": "/repo.git"
                            " * "url": "https://me@example.com:1234/repo.git"
    1              0.000001 function! FugitiveRemote(...) abort
                              return call('fugitive#Remote', a:000)
                            endfunction
                            
                            " FugitiveDidChange() triggers a FugitiveChanged event and reloads the summary
                            " buffer for the current or given buffer number's repository.  You can also
                            " give the result of a FugitiveExecute() and that context will be made
                            " available inside the FugitiveChanged() event.
                            "
                            " Passing the special argument 0 (the number zero) softly expires summary
                            " buffers for all repositories.  This can be used after a call to system()
                            " with unclear implications.
    1              0.000001 function! FugitiveDidChange(...) abort
                              return call('fugitive#DidChange', a:000)
                            endfunction
                            
                            " FugitiveHead() retrieves the name of the current branch. If the current HEAD
                            " is detached, FugitiveHead() will return the empty string, unless the
                            " optional argument is given, in which case the hash of the current commit
                            " will be truncated to the given number of characters.
                            "
                            " An optional second argument provides the Git dir, or the buffer number of a
                            " buffer with a Git dir.  The default is the current buffer.
    1              0.000001 function! FugitiveHead(...) abort
                              if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type('') && a:1 !~# '^\d\+$')
                                let dir = FugitiveGitDir(a:1)
                                let arg = get(a:, 2, 0)
                              elseif a:0 > 1
                                let dir = FugitiveGitDir(a:2)
                                let arg = a:1
                              else
                                let dir = FugitiveGitDir()
                                let arg = get(a:, 1, 0)
                              endif
                              if empty(dir)
                                return ''
                              endif
                              return fugitive#Head(arg, dir)
                            endfunction
                            
    1              0.000001 function! FugitivePath(...) abort
                              if a:0 > 2 && type(a:1) ==# type({})
                                return fugitive#Path(a:2, a:3, FugitiveGitDir(a:1))
                              elseif a:0 && type(a:1) ==# type({})
                                return FugitiveReal(a:0 > 1 ? a:2 : @%)
                              elseif a:0 > 1
                                return fugitive#Path(a:1, a:2, FugitiveGitDir(a:0 > 2 ? a:3 : -1))
                              else
                                return FugitiveReal(a:0 ? a:1 : @%)
                              endif
                            endfunction
                            
    1              0.000001 function! FugitiveStatusline(...) abort
                              if empty(FugitiveGitDir(bufnr('')))
                                return ''
                              endif
                              return fugitive#Statusline()
                            endfunction
                            
    1              0.000002 let s:commondirs = {}
    1              0.000001 function! FugitiveCommonDir(...) abort
                              let dir = FugitiveGitDir(a:0 ? a:1 : -1)
                              if empty(dir)
                                return ''
                              endif
                              if has_key(s:commondirs, dir)
                                return s:commondirs[dir]
                              endif
                              if getfsize(dir . '/HEAD') >= 10
                                let cdir = get(s:ReadFile(dir . '/commondir', 1), 0, '')
                                if cdir =~# '^/\|^\a:/'
                                  let s:commondirs[dir] = s:Slash(FugitiveVimPath(cdir))
                                elseif len(cdir)
                                  let s:commondirs[dir] = simplify(dir . '/' . cdir)
                                else
                                  let s:commondirs[dir] = dir
                                endif
                              else
                                let s:commondirs[dir] = dir
                              endif
                              return s:commondirs[dir]
                            endfunction
                            
    1              0.000001 function! FugitiveWorkTree(...) abort
                              let tree = s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))
                              if tree isnot# 0 || a:0 > 1
                                return tree
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000001 function! FugitiveIsGitDir(...) abort
                              if !a:0 || type(a:1) !=# type('')
                                return !empty(call('FugitiveGitDir', a:000))
                              endif
                              let path = substitute(a:1, '[\/]$', '', '') . '/'
                              return len(path) && getfsize(path.'HEAD') > 10 && (
                                    \ isdirectory(path.'objects') && isdirectory(path.'refs') ||
                                    \ getftype(path.'commondir') ==# 'file')
                            endfunction
                            
    1              0.000003 function! s:ReadFile(path, line_count) abort
                              try
                                return readfile(a:path, 'b', a:line_count)
                              catch
                                return []
                              endtry
                            endfunction
                            
    1              0.000001 let s:worktree_for_dir = {}
    1              0.000001 let s:dir_for_worktree = {}
    1              0.000001 function! s:Tree(path) abort
                              let dir = a:path
                              if dir =~# '/\.git$'
                                return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let ext_wtc_pat = 'v:val =~# "^\\s*worktreeConfig *= *\\%(true\\|yes\\|on\\|1\\) *$"'
                                let config = s:ReadFile(dir . '/config', 10)
                                if len(config)
                                  let ext_wtc_config = filter(copy(config), ext_wtc_pat)
                                  if len(ext_wtc_config) == 1 && filereadable(dir . '/config.worktree')
                                     let config += s:ReadFile(dir . '/config.worktree', 10)
                                  endif
                                else
                                  let worktree = fnamemodify(FugitiveVimPath(get(s:ReadFile(dir . '/gitdir', 1), '0', '')), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                  if len(filter(s:ReadFile(FugitiveCommonDir(dir) . '/config', 10), ext_wtc_pat))
                                    let config = s:ReadFile(dir . '/config.worktree', 10)
                                  endif
                                endif
                                if len(config)
                                  let wt_config = filter(copy(config), 'v:val =~# "^\\s*worktree *="')
                                  if len(wt_config)
                                    let worktree = FugitiveVimPath(matchstr(wt_config[0], '= *\zs.*'))
                                  elseif !exists('worktree')
                                    call filter(config,'v:val =~# "^\\s*bare *= *true *$"')
                                    if empty(config)
                                      let s:worktree_for_dir[dir] = 0
                                    endif
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif
                            endfunction
                            
    1              0.000001 function! s:CeilingDirectories() abort
                              if !exists('s:ceiling_directories')
                                let s:ceiling_directories = []
                                let resolve = 1
                                for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
                                  if empty(dir)
                                    let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, resolve(dir))
                                  else
                                    call add(s:ceiling_directories, dir)
                                  endif
                                endfor
                              endif
                              return s:ceiling_directories + get(g:, 'ceiling_directories', [])
                            endfunction
                            
    1              0.000001 function! FugitiveExtractGitDir(path) abort
                              if type(a:path) ==# type({})
                                return get(a:path, 'git_dir', '')
                              elseif type(a:path) == type(0)
                                let path = s:Slash(a:path >= 0 ? bufname(a:path) : bufname(''))
                              else
                                let path = s:Slash(a:path)
                              endif
                              if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
                              elseif empty(path)
                                return ''
                              else
                                let path = fnamemodify(path, ':p:h')
                              endif
                              let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
                              if len(pre) && exists('*' . pre . 'Real')
                                let path ={pre}Real(path)
                              endif
                              let path = s:Slash(path)
                              let root = resolve(path)
                              if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
                              endif
                              let previous = ""
                              let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
                              call s:Tree(env_git_dir)
                              while root !=# previous && root !~# '^$\|^//[^/]*$'
                                if index(s:CeilingDirectories(), root) >= 0
                                  break
                                endif
                                if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
                                elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
                                endif
                                let dir = substitute(root, '[\/]$', '', '') . '/.git'
                                let type = getftype(dir)
                                if type ==# 'dir' && FugitiveIsGitDir(dir)
                                  return dir
                                elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
                                elseif type !=# ''
                                  let line = get(s:ReadFile(dir, 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:\|^$' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
                                elseif FugitiveIsGitDir(root)
                                  return root
                                endif
                                let previous = root
                                let root = fnamemodify(root, ':h')
                              endwhile
                              return ''
                            endfunction
                            
    1              0.000001 function! FugitiveDetect(...) abort
                              if v:version < 703
                                return ''
                              endif
                              if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir
                                unlet b:git_dir
                              endif
                              if a:0 > 1 && a:2 is# 0 && !exists('#User#Fugitive')
                                return ''
                              endif
                              if !exists('b:git_dir')
                                let b:git_dir = FugitiveExtractGitDir(a:0 ? a:1 : bufnr(''))
                              endif
                              if empty(b:git_dir) || !exists('#User#Fugitive')
                                return ''
                              endif
                              if v:version >= 704 || (v:version == 703 && has('patch442'))
                                doautocmd <nomodeline> User Fugitive
                              elseif &modelines > 0
                                let modelines = &modelines
                                try
                                  set modelines=0
                                  doautocmd User Fugitive
                                finally
                                  let &modelines = modelines
                                endtry
                              else
                                doautocmd User Fugitive
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! FugitiveVimPath(path) abort
                              if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
                              else
                                return a:path
                              endif
                            endfunction
                            
    1              0.000001 function! FugitiveGitPath(path) abort
                              return s:Slash(a:path)
                            endfunction
                            
    1              0.000002 if exists('+shellslash')
                              function! s:Slash(path) abort
                                return tr(a:path, '\', '/')
                              endfunction
    1              0.000000 else
    1              0.000001   function! s:Slash(path) abort
                                return a:path
                              endfunction
    1              0.000000 endif
                            
    1              0.000001 function! s:ProjectionistDetect() abort
                              let file = s:Slash(get(g:, 'projectionist_file', ''))
                              let dir = FugitiveExtractGitDir(file)
                              let base = matchstr(file, '^fugitive://.\{-\}//\x\+')
                              if empty(base)
                                let base = s:Tree(dir)
                              endif
                              if !empty(base)
                                if exists('+shellslash') && !&shellslash
                                  let base = tr(base, '/', '\')
                                endif
                                let file = FugitiveFind('.git/info/projections.json', dir)
                                if filereadable(file)
                                  call projectionist#append(base, file)
                                endif
                              endif
                            endfunction
                            
    1              0.000007 let s:addr_other = has('patch-8.1.560') || has('nvim-0.5.0') ? '-addr=other' : ''
    1              0.000002 let s:addr_tabs  = has('patch-7.4.542') ? '-addr=tabs' : ''
    1              0.000002 let s:addr_wins  = has('patch-7.4.542') ? '-addr=windows' : ''
                            
    1              0.000003 if exists(':G') != 2
    1              0.000011   command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete G   exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
    1              0.000001 endif
    1              0.000008 command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#Complete Git exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)
                            
    1              0.000005 if exists(':Gstatus') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bang -bar     -range=-1' s:addr_other 'Gstatus exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gstatus is deprecated in favor of :Git (with no arguments)"|echohl NONE'
    1              0.000003 elseif exists(':Gstatus') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000008   exe 'command! -bang -bar     -range=-1' s:addr_other 'Gstatus'
                                    \ ' echoerr ":Gstatus has been removed in favor of :Git (with no arguments)"'
    1              0.000000 endif
                            
    9              0.000008 for s:cmd in ['Commit', 'Revert', 'Merge', 'Rebase', 'Pull', 'Push', 'Fetch', 'Blame']
    8              0.000024   if exists(':G' . tolower(s:cmd)) != 2 && get(g:, 'fugitive_legacy_commands', 0)
                                exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd)
                                      \ 'echohl WarningMSG|echomsg ":G' . tolower(s:cmd) . ' is deprecated in favor of :Git ' . tolower(s:cmd) . '"|echohl NONE|'
                                      \ 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
    8              0.000024   elseif exists(':G' . tolower(s:cmd)) != 2 && !exists('g:fugitive_legacy_commands')
    8              0.000057     exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd)
                                      \ 'echoerr ":G' . tolower(s:cmd) . ' has been removed in favor of :Git ' . tolower(s:cmd) . '"'
    8              0.000003   endif
    9              0.000003 endfor
    1              0.000001 unlet s:cmd
                            
    1              0.000004 exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Gcd  exe fugitive#Cd(<q-args>, 0)"
    1              0.000003 exe "command! -bar -bang -nargs=? -complete=customlist,fugitive#CdComplete Glcd exe fugitive#Cd(<q-args>, 1)"
                            
    1              0.000011 exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Ggrep  exe fugitive#GrepCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000013 exe 'command! -bang -nargs=? -range=-1' s:addr_wins '-complete=customlist,fugitive#GrepComplete Glgrep exe fugitive#GrepCommand(0, <count> > 0 ? <count> : 0, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000003 if exists(':Glog') != 2 && get(g:, 'fugitive_legacy_commands', 0)
                              exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Glog  :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "")'
                                    \ '|echohl WarningMSG|echomsg ":Glog is deprecated in favor of :Gclog"|echohl NONE'
    1              0.000002 elseif exists(':Glog') != 2 && !exists('g:fugitive_legacy_commands')
    1              0.000005   exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Glog'
                                    \ ' echoerr ":Glog has been removed in favor of :Gclog"'
    1              0.000000 endif
    1              0.000010 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gclog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'
    1              0.000009 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GcLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "c")'
    1              0.000009 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete Gllog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'
    1              0.000009 exe 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#LogComplete GlLog :exe fugitive#LogCommand(<line1>,<count>,+"<range>",<bang>0,"<mods>",<q-args>, "l")'
                            
    1              0.000011 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Ge       exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)'
    1              0.000006 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#EditComplete   Gedit    exe fugitive#Open("edit<bang>", 0, "<mods>", <q-args>)'
    1              0.000006 exe 'command! -bar -bang -nargs=*                          -complete=customlist,fugitive#ReadComplete   Gpedit   exe fugitive#Open("pedit", <bang>0, "<mods>", <q-args>)'
    1              0.000010 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#ReadComplete   Gsplit   exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "split" : "edit"), <bang>0, "<mods>", <q-args>)'
    1              0.000011 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_other '-complete=customlist,fugitive#ReadComplete   Gvsplit  exe fugitive#Open((<count> > 0 ? <count> : "").(<count> ? "vsplit" : "edit!"), <bang>0, "<mods>", <q-args>)'
    1              0.000009 exe 'command! -bar -bang -nargs=* -range=-1' s:addr_tabs  '-complete=customlist,fugitive#ReadComplete   Gtabedit exe fugitive#Open((<count> >= 0 ? <count> : "")."tabedit", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000002 if exists(':Gr') != 2
    1              0.000009   exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gr     exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000000 endif
    1              0.000010 exe 'command! -bar -bang -nargs=* -range=-1                -complete=customlist,fugitive#ReadComplete   Gread    exe fugitive#ReadCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000006 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gdiffsplit  exe fugitive#Diffsplit(1, <bang>0, "<mods>", <q-args>)'
    1              0.000008 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Ghdiffsplit exe fugitive#Diffsplit(0, <bang>0, "<mods>", <q-args>)'
    1              0.000006 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gvdiffsplit exe fugitive#Diffsplit(0, <bang>0, "vertical <mods>", <q-args>)'
                            
    1              0.000008 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gw     exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000008 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwrite exe fugitive#WriteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000008 exe 'command! -bar -bang -nargs=* -complete=customlist,fugitive#EditComplete Gwq    exe fugitive#WqCommand(   <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                            
    1              0.000007 exe 'command! -bar -bang -nargs=0 GRemove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000008 exe 'command! -bar -bang -nargs=0 GDelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000008 exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject GMove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000008 exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete GRename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000004 if exists(':Gremove') != 2 && get(g:, 'fugitive_legacy_commands', 1)
    1              0.000012   exe 'command! -bar -bang -nargs=0 Gremove exe fugitive#RemoveCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gremove is deprecated in favor of :GRemove"|echohl NONE'
    1              0.000001 endif
    1              0.000003 if exists(':Gdelete') != 2 && get(g:, 'fugitive_legacy_commands', 1)
    1              0.000011   exe 'command! -bar -bang -nargs=0 Gdelete exe fugitive#DeleteCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gdelete is deprecated in favor of :GDelete"|echohl NONE'
    1              0.000000 endif
    1              0.000003 if exists(':Gmove') != 2 && get(g:, 'fugitive_legacy_commands', 1)
    1              0.000012   exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#CompleteObject Gmove   exe fugitive#MoveCommand(  <line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Gmove is deprecated in favor of :GMove"|echohl NONE'
    1              0.000000 endif
    1              0.000003 if exists(':Grename') != 2 && get(g:, 'fugitive_legacy_commands', 1)
    1              0.000012   exe 'command! -bar -bang -nargs=1 -complete=customlist,fugitive#RenameComplete Grename exe fugitive#RenameCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|echohl WarningMSG|echomsg ":Grename is deprecated in favor of :GRename"|echohl NONE'
    1              0.000000 endif
                            
    1              0.000008 exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject GBrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
    1              0.000003 if exists(':Gbrowse') != 2 && get(g:, 'fugitive_legacy_commands', 1)
    1              0.000014   exe 'command! -bar -bang -range=-1 -nargs=* -complete=customlist,fugitive#CompleteObject Gbrowse exe fugitive#BrowseCommand(<line1>, <count>, +"<range>", <bang>0, "<mods>", <q-args>)'
                                    \ '|if <bang>1|redraw!|endif|echohl WarningMSG|echomsg ":Gbrowse is deprecated in favor of :GBrowse"|echohl NONE'
    1              0.000000 endif
                            
    1              0.000001 if v:version < 703
                              finish
    1              0.000000 endif
                            
    1              0.000025 let g:io_fugitive = {
                                  \ 'simplify': function('fugitive#simplify'),
                                  \ 'resolve': function('fugitive#resolve'),
                                  \ 'getftime': function('fugitive#getftime'),
                                  \ 'getfsize': function('fugitive#getfsize'),
                                  \ 'getftype': function('fugitive#getftype'),
                                  \ 'filereadable': function('fugitive#filereadable'),
                                  \ 'filewritable': function('fugitive#filewritable'),
                                  \ 'isdirectory': function('fugitive#isdirectory'),
                                  \ 'getfperm': function('fugitive#getfperm'),
                                  \ 'setfperm': function('fugitive#setfperm'),
                                  \ 'readfile': function('fugitive#readfile'),
                                  \ 'writefile': function('fugitive#writefile'),
                                  \ 'glob': function('fugitive#glob'),
                                  \ 'delete': function('fugitive#delete'),
                                  \ 'Real': function('FugitiveReal')}
                            
    1              0.000003 augroup fugitive
    1              0.000258   autocmd!
                            
    1              0.000011   autocmd BufNewFile,BufReadPost *  call FugitiveDetect(+expand('<abuf>'), 0)
    1              0.000003   autocmd FileType           netrw  call FugitiveDetect(+expand('<abuf>'), 0)
                            
    1              0.000003   autocmd FileType git
                                    \ call fugitive#MapCfile()
    1              0.000021   autocmd FileType gitcommit
                                    \ call fugitive#MapCfile('fugitive#MessageCfile()')
    1              0.000006   autocmd FileType git,gitcommit
                                    \ if &foldtext ==# 'foldtext()' |
                                    \    setlocal foldtext=fugitive#Foldtext() |
                                    \ endif
    1              0.000003   autocmd FileType fugitive
                                    \ call fugitive#MapCfile('fugitive#PorcelainCfile()')
    1              0.000004   autocmd FileType gitrebase
                                    \ let &l:include = '^\%(pick\|squash\|edit\|reword\|fixup\|drop\|[pserfd]\)\>' |
                                    \ if &l:includeexpr !~# 'Fugitive' |
                                    \   let &l:includeexpr = 'v:fname =~# ''^\x\{4,\}$'' && len(FugitiveGitDir()) ? FugitiveFind(v:fname) : ' .
                                    \     (len(&l:includeexpr) ? &l:includeexpr : 'v:fname') |
                                    \ endif |
                                    \ let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|setl inex= inc='
                            
    1              0.000005   autocmd BufReadCmd index{,.lock} nested
                                    \ if FugitiveIsGitDir(expand('<amatch>:p:h')) |
                                    \   let b:git_dir = s:Slash(expand('<amatch>:p:h')) |
                                    \   exe fugitive#BufReadStatus(v:cmdbang) |
                                    \ elseif filereadable(expand('<amatch>')) |
                                    \   silent doautocmd BufReadPre |
                                    \   keepalt noautocmd read <amatch> |
                                    \   silent 1delete_ |
                                    \   silent doautocmd BufReadPost |
                                    \ else |
                                    \   silent doautocmd BufNewFile |
                                    \ endif
                            
    1              0.000004   autocmd BufReadCmd   fugitive://*//*       nested exe fugitive#BufReadCmd() |
                                    \ if &path =~# '^\.\%(,\|$\)' |
                                    \   let &l:path = substitute(&path, '^\.,\=', '', '') |
                                    \ endif
    1              0.000004   autocmd BufWriteCmd  fugitive://*//[0-3]/* nested exe fugitive#BufWriteCmd()
    1              0.000003   autocmd FileReadCmd  fugitive://*//*       nested exe fugitive#FileReadCmd()
    1              0.000003   autocmd FileWriteCmd fugitive://*//[0-3]/* nested exe fugitive#FileWriteCmd()
    1              0.000004   if exists('##SourceCmd')
    1              0.000003     autocmd SourceCmd     fugitive://*//*    nested exe fugitive#SourceCmd()
    1              0.000001   endif
                            
    1              0.000002   autocmd User Flags call Hoist('buffer', function('FugitiveStatusline'))
                            
    1              0.000002   autocmd User ProjectionistDetect call s:ProjectionistDetect()
    1              0.000001 augroup END
                            
    1              0.000002 if get(g:, 'fugitive_no_maps')
                              finish
    1              0.000000 endif
                            
    1              0.000004 let s:nowait = v:version >= 704 ? '<nowait>' : ''
                            
    1              0.000005 function! s:Map(mode, lhs, rhs, flags) abort
                              let flags = a:flags . (a:rhs =~# '<Plug>' ? '' : '<script>')
                              let head = a:lhs
                              let tail = ''
                              let keys = get(g:, a:mode.'remap', {})
                              if len(keys) && type(keys) == type({})
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
                              endif
                              if flags !~# '<unique>' || empty(mapcheck(head.tail, a:mode))
                                exe a:mode.'map' s:nowait flags head.tail a:rhs
                              endif
                            endfunction
                            
    1   0.000077   0.000013 call s:Map('c', '<C-R><C-G>', 'fnameescape(fugitive#Object(@%))', '<expr>')
    1   0.000073   0.000021 call s:Map('n', 'y<C-G>', ':<C-U>call setreg(v:register, fugitive#Object(@%))<CR>', '<silent>')

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-rhubarb/plugin/rhubarb.vim
Sourced 1 time
Total time:   0.000349
 Self time:   0.000349

count  total (s)   self (s)
                            " rhubarb.vim - fugitive.vim extension for GitHub
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            
    1              0.000010 if exists("g:loaded_rhubarb") || v:version < 700 || &cp
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_rhubarb = 1
                            
    1              0.000002 if !exists('g:dispatch_compilers')
    1              0.000002   let g:dispatch_compilers = {}
    1              0.000000 endif
    1              0.000002 let g:dispatch_compilers['hub'] = 'git'
                            
    1              0.000003 function! s:SetUpMessage(filename) abort
                              if &omnifunc !~# '^\%(syntaxcomplete#Complete\)\=$' ||
                                    \ a:filename !~# '\.git[\/].*MSG$' ||
                                    \ !exists('*FugitiveFind')
                                return
                              endif
                              let dir = exists('*FugitiveConfigGetRegexp') ? FugitiveGitDir() : FugitiveExtractGitDir(a:filename)
                              if empty(dir)
                                return
                              endif
                              let config_file = FugitiveFind('.git/config', dir)
                              let config = filereadable(config_file) ? readfile(config_file) : []
                              if !empty(filter(config,
                                    \ '!empty(rhubarb#HomepageForUrl(matchstr(v:val, ''^\s*url\s*=\s*"\=\zs[^[:space:]"]*'')))'))
                                setlocal omnifunc=rhubarb#Complete
                              endif
                            endfunction
                            
    1              0.000002 augroup rhubarb
    1              0.000245   autocmd!
    1              0.000003   if exists('+omnifunc')
    1              0.000005     autocmd FileType gitcommit call s:SetUpMessage(expand('<afile>:p'))
    1              0.000000   endif
    1              0.000003   autocmd BufEnter *
                                    \ if expand('%') ==# '' && &previewwindow && pumvisible() && getbufvar('#', '&omnifunc') ==# 'rhubarb#omnifunc' |
                                    \    setlocal nolist linebreak filetype=markdown |
                                    \ endif
    1              0.000012   autocmd BufNewFile,BufRead *.git/{PULLREQ_EDIT,ISSUE_EDIT,RELEASE_EDIT}MSG
                                    \ if &ft ==# '' || &ft ==# 'conf' |
                                    \   set ft=gitcommit |
                                    \ endif
    1              0.000001 augroup END
                            
    1              0.000002 if !exists('g:fugitive_browse_handlers')
    1              0.000002   let g:fugitive_browse_handlers = []
    1              0.000000 endif
                            
    1              0.000004 if index(g:fugitive_browse_handlers, function('rhubarb#FugitiveUrl')) < 0
    1              0.000003   call insert(g:fugitive_browse_handlers, function('rhubarb#FugitiveUrl'))
    1              0.000017 endif

SCRIPT  /home/tony/.config/nvim/autoload/plugged/gv.vim/plugin/gv.vim
Sourced 1 time
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
                            " The MIT License (MIT)
                            "
                            " Copyright (c) 2016 Junegunn Choi
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to deal
                            " in the Software without restriction, including without limitation the rights
                            " to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            " copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            " OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
                            " THE SOFTWARE.
                            
    1              0.000004 function! s:warn(message)
                              echohl WarningMsg | echom a:message | echohl None
                            endfunction
                            
    1              0.000001 function! s:shrug()
                              call s:warn('¯\_(ツ)_/¯')
                            endfunction
                            
    1              0.000002 let s:begin = '^[^0-9]*[0-9]\{4}-[0-9]\{2}-[0-9]\{2}\s\+'
                            
    1              0.000001 function! gv#sha(...)
                              return matchstr(get(a:000, 0, getline('.')), s:begin.'\zs[a-f0-9]\+')
                            endfunction
                            
    1              0.000001 function! s:move(flag)
                              let [l, c] = searchpos(s:begin, a:flag)
                              return l ? printf('%dG%d|', l, c) : ''
                            endfunction
                            
    1              0.000001 function! s:browse(url)
                              call netrw#BrowseX(b:git_origin.a:url, 0)
                            endfunction
                            
    1              0.000001 function! s:tabnew()
                              execute (tabpagenr()-1).'tabnew'
                            endfunction
                            
    1              0.000001 function! s:gbrowse()
                              let sha = gv#sha()
                              if empty(sha)
                                return s:shrug()
                              endif
                              execute 'GBrowse' sha
                            endfunction
                            
    1              0.000001 function! s:type(visual)
                              if a:visual
                                let shas = filter(map(getline("'<", "'>"), 'gv#sha(v:val)'), '!empty(v:val)')
                                if len(shas) < 2
                                  return [0, 0]
                                endif
                                return ['diff', FugitiveShellCommand(['diff', shas[-1], shas[0]])]
                              endif
                            
                              if exists('b:git_origin')
                                let syn = synIDattr(synID(line('.'), col('.'), 0), 'name')
                                if syn == 'gvGitHub'
                                  return ['link', '/issues/'.expand('<cword>')[1:]]
                                elseif syn == 'gvTag'
                                  let tag = matchstr(getline('.'), '(tag: \zs[^ ,)]\+')
                                  return ['link', '/releases/'.tag]
                                endif
                              endif
                            
                              let sha = gv#sha()
                              if !empty(sha)
                                return ['commit', FugitiveFind(sha, b:git_dir)]
                              endif
                              return [0, 0]
                            endfunction
                            
    1              0.000001 function! s:split(tab)
                              if a:tab
                                call s:tabnew()
                              elseif getwinvar(winnr('$'), 'gv')
                                $wincmd w
                                enew
                              else
                                vertical botright new
                              endif
                              let w:gv = 1
                            endfunction
                            
    1              0.000001 function! s:open(visual, ...)
                              let [type, target] = s:type(a:visual)
                            
                              if empty(type)
                                return s:shrug()
                              elseif type == 'link'
                                return s:browse(target)
                              endif
                            
                              call s:split(a:0)
                              call s:scratch()
                              if type == 'commit'
                                execute 'e' escape(target, ' ')
                                nnoremap <silent> <buffer> gb :GBrowse<cr>
                              elseif type == 'diff'
                                call s:fill(target)
                                setf diff
                              endif
                              nnoremap <silent> <buffer> q :close<cr>
                              let bang = a:0 ? '!' : ''
                              if exists('#User#GV'.bang)
                                execute 'doautocmd <nomodeline> User GV'.bang
                              endif
                              wincmd p
                              echo
                            endfunction
                            
    1              0.000001 function! s:dot()
                              let sha = gv#sha()
                              return empty(sha) ? '' : ':Git  '.sha."\<s-left>\<left>"
                            endfunction
                            
    1              0.000001 function! s:maps()
                              nnoremap <silent> <buffer> q    :$wincmd w <bar> close<cr>
                              nnoremap <silent> <buffer> <nowait> gq :$wincmd w <bar> close<cr>
                              nnoremap <silent> <buffer> gb   :call <sid>gbrowse()<cr>
                              nnoremap <silent> <buffer> <cr> :call <sid>open(0)<cr>
                              nnoremap <silent> <buffer> o    :call <sid>open(0)<cr>
                              nnoremap <silent> <buffer> O    :call <sid>open(0, 1)<cr>
                              xnoremap <silent> <buffer> <cr> :<c-u>call <sid>open(1)<cr>
                              xnoremap <silent> <buffer> o    :<c-u>call <sid>open(1)<cr>
                              xnoremap <silent> <buffer> O    :<c-u>call <sid>open(1, 1)<cr>
                              nnoremap          <buffer> <expr> .  <sid>dot()
                              nnoremap <silent> <buffer> <expr> ]] <sid>move('')
                              nnoremap <silent> <buffer> <expr> ][ <sid>move('')
                              nnoremap <silent> <buffer> <expr> [[ <sid>move('b')
                              nnoremap <silent> <buffer> <expr> [] <sid>move('b')
                              xnoremap <silent> <buffer> <expr> ]] <sid>move('')
                              xnoremap <silent> <buffer> <expr> ][ <sid>move('')
                              xnoremap <silent> <buffer> <expr> [[ <sid>move('b')
                              xnoremap <silent> <buffer> <expr> [] <sid>move('b')
                            
                              nmap              <buffer> <C-n> ]]o
                              nmap              <buffer> <C-p> [[o
                              xmap              <buffer> <C-n> ]]ogv
                              xmap              <buffer> <C-p> [[ogv
                            endfunction
                            
    1              0.000001 function! s:setup(git_dir, git_origin)
                              call s:tabnew()
                              call s:scratch()
                            
                              if exists('g:fugitive_github_domains')
                                let domain = join(map(extend(['github.com'], g:fugitive_github_domains),
                                      \ 'escape(substitute(split(v:val, "://")[-1], "/*$", "", ""), ".")'), '\|')
                              else
                                let domain = '.*github.\+'
                              endif
                              " https://  github.com  /  junegunn/gv.vim  .git
                              " git@      github.com  :  junegunn/gv.vim  .git
                              let pat = '^\(https\?://\|git@\)\('.domain.'\)[:/]\([^@:/]\+/[^@:/]\{-}\)\%(.git\)\?$'
                              let origin = matchlist(a:git_origin, pat)
                              if !empty(origin)
                                let scheme = origin[1] =~ '^http' ? origin[1] : 'https://'
                                let b:git_origin = printf('%s%s/%s', scheme, origin[2], origin[3])
                              endif
                              let b:git_dir = a:git_dir
                            endfunction
                            
    1              0.000001 function! s:scratch()
                              setlocal buftype=nofile bufhidden=wipe noswapfile nomodeline
                            endfunction
                            
    1              0.000001 function! s:fill(cmd)
                              setlocal modifiable
                              %delete _
                              silent execute 'read' escape('!'.a:cmd, '%')
                              normal! gg"_dd
                              setlocal nomodifiable
                            endfunction
                            
    1              0.000001 function! s:tracked(fugitive_repo, file)
                              call system(FugitiveShellCommand(['ls-files', '--error-unmatch', a:file]))
                              return !v:shell_error
                            endfunction
                            
    1              0.000001 function! s:check_buffer(fugitive_repo, current)
                              if empty(a:current)
                                throw 'untracked buffer'
                              elseif !s:tracked(a:fugitive_repo, a:current)
                                throw a:current.' is untracked'
                              endif
                            endfunction
                            
    1              0.000001 function! s:log_opts(fugitive_repo, bang, visual, line1, line2)
                              if a:visual || a:bang
                                let current = expand('%')
                                call s:check_buffer(a:fugitive_repo, current)
                                return a:visual ? [[printf('-L%d,%d:%s', a:line1, a:line2, current)], []] : [['--follow'], ['--', current]]
                              endif
                              return [['--graph'], []]
                            endfunction
                            
    1              0.000001 function! s:list(fugitive_repo, log_opts)
                              let default_opts = ['--color=never', '--date=short', '--format=%cd %h%d %s (%an)']
                              let git_args = ['log'] + default_opts + a:log_opts
                              let git_log_cmd = FugitiveShellCommand(git_args, a:fugitive_repo)
                            
                              let repo_short_name = fnamemodify(substitute(a:fugitive_repo.dir(), '[\\/]\.git[\\/]\?$', '', ''), ':t')
                              let bufname = repo_short_name.' '.join(a:log_opts)
                              silent exe (bufexists(bufname) ? 'buffer' : 'file') fnameescape(bufname)
                            
                              call s:fill(git_log_cmd)
                              setlocal nowrap tabstop=8 cursorline iskeyword+=#
                            
                              if !exists(':GBrowse')
                                doautocmd <nomodeline> User Fugitive
                              endif
                              call s:maps()
                              setf GV
                              redraw
                              echo 'o: open split / O: open tab / gb: GBrowse / q: quit'
                            endfunction
                            
    1              0.000001 function! s:trim(arg)
                              let arg = substitute(a:arg, '\s*$', '', '')
                              return arg =~ "^'.*'$" ? substitute(arg[1:-2], "''", '', 'g')
                                 \ : arg =~ '^".*"$' ? substitute(substitute(arg[1:-2], '""', '', 'g'), '\\"', '"', 'g')
                                 \ : substitute(substitute(arg, '""\|''''', '', 'g'), '\\ ', ' ', 'g')
                            endfunction
                            
    1              0.000001 function! gv#shellwords(arg)
                              let words = []
                              let contd = 0
                              for token in split(a:arg, '\%(\%(''\%([^'']\|''''\)\+''\)\|\%("\%(\\"\|[^"]\)\+"\)\|\%(\%(\\ \|\S\)\+\)\)\s*\zs')
                                let trimmed = s:trim(token)
                                if contd
                                  let words[-1] .= trimmed
                                else
                                  call add(words, trimmed)
                                endif
                                let contd = token !~ '\s\+$'
                              endfor
                              return words
                            endfunction
                            
    1              0.000001 function! s:split_pathspec(args)
                              let split = index(a:args, '--')
                              if split < 0
                                return [a:args, []]
                              elseif split == 0
                                return [[], a:args]
                              endif
                              return [a:args[0:split-1], a:args[split:]]
                            endfunction
                            
    1              0.000001 function! s:gl(buf, visual)
                              if !exists(':Gllog')
                                return
                              endif
                              tab split
                              silent execute a:visual ? "'<,'>" : "" 'Gllog'
                              call setloclist(0, insert(getloclist(0), {'bufnr': a:buf}, 0))
                              noautocmd b #
                              lopen
                              xnoremap <buffer> o :call <sid>gld()<cr>
                              nnoremap <buffer> o <cr><c-w><c-w>
                              nnoremap <buffer> O :call <sid>gld()<cr>
                              nnoremap <buffer> q :tabclose<cr>
                              nnoremap <buffer> gq :tabclose<cr>
                              call matchadd('Conceal', '^fugitive://.\{-}\.git//')
                              call matchadd('Conceal', '^fugitive://.\{-}\.git//\x\{7}\zs.\{-}||')
                              setlocal concealcursor=nv conceallevel=3 nowrap
                              let w:quickfix_title = 'o: open / o (in visual): diff / O: open (tab) / q: quit'
                            endfunction
                            
    1              0.000001 function! s:gld() range
                              let [to, from] = map([a:firstline, a:lastline], 'split(getline(v:val), "|")[0]')
                              execute (tabpagenr()-1).'tabedit' escape(to, ' ')
                              if from !=# to
                                execute 'vsplit' escape(from, ' ')
                                windo diffthis
                              endif
                            endfunction
                            
    1              0.000001 function! s:gv(bang, visual, line1, line2, args) abort
                              if !exists('g:loaded_fugitive')
                                return s:warn('fugitive not found')
                              endif
                            
                              let git_dir = FugitiveGitDir()
                              if empty(git_dir)
                                return s:warn('not in git repo')
                              endif
                            
                              let fugitive_repo = fugitive#repo(git_dir)
                              let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : 'cd'
                              let cwd = getcwd()
                              let root = fugitive_repo.tree()
                              try
                                if cwd !=# root
                                  execute cd escape(root, ' ')
                                endif
                                if a:args =~ '?$'
                                  if len(a:args) > 1
                                    return s:warn('invalid arguments')
                                  endif
                                  call s:check_buffer(fugitive_repo, expand('%'))
                                  call s:gl(bufnr(''), a:visual)
                                else
                                  let [opts1, paths1] = s:log_opts(fugitive_repo, a:bang, a:visual, a:line1, a:line2)
                                  let [opts2, paths2] = s:split_pathspec(gv#shellwords(a:args))
                                  let log_opts = opts1 + opts2 + paths1 + paths2
                                  call s:setup(git_dir, fugitive_repo.config('remote.origin.url'))
                                  call s:list(fugitive_repo, log_opts)
                                  call FugitiveDetect(@#)
                                endif
                              catch
                                return s:warn(v:exception)
                              finally
                                if getcwd() !=# cwd
                                  cd -
                                endif
                              endtry
                            endfunction
                            
    1              0.000001 function! s:gvcomplete(a, l, p) abort
                              return fugitive#repo().superglob(a:a)
                            endfunction
                            
    1              0.000022 command! -bang -nargs=* -range=0 -complete=customlist,s:gvcomplete GV call s:gv(<bang>0, <count>, <line1>, <line2>, <q-args>)

SCRIPT  /home/tony/.config/nvim/autoload/plugged/nvim-web-devicons/plugin/nvim-web-devicons.vim
Sourced 1 time
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000008 if exists('g:loaded_devicons') | finish | endif
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
                            " TODO change so its easier to get
    1              0.000001 let g:nvim_web_devicons = 1
                            
    1              0.000003 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
    1              0.000012 let g:loaded_devicons = 1

SCRIPT  /home/tony/.config/nvim/autoload/plugged/nvim-colorizer.lua/plugin/colorizer.vim
Sourced 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000004 if exists('g:loaded_colorizer')
                              finish
    1              0.000000 endif
                            
    1              0.000004 command! ColorizerAttachToBuffer lua require'colorizer'.attach_to_buffer(0)
    1              0.000002 command! ColorizerDetachFromBuffer lua require'colorizer'.detach_from_buffer(0)
    1              0.000002 command! ColorizerReloadAllBuffers lua require'colorizer'.reload_all_buffers()
    1              0.000006 command! ColorizerToggle lua local c = require'colorizer'
                                        \ if c.is_buffer_attached(0) then c.detach_from_buffer(0) else
                                        \ c.attach_to_buffer(0) end
                            
    1              0.000011 let g:loaded_colorizer = 1

SCRIPT  /home/tony/.config/nvim/autoload/plugged/rainbow_parentheses.vim/plugin/rainbow_parentheses.vim
Sourced 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
                            "==============================================================================
                            "  Description: Rainbow colors for parentheses, based on rainbow_parenthsis.vim
                            "               by Martin Krischik and others.
                            "==============================================================================
                            
    1              0.000016 command! -bang -nargs=? -bar RainbowParentheses
                              \  if empty('<bang>')
                              \|   call rainbow_parentheses#activate()
                              \| elseif <q-args> == '!'
                              \|   call rainbow_parentheses#toggle()
                              \| else
                              \|   call rainbow_parentheses#deactivate()
                              \| endif
                            

SCRIPT  /home/tony/.config/nvim/autoload/plugged/goyo.vim/plugin/goyo.vim
Sourced 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            " Copyright (c) 2015 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000014 command! -nargs=? -bar -bang Goyo call goyo#execute(<bang>0, <q-args>)

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-which-key/plugin/which_key.vim
Sourced 1 time
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    1              0.000004 scriptencoding utf-8
                            
    1              0.000006 if exists('g:loaded_vim_which_key')
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_vim_which_key = 1
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000006 let g:which_key_sep = get(g:, 'which_key_sep', '→')
    1              0.000002 let g:which_key_hspace = get(g:, 'which_key_hspace', 5)
    1              0.000002 let g:which_key_flatten = get(g:, 'which_key_flatten', 1)
    1              0.000002 let g:which_key_timeout = get(g:, 'which_key_timeout', &timeoutlen)
    1              0.000002 let g:which_key_max_size = get(g:, 'which_key_max_size', 0)
    1              0.000001 let g:which_key_vertical = get(g:, 'which_key_vertical', 0)
    1              0.000002 let g:which_key_position = get(g:, 'which_key_position', 'botright')
    1              0.000002 let g:which_key_centered = get(g:, 'which_key_centered', 1)
    1              0.000002 let g:which_key_group_dicts = get(g:, 'which_key_group_dicts', 'end')
    1              0.000002 let g:which_key_sort_horizontal = get(g:, 'which_key_sort_horizontal', 0)
    1              0.000002 let g:which_key_run_map_on_popup = get(g:, 'which_key_run_map_on_popup', 1)
    1              0.000002 let g:which_key_align_by_seperator = get(g:, 'which_key_align_by_seperator', 1)
    1              0.000002 let g:which_key_ignore_invalid_key = get(g:, 'which_key_ignore_invalid_key', 1)
    1              0.000002 let g:which_key_fallback_to_native_key = get(g:, 'which_key_fallback_to_native_key', 0)
    1              0.000002 let g:which_key_default_group_name = get(g:, 'which_key_default_group_name', '+prefix')
    1              0.000005 let g:which_key_use_floating_win = (exists('*nvim_open_win') || exists('*popup_create')) && get(g:, 'which_key_use_floating_win', 1)
    1              0.000002 let g:which_key_floating_relative_win = get(g:, 'which_key_floating_relative_win', 0)
    1              0.000002 let g:which_key_disable_default_offset = get(g:, 'which_key_disable_default_offset', 0)
    1              0.000004 let g:WhichKeyFormatFunc = get(g:, 'WhichKeyFormatFunc', function('which_key#format'))
                            
    1              0.000007 command! -bang -nargs=1 WhichKey call which_key#start(0, <bang>0, <args>)
    1              0.000004 command! -bang -nargs=1 -range WhichKeyVisual call which_key#start(1, <bang>0, <args>)
                            
    1              0.000004 let &cpo = s:save_cpo
    1              0.000013 unlet s:save_cpo

SCRIPT  /home/tony/.config/nvim/autoload/plugged/suda.vim/plugin/suda.vim
Sourced 1 time
Total time:   0.000351
 Self time:   0.000351

count  total (s)   self (s)
    1              0.000005 if exists('g:loaded_suda')
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_suda = 1
                            
    1              0.000002 if get(g:, 'suda_smart_edit')
                              augroup suda_smart_edit
                                autocmd!
                                autocmd BufEnter * nested call suda#BufEnter()
                              augroup end
    1              0.000000 endif
                            
    1              0.000001 augroup suda_plugin
    1              0.000268   autocmd!
    1              0.000006   autocmd BufReadCmd   suda://* call suda#BufReadCmd()
    1              0.000003   autocmd FileReadCmd  suda://* call suda#FileReadCmd()
    1              0.000002   autocmd BufWriteCmd  suda://* call suda#BufWriteCmd()
    1              0.000002   autocmd FileWriteCmd suda://* call suda#FileWriteCmd()
    1              0.000001 augroup END
                            
    1              0.000004 function! s:read(args) abort
                              let args = empty(a:args) ? expand('%:p') : a:args
                              execute printf('edit suda://%s', args)
                            endfunction
    1              0.000007 command! -nargs=? -complete=file SudaRead  call s:read(<q-args>)
                            
    1              0.000001 function! s:write(args) abort
                              let args = empty(a:args) ? expand('%:p') : a:args
                              execute printf('write suda://%s', args)
                            endfunction
    1              0.000021 command! -nargs=? -complete=file SudaWrite call s:write(<q-args>)

SCRIPT  /home/tony/.config/nvim/autoload/plugged/startuptime.vim/plugin/startuptime.vim
Sourced 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000014 command! -nargs=* -complete=file StartupTime call startuptime#profile(<f-args>)

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-polyglot/plugin/polyglot.vim
Sourced 1 time
Total time:   0.003046
 Self time:   0.003044

count  total (s)   self (s)
    1   0.000012   0.000011 call polyglot#init#init()
                            
                            " Turn on filetype plugins (:help filetype-plugin).
    1              0.000007 if has('autocmd') && !(exists("did_load_filetypes") && exists("did_indent_on"))
                              filetype plugin indent on
    1              0.000000 endif
                            
                            " Enable syntax highlighting.
    1              0.000003 if has('syntax') && !exists('g:syntax_on')
                              syntax enable
    1              0.000000 endif
                            
                            " No need to duplicate work
    1              0.000001 if exists('g:loaded_sensible')
                              finish
    1              0.000000 endif
                            
                            " Code taken from https://github.com/tpope/vim-sensible
                            " and (mostly comments) from https://github.com/sheerun/vimrc
                            "
                            " Only settings that matter for proper editing are left
    1              0.000002 if !has_key(g:polyglot_is_disabled, 'sensible')
                              " Allow backspace in insert mode.
    1              0.000002   if &backspace == ""
                                set backspace=indent,eol,start
    1              0.000000   endif
                            
                              " Allow for mappings including `Esc`, while preserving
                              " zero timeout after pressing it manually.
                              " (only vim needs a fix for this)
    1              0.000002   if !has('nvim') && &ttimeoutlen == -1
                                set ttimeout
                                set ttimeoutlen=100
    1              0.000000   endif
                            
                              " Set default whitespace characters when using `:set list`
    1              0.000001   if &listchars ==# 'eol:$'
                                set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
    1              0.000000   endif
                            
                              " Delete comment character when joining commented lines
    1              0.000002   if v:version > 703 || v:version == 703 && has("patch541")
    1              0.000007     set formatoptions+=j
    1              0.000000   endif
                            
                              " Search upwards for tags file instead only locally
    1              0.000001   if has('path_extra')
    1              0.000005     setglobal tags-=./tags tags-=./tags; tags^=./tags;
    1              0.000000   endif
                            
                              " Fix issues with fish shell
                              " https://github.com/tpope/vim-sensible/issues/50
    1              0.000004   if &shell =~# 'fish$' && (v:version < 704 || v:version == 704 && !has('patch276'))
                                set shell=/usr/bin/env\ bash
    1              0.000000   endif
                            
                              " Increase history size to 1000 items.
    1              0.000001   if &history < 1000
                                set history=1000
    1              0.000000   endif
                            
                              " Allow for up to 50 opened tabs on Vim start.
    1              0.000001   if &tabpagemax < 50
                                set tabpagemax=50
    1              0.000000   endif
                            
                              " Reduce updatetime from 4000 to 300 to avoid issues with coc.nvim
    1              0.000001   if &updatetime == 4000
                                set updatetime=300
    1              0.000000   endif
                            
                              " Automatically reload file if changed somewhere else
    1              0.000002   redir => capture
    1              0.000012   silent autocmd CursorHold
    1              0.000002   redir END
    1              0.000005   if match(capture, 'checktime') == -1
    1              0.000001     augroup polyglot-sensible
    1              0.000246       au!
    1              0.000003       au CursorHold * silent! checktime
    1              0.000001     augroup END
    1              0.000000   endif
                            
                              " Always save upper case variables to viminfo file.
    1              0.000003   if !empty(&viminfo)
    1              0.000002     set viminfo^=!
    1              0.000000   endif
                            
                              " Don't save options in sessions and views
    1              0.000003   set sessionoptions-=options
    1              0.000002   set viewoptions-=options
                            
                              " Allow color schemes to do bright colors without forcing bold.
    1              0.000002   if &t_Co == 8 && $TERM !~# '^Eterm'
                                set t_Co=16
    1              0.000000   endif
                            
                              " Load matchit.vim, but only if the user hasn't installed a newer version.
    1              0.002601   if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''
                                runtime! macros/matchit.vim
    1              0.000001   endif
                            
                              " `Ctrl-U` in insert mode deletes a lot. Use `Ctrl-G` u to first break undo,
                              " so that you can undo `Ctrl-U` without undoing what you typed before it.
    1              0.000035   if empty(mapcheck('<C-U>', 'i'))
                                inoremap <C-U> <C-G>u<C-U>
    1              0.000000   endif
                            
    1              0.000007   if empty(mapcheck('<C-W>', 'i'))
                                inoremap <C-W> <C-G>u<C-W>
    1              0.000000   endif
    1              0.000017 endif

SCRIPT  /usr/share/nvim/runtime/plugin/gzip.vim
Sourced 1 time
Total time:   0.000372
 Self time:   0.000372

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer: Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2016 Oct 30
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000010 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
    1              0.000000 endif
    1              0.000003 let loaded_gzip = 1
                            
    1              0.000001 augroup gzip
                              " Remove all gzip autocommands
    1              0.000254   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000019   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
    1              0.000003   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.lz  call gzip#read("lzip -d")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.zst call gzip#read("zstd -d --rm")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.br call gzip#read("brotli -d --rm")
    1              0.000002   autocmd BufReadPost,FileReadPost	*.lzo call gzip#read("lzop -d -U")
    1              0.000003   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.lz  call gzip#write("lzip")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.zst  call gzip#write("zstd --rm")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.br  call gzip#write("brotli --rm")
    1              0.000002   autocmd BufWritePost,FileWritePost	*.lzo  call gzip#write("lzop -U")
    1              0.000002   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000003   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000002   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000003   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000002   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000001   autocmd FileAppendPre			*.lz   call gzip#appre("lzip -d")
    1              0.000002   autocmd FileAppendPre			*.zst call gzip#appre("zstd -d --rm")
    1              0.000001   autocmd FileAppendPre			*.br call gzip#appre("brotli -d --rm")
    1              0.000001   autocmd FileAppendPre			*.lzo call gzip#appre("lzop -d -U")
    1              0.000002   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000002   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000002   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000003   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000002   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000001   autocmd FileAppendPost		*.lz call gzip#write("lzip")
    1              0.000001   autocmd FileAppendPost		*.zst call gzip#write("zstd --rm")
    1              0.000001   autocmd FileAppendPost		*.br call gzip#write("brotli --rm")
    1              0.000001   autocmd FileAppendPost		*.lzo call gzip#write("lzop -U")
    1              0.000002 augroup END

SCRIPT  /usr/share/nvim/runtime/plugin/health.vim
Sourced 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000005 autocmd CmdUndefined CheckHealth checkhealth

SCRIPT  /usr/share/nvim/runtime/plugin/man.vim
Sourced 1 time
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
                            " Maintainer: Anmol Sethi <hi@nhooyr.io>
                            
    1              0.000003 if exists('g:loaded_man')
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_man = 1
                            
    1              0.000012 command! -bang -bar -addr=other -complete=customlist,man#complete -nargs=* Man
                                  \ if <bang>0 | call man#init_pager() |
                                  \ else | call man#open_page(<count>, <q-mods>, <f-args>) | endif
                            
    1              0.000001 augroup man
    1              0.000172   autocmd!
    1              0.000004   autocmd BufReadCmd man://* call man#read_page(matchstr(expand('<amatch>'), 'man://\zs.*'))
    1              0.000002 augroup END

SCRIPT  /usr/share/nvim/runtime/plugin/matchit.vim
Sourced 1 time
Total time:   0.001614
 Self time:   0.001333

count  total (s)   self (s)
                            " Nvim: load the matchit plugin by default.
    1              0.000009 if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
    1   0.001597   0.001317   packadd matchit
    1              0.000003 endif

SCRIPT  /usr/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
Sourced 1 time
Total time:   0.000273
 Self time:   0.000273

count  total (s)   self (s)
                            "  matchit.vim: (global plugin) Extended "%" matching
                            "  Maintainer:  Christian Brabandt
                            "  Version:     1.17
                            "  Last Change: 2019 Oct 24
                            "  Repository:  https://github.com/chrisbra/matchit
                            "  Previous URL:http://www.vim.org/script.php?script_id=39
                            "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
                            
                            " Documentation:
                            "  The documentation is in a separate file: ../doc/matchit.txt
                            
                            " Credits:
                            "  Vim editor by Bram Moolenaar (Thanks, Bram!)
                            "  Original script and design by Raul Segura Acevedo
                            "  Support for comments by Douglas Potts
                            "  Support for back references and other improvements by Benji Fisher
                            "  Support for many languages by Johannes Zellner
                            "  Suggestions for improvement, bug reports, and support for additional
                            "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
                            "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
                            
                            " Debugging:
                            "  If you'd like to try the built-in debugging commands...
                            "   :MatchDebug      to activate debugging for the current buffer
                            "  This saves the values of several key script variables as buffer-local
                            "  variables.  See the MatchDebug() function, below, for details.
                            
                            " TODO:  I should think about multi-line patterns for b:match_words.
                            "   This would require an option:  how many lines to scan (default 1).
                            "   This would be useful for Python, maybe also for *ML.
                            " TODO:  Maybe I should add a menu so that people will actually use some of
                            "   the features that I have implemented.
                            " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
                            "   Match_wrapper() instead.
                            " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
                            " TODO:  Make backrefs safer by using '\V' (very no-magic).
                            " TODO:  Add a level of indirection, so that custom % scripts can use my
                            "   work but extend it.
                            
                            " Allow user to prevent loading and prevent duplicate loading.
    1              0.000009 if exists("g:loaded_matchit") || &cp
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_matchit = 1
                            
    1              0.000003 let s:save_cpo = &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000035 nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
    1              0.000010 nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
    1              0.000011 xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>m'gv``
    1              0.000008 xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
    1              0.000009 onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
    1              0.000008 onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
                            
    1              0.000007 nmap <silent> %  <Plug>(MatchitNormalForward)
    1              0.000007 nmap <silent> g% <Plug>(MatchitNormalBackward)
    1              0.000007 xmap <silent> %  <Plug>(MatchitVisualForward)
    1              0.000006 xmap <silent> g% <Plug>(MatchitVisualBackward)
    1              0.000006 omap <silent> %  <Plug>(MatchitOperationForward)
    1              0.000006 omap <silent> g% <Plug>(MatchitOperationBackward)
                            
                            " Analogues of [{ and ]} using matching patterns:
    1              0.000008 nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
    1              0.000007 nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
    1              0.000008 xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
    1              0.000007 xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
    1              0.000007 onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
    1              0.000007 onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
                            
    1              0.000006 nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
    1              0.000006 nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
    1              0.000006 xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
    1              0.000006 xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
    1              0.000006 omap <silent> [% <Plug>(MatchitOperationMultiBackward)
    1              0.000006 omap <silent> ]% <Plug>(MatchitOperationMultiForward)
                            
                            " text object:
    1              0.000009 xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
    1              0.000005 xmap a% <Plug>(MatchitVisualTextObject)
                            
                            " Call this function to turn on debugging information.  Every time the main
                            " script is run, buffer variables will be saved.  These can be used directly
                            " or viewed using the menu items below.
    1              0.000005 if !exists(":MatchDebug")
    1              0.000004   command! -nargs=0 MatchDebug call matchit#Match_debug()
    1              0.000000 endif
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:et:

SCRIPT  /usr/share/nvim/runtime/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2021 Apr 08
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
                            " - the "CursorMoved" autocmd event is not available.
    1              0.000007 if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_matchparen = 1
                            
    1              0.000002 if !exists("g:matchparen_timeout")
    1              0.000001   let g:matchparen_timeout = 300
    1              0.000000 endif
    1              0.000001 if !exists("g:matchparen_insert_timeout")
    1              0.000001   let g:matchparen_insert_timeout = 60
    1              0.000000 endif
                            
    1              0.000001 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000007   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
    1              0.000002   autocmd! WinLeave * call s:Remove_Matches()
    1              0.000002   if exists('##TextChanged')
    1              0.000004     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000000   endif
    1              0.000000 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000004 if exists("*s:Highlight_Matching_Pair")
                              finish
    1              0.000000 endif
                            
    1              0.000003 let s:cpo_save = &cpo
    1              0.000004 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000002 func s:Highlight_Matching_Pair()
                              " Remove any previous match.
                              call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
                              if empty(matches)
                                let [c_before, c] = ['', '']
                              else
                                let [c_before, c] = matches[1:2]
                              endif
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' .
                            	\ '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
    1              0.000001 func s:Remove_Matches()
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            endfunc
                            
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000003 command DoMatchParen call s:DoMatchParen()
    1              0.000003 command NoMatchParen call s:NoMatchParen()
                            
    1              0.000001 func s:NoMatchParen()
                              let w = winnr()
                              noau windo silent! call matchdelete(3)
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen
                            endfunc
                            
    1              0.000001 func s:DoMatchParen()
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"
                            endfunc
                            
    1              0.000004 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.000729
 Self time:   0.000729

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Date:		Feb 09, 2021
                            " Maintainer:	Charles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000005 if &cp || exists("g:loaded_netrwPlugin")
                             finish
    1              0.000000 endif
    1              0.000001 let g:loaded_netrwPlugin = "v171"
    1              0.000002 let s:keepcpo = &cpo
    1              0.000003 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing Autocmds: {{{2
    1              0.000001 augroup FileExplorer
    1              0.000238  au!
    1              0.000004  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
    1              0.000002  au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000002  au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
    1              0.000007  if has("win32") || has("win95") || has("win64") || has("win16")
                              au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000000  endif
    1              0.000001 augroup END
                            
                            " Network Browsing Reading Writing: {{{2
    1              0.000001 augroup Network
    1              0.000163  au!
    1              0.000004  au BufReadCmd   file://*											call netrw#FileUrlEdit(expand("<amatch>"))
    1              0.000009  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
    1              0.000012  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
    1              0.000009  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
    1              0.000013  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
    1              0.000001  try
    1              0.000009   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             catch /^Vim\%((\a\+)\)\=:E216/
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
    1              0.000001  endtry
    1              0.000000 augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
    1              0.000009 com! -count=1 -nargs=*	Nread		let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
    1              0.000007 com! -range=% -nargs=*	Nwrite		let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000002 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
    1              0.000004 com! -nargs=*	        Nsource		let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000002 com! -nargs=?		Ntree		call netrw#SetTreetop(1,<q-args>)
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
    1              0.000007 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
    1              0.000006 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
    1              0.000004 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
    1              0.000005 com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
    1              0.000004 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
    1              0.000002 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
    1              0.000002 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
    1              0.000004 com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore	call netrw#Lexplore(<count>,<bang>0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
    1              0.000002 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
    1              0.000003 com! -bang	NetrwClean	call netrw#Clean(<bang>0)
                            
                            " Maps:
    1              0.000002 if !exists("g:netrw_nogx")
    1              0.000024  if maparg('gx','n') == ""
    1              0.000018   if !hasmapto('<Plug>NetrwBrowseX')
    1              0.000011    nmap <unique> gx <Plug>NetrwBrowseX
    1              0.000001   endif
    1              0.000010   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
    1              0.000000  endif
    1              0.000007  if maparg('gx','x') == ""
    1              0.000010   if !hasmapto('<Plug>NetrwBrowseXVis')
    1              0.000009    xmap <unique> gx <Plug>NetrwBrowseXVis
    1              0.000000   endif
    1              0.000008   xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
    1              0.000000  endif
    1              0.000000 endif
    1              0.000002 if exists("g:netrw_usetab") && g:netrw_usetab
                             if maparg('<c-tab>','n') == ""
                              nmap <unique> <c-tab> <Plug>NetrwShrink
                             endif
                             nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
    1              0.000000 endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
    1              0.000003 fun! s:LocalBrowse(dirname)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
                              if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            
                            "  call Dret("s:LocalBrowse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
                            "             Its purpose: to look over all windows and run s:LocalBrowse() on
                            "             them, which checks if they're directories and will create a directory
                            "             listing when appropriate.
                            "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
                            "             has already been called.
    1              0.000001 fun! s:VimEnter(dirname)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
                              if has('nvim') || v:version < 802
                              " Johann Höchtl: reported that the call range... line causes an E488: Trailing characters
                              "                error with neovim. I suspect its because neovim hasn't updated with recent
                              "                vim patches. As is, this code will have problems with popup terminals
                              "                instantiated before the VimEnter event runs.
                              " Ingo Karkat  : E488 also in Vim 8.1.1602
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo call s:LocalBrowse(expand("%:p"))
                              exe curwin."wincmd w"
                             else
                              " the following complicated expression comes courtesy of lacygoill; largely does the same thing as the windo and 
                              " wincmd which are commented out, but avoids some side effects. Allows popup terminal before VimEnter.
                              let s:vimentered = 1
                              call range(1, winnr('$'))->map({_, v -> win_execute(win_getid(v), 'call expand("%:p")->s:LocalBrowse()')})
                             endif
                            "  call Dret("s:VimEnter")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
    1              0.000001 fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
    1              0.000001 fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
    1              0.000006 let &cpo= s:keepcpo
    1              0.000001 unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /usr/share/nvim/runtime/plugin/rplugin.vim
Sourced 1 time
Total time:   0.000253
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000004 if exists('g:loaded_remote_plugins')
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_remote_plugins = '/path/to/manifest'
                            
                            " Get the path to the rplugin manifest file.
    1              0.000002 function! s:GetManifestPath() abort
                              let manifest_base = ''
                            
                              if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
                              endif
                            
                              let dest = stdpath('data')
                              if !empty(dest)
                                if !isdirectory(dest)
                                  call mkdir(dest, 'p', 0700)
                                endif
                                let manifest_base = dest
                              endif
                            
                              return manifest_base.'/rplugin.vim'
                            endfunction
                            
                            " Old manifest file based on known script locations.
    1              0.000001 function! s:GetOldManifestPaths() abort
                              let prefix = exists('$MYVIMRC')
                                    \ ? $MYVIMRC
                                    \ : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
                              let origpath = fnamemodify(expand(prefix, 1), ':h')
                                    \.'/.'.fnamemodify(prefix, ':t').'-rplugin~'
                              if !has('win32')
                                return [origpath]
                              endif
                              " Windows used to use $APPLOCALDATA/nvim but stdpath('data') is
                              " $XDG_DATA_DIR/nvim-data
                              let pseudostdpath = exists('$LOCALAPPDATA') ? '$LOCALAPPDATA' : '~/AppData/Local'
                              let pseudostdpath = fnamemodify(expand(pseudostdpath), ':p')
                              return [substitute(pseudostdpath, '[/\\]\=$', '/', '') . 'nvim/rplugin.vim', origpath]
                            endfunction
                            
    1              0.000001 function! s:GetManifest() abort
                              let manifest = s:GetManifestPath()
                              if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
                                for old_manifest in s:GetOldManifestPaths()
                                  if filereadable(old_manifest)
                                    call rename(old_manifest, manifest)
                                    break
                                  endif
                                endfor
                              endif
                              return manifest
                            endfunction
                            
    1              0.000001 function! s:LoadRemotePlugins() abort
                              let g:loaded_remote_plugins = s:GetManifest()
                              if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
                              endif
                            endfunction
                            
    1              0.000005 command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
                            
    1   0.000215   0.000009 call s:LoadRemotePlugins()

SCRIPT  /usr/share/nvim/runtime/plugin/shada.vim
Sourced 1 time
Total time:   0.000216
 Self time:   0.000216

count  total (s)   self (s)
    1              0.000004 if exists('g:loaded_shada_plugin')
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_shada_plugin = 1
                            
    1              0.000001 augroup ShaDaCommands
    1              0.000171   autocmd!
    1              0.000008   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b')))
                                    \ |setlocal filetype=shada
    1              0.000005   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
    1              0.000005   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |if writefile(shada#get_binstrings(getline(1, '$')),
                                                   \expand('<afile>'), 'b') == 0
                                    \ |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))
                                                           \? 0
                                                           \: stridx(&cpoptions, '+') != -1)
                                    \ |endif
    1              0.000006   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'b')
    1              0.000004   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'ab')
    1              0.000003   autocmd SourceCmd *.shada,*.shada.tmp.[a-z]
                                    \ :execute 'rshada' fnameescape(expand('<afile>'))
    1              0.000002 augroup END

SCRIPT  /usr/share/nvim/runtime/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            
    1              0.000009 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
    1              0.000000 endif
    1              0.000002 let loaded_spellfile_plugin = 1
                            
    1              0.000004 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /usr/share/nvim/runtime/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000005 if &cp || exists("g:loaded_tarPlugin")
                             finish
    1              0.000000 endif
    1              0.000001 let g:loaded_tarPlugin = "v32"
    1              0.000002 let s:keepcpo          = &cpo
    1              0.000004 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000001 augroup tar
    1              0.000128   au!
    1              0.000004   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000003   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000002   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000002   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000002   if has("unix")
    1              0.000002    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000002    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000002    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000002    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000000   endif
                            
    1              0.000002   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tbz			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tar.zst		call tar#Browse(expand("<amatch>"))
    1              0.000001   au BufReadCmd   *.tzs			call tar#Browse(expand("<amatch>"))
    1              0.000001 augroup END
    1              0.000007 com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000004 let &cpo= s:keepcpo
    1              0.000003 unlet s:keepcpo

SCRIPT  /usr/share/nvim/runtime/plugin/tohtml.vim
Sourced 1 time
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
                            " Vim plugin for converting a syntax highlighted file to HTML.
                            " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
                            " Last Change: 2019 Nov 13
                            "
                            " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
                            " $VIMRUNTIME/syntax/2html.vim
                            "
    1              0.000003 if exists('g:loaded_2html_plugin')
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_2html_plugin = 'vim8.1_v2'
                            
                            "
                            " Changelog: {{{
                            "   8.1_v2  (this version): - Fix Bitbucket issue #19: fix calculation of tab
                            "                             stop position to use in expanding a tab, when that
                            "                             tab occurs after a syntax match which in turn
                            "                             comes after previously expanded tabs.
                            "                           - Set eventignore while splitting a window for the
                            "                             destination file to ignore FileType events;
                            "                             speeds up processing when the destination file
                            "                             already exists and HTML highlight takes too long.
                            "                           - Fix Bitbucket issue #20: progress bar could not be
                            "                             seen when DiffDelete background color matched
                            "                             StatusLine background color. Added TOhtmlProgress
                            "                             highlight group for manual user override, but
                            "                             calculate it to be visible compared to StatusLine
                            "                             by default.
                            "                           - Fix Bitbucket issue #1: Remove workaround for old
                            "                             browsers which don't support 'ch' CSS unit, since
                            "                             all modern browsers, including IE>=9, support it.
                            "                           - Fix Bitbucket issue #10: support termguicolors
                            "                           - Fix Bitbucket issue #21: default to using
                            "                             generated content instead of <input> tags for
                            "                             uncopyable text, so that text is correctly
                            "                             prevented from being copied in chrome. Use
                            "                             g:html_use_input_for_pc option to control the
                            "                             method used.
                            "                           - Switch to HTML5 to allow using vnu as a validator
                            "                             in unit test.
                            "                           - Fix fallback sizing of <input> tags for browsers
                            "                             without "ch" support.
                            "                           - Fix cursor on unselectable diff filler text.
                            "   8.1_v1  (Vim 8.1.0528): - Fix Bitbucket issue #6: Don't generate empty
                            "                             script tag.
                            "                           - Fix Bitbucket issue #5: javascript should
                            "                             declare variables with "var".
                            "                           - Fix Bitbucket issue #13: errors thrown sourcing
                            "                             2html.vim directly when plugins not loaded.
                            "                           - Fix Bitbucket issue #16: support 'vartabstop'.
                            "
                            "   7.4 updates: {{{
                            "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
                            "                           an empty buffer. Jan Stocker: allow g:html_font to
                            "                           take a list so it is easier to specfiy fallback
                            "                           fonts in the generated CSS.
                            "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
                            "			    also for version-specific modelines like "vim>703:".
                            "}}}
                            "
                            "   7.3 updates: {{{
                            "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
                            "			    g:html_line_ids=0. Allow customizing
                            "			    important IDs (like line IDs and fold IDs) using
                            "			    g:html_id_expr evaluated when the buffer conversion
                            "			    is started.
                            "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
                            "			    insert modeline to set it to manual.
                            "			    Fix bug: diff mode with 2 unsaved buffers creates a
                            "			    duplicate of one buffer instead of including both.
                            "			    Add anchors to each line so you can put '#L123'
                            "			    or '#123' at the end of the URL to jump to line 123
                            "			    (idea by Andy Spencer). Add javascript to open folds
                            "			    to show the anchor being jumped to if it is hidden.
                            "			    Fix XML validation error: &nsbp; not part of XML.
                            "			    Allow TOhtml to chain together with other commands
                            "			    using |.
                            "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
                            "			    highlight groups make up the start-of-modeline text.
                            "			    Improve render time of page with uncopyable regions
                            "			    by not using one-input-per-char. Change name of
                            "			    uncopyable option from html_unselectable to
                            "			    html_prevent_copy. Added html_no_invalid option and
                            "			    default to inserting invalid markup for uncopyable
                            "			    regions to prevent MS Word from pasting undeletable
                            "			    <input> elements. Fix 'cpo' handling (Thilo Six).
                            "		 7.3_v12b1: Add html_unselectable option. Rework logic to
                            "			    eliminate post-processing substitute commands in
                            "			    favor of doing the work up front. Remove unnecessary
                            "			    special treatment of 'LineNr' highlight group. Minor
                            "			    speed improvements. Fix modeline mangling in
                            "			    generated output so it works for text in the first
                            "			    column. Fix missing line number and fold column in
                            "			    diff filler lines. Fix that some fonts have a 1px
                            "			    gap (using a dirty hack, improvements welcome). Add
                            "			    "colorscheme" meta tag. Does NOT include support for
                            "			    the new default foldtext added in v11, as the patch
                            "			    adding it has not yet been included in Vim.
                            "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
                            "			    Brabandt in
                            "			    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
                            "			    This patch has not yet been included in Vim, thus
                            "			    these changes are removed in the next version.
                            "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
                            "			    multiple nested folds with dynamic folding on.
                            "			    Also fix problem with foldtext in this situation.
                            "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
                            "			    and without html_no_pre, default value same as
                            "			    'wrap' option, (Andy Spencer). Don't use
                            "			    'fileencoding' for converted document encoding if
                            "			    'buftype' indicates a special buffer which isn't
                            "			    written.
                            "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
                            "			    characters in generated output (Andy Spencer).
                            "			    Escape text that looks like a modeline so Vim
                            "			    doesn't use anything in the converted HTML as a
                            "			    modeline. Bugfixes: Fix folding when a fold starts
                            "			    before the conversion range. Remove fold column when
                            "			    there are no folds.
                            "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
                            "		  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
                            "		  7.3_v7b2: Remove automatic detection of encodings that are not
                            "			    supported by all major browsers according to
                            "			    http://wiki.whatwg.org/wiki/Web_Encodings and
                            "			    convert to UTF-8 for all Unicode encodings. Make
                            "			    HTML encoding to Vim encoding detection be
                            "			    case-insensitive for built-in pairs.
                            "		  7.3_v7b1: Remove use of setwinvar() function which cannot be
                            "			    called in restricted mode (Andy Spencer). Use
                            "			    'fencoding' instead of 'encoding' to determine by
                            "			    charset, and make sure the 'fenc' of the generated
                            "			    file matches its indicated charset. Add charsets for
                            "			    all of Vim's natively supported encodings.
                            "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
                            "			    user settings interfering with diff mode generation,
                            "			    trailing whitespace (e.g. line number column) when
                            "			    using html_no_pre, and bugs when using
                            "			    html_hover_unfold.
                            "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
                            "			    folds in diff mode when first line was folded.
                            "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
                            "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
                            "			    default to true when not set to anything. Use strict
                            "			    doctypes where possible. Rename use_xhtml option to
                            "			    html_use_xhtml for consistency. Use .xhtml extension
                            "			    when using this option. Add meta tag for settings.
                            "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
                            "			    diff colors and the normal syntax colors
                            "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
                            "}}}
                            "}}}
                            
                            " TODO: {{{
                            "   * Check the issue tracker:
                            "     https://bitbucket.org/fritzophrenic/vim-tohtml/issues?status=new&status=open
                            "   * Options for generating the CSS in external style sheets. New :TOcss
                            "     command to convert the current color scheme into a (mostly) generic CSS
                            "     stylesheet which can be re-used. Alternate stylesheet support? Good start
                            "     by Erik Falor
                            "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
                            "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
                            "     term) to use for the styling. Suggestion by "nacitar".
                            "   * Add way to override or specify which RGB colors map to the color numbers
                            "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
                            "   * Disable filetype detection until after all processing is done.
                            "   * Add option for not generating the hyperlink on stuff that looks like a
                            "     URL? Or just color the link to fit with the colorscheme (and only special
                            "     when hovering)?
                            "   * Bug: Opera does not allow printing more than one page if uncopyable
                            "     regions is turned on. Possible solution: Add normal text line numbers with
                            "     display:none, set to display:inline for print style sheets, and hide
                            "     <input> elements for print, to allow Opera printing multiple pages (and
                            "     other uncopyable areas?). May need to make the new text invisible to IE
                            "     with conditional comments to prevent copying it, IE for some reason likes
                            "     to copy hidden text. Other browsers too?
                            "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
                            "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
                            "     on Windows). Perhaps it is font related?
                            "   * Bug: still some gaps in the fold column when html_prevent_copy contains
                            "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
                            "     on diff lines though.
                            "   * Undercurl support via CSS3, with fallback to dotted or something:
                            "	https://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
                            "   * Redo updates for modified default foldtext (v11) when/if the patch is
                            "     accepted to modify it.
                            "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
                            "		+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
                            "		+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
                            "     does not show the whole diff filler as it is supposed to?
                            "   * Bug: when 'isprint' is wrong for the current encoding, will generate
                            "     invalid content. Can/should anything be done about this? Maybe a separate
                            "     plugin to correct 'isprint' based on encoding?
                            "   * Check to see if the windows-125\d encodings actually work in Unix without
                            "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
                            "   * Font auto-detection similar to
                            "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
                            "     platforms.
                            "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
                            "	- listchars support
                            "	- full-line background highlight
                            "	- other?
                            "   * Make it so deleted lines in a diff don't create side-scrolling (get it
                            "     free with full-line background highlight above).
                            "   * Restore open/closed folds and cursor position after processing each file
                            "     with option not to restore for speed increase.
                            "   * Add extra meta info (generation time, etc.)?
                            "   * Tidy up so we can use strict doctype in even more situations
                            "   * Implementation detail: add threshold for writing the lines to the html
                            "     buffer before we're done (5000 or so lines should do it)
                            "   * TODO comments for code cleanup scattered throughout
                            "}}}
                            
                            " Define the :TOhtml command when:
                            " - 'compatible' is not set
                            " - this plugin or user override was not already loaded
                            " - user commands are available. {{{
    1              0.000008 if !&cp && !exists(":TOhtml") && has("user_commands")
    1              0.000012   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
    1              0.000001 endif "}}}
                            
                            " Make sure any patches will probably use consistent indent
                            "   vim: ts=8 sw=2 sts=2 noet fdm=marker

SCRIPT  /usr/share/nvim/runtime/plugin/tutor.vim
Sourced 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000004 if exists('g:loaded_tutor_mode_plugin') || &compatible
                                finish
    1              0.000000 endif
    1              0.000002 let g:loaded_tutor_mode_plugin = 1
                            
    1              0.000005 command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)

SCRIPT  /usr/share/nvim/runtime/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Jan 07, 2020
                            " Maintainer:	Charles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000004 if &cp || exists("g:loaded_zipPlugin")
                             finish
    1              0.000000 endif
    1              0.000001 let g:loaded_zipPlugin = "v32"
    1              0.000002 let s:keepcpo          = &cpo
    1              0.000003 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
    1              0.000002 if !exists("g:zipPlugin_ext")
    1              0.000004  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
    1              0.000000 endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000001 augroup zip
    1              0.000087  au!
    1              0.000004  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000003  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000002  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000002  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000001  if has("unix")
    1              0.000003   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000002   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000002   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000002   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000000  endif
                            
    1              0.000042  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
    1              0.000001 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000004 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo

SCRIPT  /usr/share/vim/vimfiles/plugin/fzf.vim
Sourced 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            " Copyright (c) 2017 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000003 if exists('g:loaded_fzf')
    1              0.000001   finish
                            endif
                            let g:loaded_fzf = 1
                            
                            let s:is_win = has('win32') || has('win64')
                            if s:is_win && &shellslash
                              set noshellslash
                              let s:base_dir = expand('<sfile>:h:h')
                              set shellslash
                            else
                              let s:base_dir = expand('<sfile>:h:h')
                            endif
                            if s:is_win
                              let s:term_marker = '&::FZF'
                            
                              function! s:fzf_call(fn, ...)
                                let shellslash = &shellslash
                                try
                                  set noshellslash
                                  return call(a:fn, a:000)
                                finally
                                  let &shellslash = shellslash
                                endtry
                              endfunction
                            
                              " Use utf-8 for fzf.vim commands
                              " Return array of shell commands for cmd.exe
                              function! s:enc_to_cp(str)
                                if !has('iconv')
                                  return a:str
                                endif
                                if !exists('s:codepage')
                                  let s:codepage = libcallnr('kernel32.dll', 'GetACP', 0)
                                endif
                                return iconv(a:str, &encoding, 'cp'.s:codepage)
                              endfunction
                              function! s:wrap_cmds(cmds)
                                return map([
                                  \ '@echo off',
                                  \ 'setlocal enabledelayedexpansion']
                                \ + (has('gui_running') ? ['set TERM= > nul'] : [])
                                \ + (type(a:cmds) == type([]) ? a:cmds : [a:cmds])
                                \ + ['endlocal'],
                                \ '<SID>enc_to_cp(v:val."\r")')
                              endfunction
                            else
                              let s:term_marker = ";#FZF"
                            
                              function! s:fzf_call(fn, ...)
                                return call(a:fn, a:000)
                              endfunction
                            
                              function! s:wrap_cmds(cmds)
                                return a:cmds
                              endfunction
                            
                              function! s:enc_to_cp(str)
                                return a:str
                              endfunction
                            endif
                            
                            function! s:shellesc_cmd(arg)
                              let escaped = substitute(a:arg, '[&|<>()@^]', '^&', 'g')
                              let escaped = substitute(escaped, '%', '%%', 'g')
                              let escaped = substitute(escaped, '"', '\\^&', 'g')
                              let escaped = substitute(escaped, '\(\\\+\)\(\\^\)', '\1\1\2', 'g')
                              return '^"'.substitute(escaped, '\(\\\+\)$', '\1\1', '').'^"'
                            endfunction
                            
                            function! fzf#shellescape(arg, ...)
                              let shell = get(a:000, 0, s:is_win ? 'cmd.exe' : 'sh')
                              if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
                              endif
                              return s:fzf_call('shellescape', a:arg)
                            endfunction
                            
                            function! s:fzf_getcwd()
                              return s:fzf_call('getcwd')
                            endfunction
                            
                            function! s:fzf_fnamemodify(fname, mods)
                              return s:fzf_call('fnamemodify', a:fname, a:mods)
                            endfunction
                            
                            function! s:fzf_expand(fmt)
                              return s:fzf_call('expand', a:fmt, 1)
                            endfunction
                            
                            function! s:fzf_tempname()
                              return s:fzf_call('tempname')
                            endfunction
                            
                            let s:layout_keys = ['window', 'tmux', 'up', 'down', 'left', 'right']
                            let s:fzf_go = s:base_dir.'/bin/fzf'
                            let s:fzf_tmux = s:base_dir.'/bin/fzf-tmux'
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            function! s:popup_support()
                              return has('nvim') ? has('nvim-0.4') : has('popupwin') && has('patch-8.2.191')
                            endfunction
                            
                            function! s:default_layout()
                              return s:popup_support()
                                    \ ? { 'window' : { 'width': 0.9, 'height': 0.6 } }
                                    \ : { 'down': '~40%' }
                            endfunction
                            
                            function! fzf#install()
                              if s:is_win && !has('win32unix')
                                let script = s:base_dir.'/install.ps1'
                                if !filereadable(script)
                                  throw script.' not found'
                                endif
                                let script = 'powershell -ExecutionPolicy Bypass -file ' . script
                              else
                                let script = s:base_dir.'/install'
                                if !executable(script)
                                  throw script.' not found'
                                endif
                                let script .= ' --bin'
                              endif
                            
                              call s:warn('Running fzf installer ...')
                              call system(script)
                              if v:shell_error
                                throw 'Failed to download fzf: '.script
                              endif
                            endfunction
                            
                            let s:versions = {}
                            function s:get_version(bin)
                              if has_key(s:versions, a:bin)
                                return s:versions[a:bin]
                              end
                              let command = a:bin . ' --version --no-height'
                              let output = systemlist(command)
                              if v:shell_error || empty(output)
                                return ''
                              endif
                              let ver = matchstr(output[-1], '[0-9.]\+')
                              let s:versions[a:bin] = ver
                              return ver
                            endfunction
                            
                            function! s:compare_versions(a, b)
                              let a = split(a:a, '\.')
                              let b = split(a:b, '\.')
                              for idx in range(0, max([len(a), len(b)]) - 1)
                                let v1 = str2nr(get(a, idx, 0))
                                let v2 = str2nr(get(b, idx, 0))
                                if     v1 < v2 | return -1
                                elseif v1 > v2 | return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
                            function! s:compare_binary_versions(a, b)
                              return s:compare_versions(s:get_version(a:a), s:get_version(a:b))
                            endfunction
                            
                            let s:checked = {}
                            function! fzf#exec(...)
                              if !exists('s:exec')
                                let binaries = []
                                if executable('fzf')
                                  call add(binaries, 'fzf')
                                endif
                                if executable(s:fzf_go)
                                  call add(binaries, s:fzf_go)
                                endif
                            
                                if empty(binaries)
                                  if input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                    redraw
                                    call fzf#install()
                                    return fzf#exec()
                                  else
                                    redraw
                                    throw 'fzf executable not found'
                                  endif
                                elseif len(binaries) > 1
                                  call sort(binaries, 's:compare_binary_versions')
                                endif
                            
                                let s:exec = binaries[-1]
                              endif
                            
                              if a:0 && !has_key(s:checked, a:1)
                                let fzf_version = s:get_version(s:exec)
                                if empty(fzf_version)
                                  let message = printf('Failed to run "%s --version"', s:exec)
                                  unlet s:exec
                                  throw message
                                end
                            
                                if s:compare_versions(fzf_version, a:1) >= 0
                                  let s:checked[a:1] = 1
                                  return s:exec
                                elseif a:0 < 2 && input(printf('You need fzf %s or above. Found: %s. Download binary? (y/n) ', a:1, fzf_version)) =~? '^y'
                                  let s:versions = {}
                                  unlet s:exec
                                  redraw
                                  call fzf#install()
                                  return fzf#exec(a:1, 1)
                                else
                                  throw printf('You need to upgrade fzf (required: %s or above)', a:1)
                                endif
                              endif
                            
                              return s:exec
                            endfunction
                            
                            function! s:tmux_enabled()
                              if has('gui_running') || !exists('$TMUX')
                                return 0
                              endif
                            
                              if exists('s:tmux')
                                return s:tmux
                              endif
                            
                              let s:tmux = 0
                              if !executable(s:fzf_tmux)
                                if executable('fzf-tmux')
                                  let s:fzf_tmux = 'fzf-tmux'
                                else
                                  return 0
                                endif
                              endif
                            
                              let output = system('tmux -V')
                              let s:tmux = !v:shell_error && output >= 'tmux 1.7'
                              return s:tmux
                            endfunction
                            
                            function! s:escape(path)
                              let path = fnameescape(a:path)
                              return s:is_win ? escape(path, '$') : path
                            endfunction
                            
                            function! s:error(msg)
                              echohl ErrorMsg
                              echom a:msg
                              echohl None
                            endfunction
                            
                            function! s:warn(msg)
                              echohl WarningMsg
                              echom a:msg
                              echohl None
                            endfunction
                            
                            function! s:has_any(dict, keys)
                              for key in a:keys
                                if has_key(a:dict, key)
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
                            function! s:open(cmd, target)
                              if stridx('edit', a:cmd) == 0 && s:fzf_fnamemodify(a:target, ':p') ==# s:fzf_expand('%:p')
                                return
                              endif
                              execute a:cmd s:escape(a:target)
                            endfunction
                            
                            function! s:common_sink(action, lines) abort
                              if len(a:lines) < 2
                                return
                              endif
                              let key = remove(a:lines, 0)
                              let Cmd = get(a:action, key, 'e')
                              if type(Cmd) == type(function('call'))
                                return Cmd(a:lines)
                              endif
                              if len(a:lines) > 1
                                augroup fzf_swap
                                  autocmd SwapExists * let v:swapchoice='o'
                                        \| call s:warn('fzf: E325: swap file exists: '.s:fzf_expand('<afile>'))
                                augroup END
                              endif
                              try
                                let empty = empty(s:fzf_expand('%')) && line('$') == 1 && empty(getline(1)) && !&modified
                                " Preserve the current working directory in case it's changed during
                                " the execution (e.g. `set autochdir` or `autocmd BufEnter * lcd ...`)
                                let cwd = exists('w:fzf_pushd') ? w:fzf_pushd.dir : expand('%:p:h')
                                for item in a:lines
                                  if item[0] != '~' && item !~ (s:is_win ? '^[A-Z]:\' : '^/')
                                    let sep = s:is_win ? '\' : '/'
                                    let item = join([cwd, item], cwd[len(cwd)-1] == sep ? '' : sep)
                                  endif
                                  if empty
                                    execute 'e' s:escape(item)
                                    let empty = 0
                                  else
                                    call s:open(Cmd, item)
                                  endif
                                  if !has('patch-8.0.0177') && !has('nvim-0.2') && exists('#BufEnter')
                                        \ && isdirectory(item)
                                    doautocmd BufEnter
                                  endif
                                endfor
                              catch /^Vim:Interrupt$/
                              finally
                                silent! autocmd! fzf_swap
                              endtry
                            endfunction
                            
                            function! s:get_color(attr, ...)
                              let gui = !s:is_win && !has('win32unix') && has('termguicolors') && &termguicolors
                              let fam = gui ? 'gui' : 'cterm'
                              let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
                              for group in a:000
                                let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
                                if code =~? pat
                                  return code
                                endif
                              endfor
                              return ''
                            endfunction
                            
                            function! s:defaults()
                              let rules = copy(get(g:, 'fzf_colors', {}))
                              let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
                              return empty(colors) ? '' : fzf#shellescape('--color='.colors)
                            endfunction
                            
                            function! s:validate_layout(layout)
                              for key in keys(a:layout)
                                if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s',
                                        \ key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
                                endif
                              endfor
                              return a:layout
                            endfunction
                            
                            function! s:evaluate_opts(options)
                              return type(a:options) == type([]) ?
                                    \ join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options
                            endfunction
                            
                            " [name string,] [opts dict,] [fullscreen boolean]
                            function! fzf#wrap(...)
                              let args = ['', {}, 0]
                              let expects = map(copy(args), 'type(v:val)')
                              let tidx = 0
                              for arg in copy(a:000)
                                let tidx = index(expects, type(arg) == 6 ? type(0) : type(arg), tidx)
                                if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
                                endif
                                let args[tidx] = arg
                                let tidx += 1
                                unlet arg
                              endfor
                              let [name, opts, bang] = args
                            
                              if len(name)
                                let opts.name = name
                              end
                            
                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
                              if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
                              elseif !s:has_any(opts, s:layout_keys)
                                if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
                                else
                                  let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout())))
                                endif
                              endif
                            
                              " Colors: g:fzf_colors
                              let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                            
                              " History: g:fzf_history_dir
                              if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
                              endif
                            
                              " Action: g:fzf_action
                              if !s:has_any(opts, ['sink', 'sinklist', 'sink*'])
                                let opts._action = get(g:, 'fzf_action', s:default_action)
                                let opts.options .= ' --expect='.join(keys(opts._action), ',')
                                function! opts.sinklist(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
                                let opts['sink*'] = opts.sinklist " For backward compatibility
                              endif
                            
                              return opts
                            endfunction
                            
                            function! s:use_sh()
                              let [shell, shellslash, shellcmdflag, shellxquote] = [&shell, &shellslash, &shellcmdflag, &shellxquote]
                              if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                                let &shellcmdflag = has('nvim') ? '/s /c' : '/c'
                                let &shellxquote = has('nvim') ? '"' : '('
                              else
                                set shell=sh
                              endif
                              return [shell, shellslash, shellcmdflag, shellxquote]
                            endfunction
                            
                            function! s:writefile(...)
                              if call('writefile', a:000) == -1
                                throw 'Failed to write temporary file. Check if you can write to the path tempname() returns.'
                              endif
                            endfunction
                            
                            function! fzf#run(...) abort
                            try
                              let [shell, shellslash, shellcmdflag, shellxquote] = s:use_sh()
                            
                              let dict   = exists('a:1') ? copy(a:1) : {}
                              let temps  = { 'result': s:fzf_tempname() }
                              let optstr = s:evaluate_opts(get(dict, 'options', ''))
                              try
                                let fzf_exec = fzf#shellescape(fzf#exec())
                              catch
                                throw v:exception
                              endtry
                            
                              if !s:present(dict, 'dir')
                                let dict.dir = s:fzf_getcwd()
                              endif
                              if has('win32unix') && s:present(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
                              endif
                            
                              if has_key(dict, 'source')
                                let source = remove(dict, 'source')
                                let type = type(source)
                                if type == 1
                                  let source_command = source
                                elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call s:writefile(source, temps.input)
                                  let source_command = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input)
                                else
                                  throw 'Invalid source type'
                                endif
                              else
                                let source_command = ''
                              endif
                            
                              let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0) || has_key(dict, 'tmux')
                              let use_height = has_key(dict, 'down') && !has('gui_running') &&
                                    \ !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) &&
                                    \ executable('tput') && filereadable('/dev/tty')
                              let has_vim8_term = has('terminal') && has('patch-8.0.995')
                              let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
                              let use_term = has_nvim_term ||
                                \ has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || s:present(dict, 'down', 'up', 'left', 'right', 'window'))
                              let use_tmux = (has_key(dict, 'tmux') || (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:splittable(dict)) && s:tmux_enabled()
                              if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
                              endif
                              if use_term
                                let optstr .= ' --no-height'
                              elseif use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
                              endif
                              let optstr .= s:border_opt(get(dict, 'window', 0))
                              let prev_default_command = $FZF_DEFAULT_COMMAND
                              if len(source_command)
                                let $FZF_DEFAULT_COMMAND = source_command
                              endif
                              let command = (use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
                              if use_term
                                return s:execute_term(dict, command, temps)
                              endif
                            
                              let lines = use_tmux ? s:execute_tmux(dict, command, temps)
                                             \ : s:execute(dict, command, use_height, temps)
                              call s:callback(dict, lines)
                              return lines
                            finally
                              if exists('source_command') && len(source_command)
                                if len(prev_default_command)
                                  let $FZF_DEFAULT_COMMAND = prev_default_command
                                else
                                  let $FZF_DEFAULT_COMMAND = ''
                                  silent! execute 'unlet $FZF_DEFAULT_COMMAND'
                                endif
                              endif
                              let [&shell, &shellslash, &shellcmdflag, &shellxquote] = [shell, shellslash, shellcmdflag, shellxquote]
                            endtry
                            endfunction
                            
                            function! s:present(dict, ...)
                              for key in a:000
                                if !empty(get(a:dict, key, ''))
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
                            function! s:fzf_tmux(dict)
                              let size = get(a:dict, 'tmux', '')
                              if empty(size)
                                for o in ['up', 'down', 'left', 'right']
                                  if s:present(a:dict, o)
                                    let spec = a:dict[o]
                                    if (o == 'up' || o == 'down') && spec[0] == '~'
                                      let size = '-'.o[0].s:calc_size(&lines, spec, a:dict)
                                    else
                                      " Legacy boolean option
                                      let size = '-'.o[0].(spec == 1 ? '' : substitute(spec, '^\~', '', ''))
                                    endif
                                    break
                                  endif
                                endfor
                              endif
                              return printf('LINES=%d COLUMNS=%d %s %s - --',
                                \ &lines, &columns, fzf#shellescape(s:fzf_tmux), size)
                            endfunction
                            
                            function! s:splittable(dict)
                              return s:present(a:dict, 'up', 'down') && &lines > 15 ||
                                    \ s:present(a:dict, 'left', 'right') && &columns > 40
                            endfunction
                            
                            function! s:pushd(dict)
                              if s:present(a:dict, 'dir')
                                let cwd = s:fzf_getcwd()
                                let w:fzf_pushd = {
                                \   'command': haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'),
                                \   'origin': cwd,
                                \   'bufname': bufname('')
                                \ }
                                execute 'lcd' s:escape(a:dict.dir)
                                let cwd = s:fzf_getcwd()
                                let w:fzf_pushd.dir = cwd
                                let a:dict.pushd = w:fzf_pushd
                                return cwd
                              endif
                              return ''
                            endfunction
                            
                            augroup fzf_popd
                              autocmd!
                              autocmd WinEnter * call s:dopopd()
                            augroup END
                            
                            function! s:dopopd()
                              if !exists('w:fzf_pushd')
                                return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd
                            endfunction
                            
                            function! s:xterm_launcher()
                              let fmt = 'xterm -T "[fzf]" -bg "%s" -fg "%s" -geometry %dx%d+%d+%d -e bash -ic %%s'
                              if has('gui_macvim')
                                let fmt .= '&& osascript -e "tell application \"MacVim\" to activate"'
                              endif
                              return printf(fmt,
                                \ escape(synIDattr(hlID("Normal"), "bg"), '#'), escape(synIDattr(hlID("Normal"), "fg"), '#'),
                                \ &columns, &lines/2, getwinposx(), getwinposy())
                            endfunction
                            unlet! s:launcher
                            if s:is_win || has('win32unix')
                              let s:launcher = '%s'
                            else
                              let s:launcher = function('s:xterm_launcher')
                            endif
                            
                            function! s:exit_handler(code, command, ...)
                              if a:code == 130
                                return 0
                              elseif has('nvim') && a:code == 129
                                " When deleting the terminal buffer while fzf is still running,
                                " Nvim sends SIGHUP.
                                return 0
                              elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
                              endif
                              return 1
                            endfunction
                            
                            function! s:execute(dict, command, use_height, temps) abort
                              call s:pushd(a:dict)
                              if has('unix') && !a:use_height
                                silent! !clear 2> /dev/null
                              endif
                              let escaped = (a:use_height || s:is_win) ? a:command : escape(substitute(a:command, '\n', '\\n', 'g'), '%#!')
                              if has('gui_running')
                                let Launcher = get(a:dict, 'launcher', get(g:, 'Fzf_launcher', get(g:, 'fzf_launcher', s:launcher)))
                                let fmt = type(Launcher) == 2 ? call(Launcher, []) : Launcher
                                if has('unix')
                                  let escaped = "'".substitute(escaped, "'", "'\"'\"'", 'g')."'"
                                endif
                                let command = printf(fmt, escaped)
                              else
                                let command = escaped
                              endif
                              if s:is_win
                                let batchfile = s:fzf_tempname().'.bat'
                                call s:writefile(s:wrap_cmds(command), batchfile)
                                let command = batchfile
                                let a:temps.batchfile = batchfile
                                if has('nvim')
                                  let fzf = {}
                                  let fzf.dict = a:dict
                                  let fzf.temps = a:temps
                                  function! fzf.on_exit(job_id, exit_status, event) dict
                                    call s:pushd(self.dict)
                                    let lines = s:collect(self.temps)
                                    call s:callback(self.dict, lines)
                                  endfunction
                                  let cmd = 'start /wait cmd /c '.command
                                  call jobstart(cmd, fzf)
                                  return []
                                endif
                              elseif has('win32unix') && $TERM !=# 'cygwin'
                                let shellscript = s:fzf_tempname()
                                call s:writefile([command], shellscript)
                                let command = 'cmd.exe /C '.fzf#shellescape('set "TERM=" & start /WAIT sh -c '.shellscript)
                                let a:temps.shellscript = shellscript
                              endif
                              if a:use_height
                                call system(printf('tput cup %d > /dev/tty; tput cnorm > /dev/tty; %s < /dev/tty 2> /dev/tty', &lines, command))
                              else
                                execute 'silent !'.command
                              endif
                              let exit_status = v:shell_error
                              redraw!
                              let lines = s:collect(a:temps)
                              return s:exit_handler(exit_status, command) ? lines : []
                            endfunction
                            
                            function! s:execute_tmux(dict, command, temps) abort
                              let command = a:command
                              let cwd = s:pushd(a:dict)
                              if len(cwd)
                                " -c '#{pane_current_path}' is only available on tmux 1.9 or above
                                let command = join(['cd', fzf#shellescape(cwd), '&&', command])
                              endif
                            
                              call system(command)
                              let exit_status = v:shell_error
                              redraw!
                              let lines = s:collect(a:temps)
                              return s:exit_handler(exit_status, command) ? lines : []
                            endfunction
                            
                            function! s:calc_size(max, val, dict)
                              let val = substitute(a:val, '^\~', '', '')
                              if val =~ '%$'
                                let size = a:max * str2nr(val[:-2]) / 100
                              else
                                let size = min([a:max, str2nr(val)])
                              endif
                            
                              let srcsz = -1
                              if type(get(a:dict, 'source', 0)) == type([])
                                let srcsz = len(a:dict.source)
                              endif
                            
                              let opts = $FZF_DEFAULT_OPTS.' '.s:evaluate_opts(get(a:dict, 'options', ''))
                              if opts =~ 'preview'
                                return size
                              endif
                              let margin = match(opts, '--inline-info\|--info[^-]\{-}inline') > match(opts, '--no-inline-info\|--info[^-]\{-}\(default\|hidden\)') ? 1 : 2
                              let margin += stridx(opts, '--border') > stridx(opts, '--no-border') ? 2 : 0
                              if stridx(opts, '--header') > stridx(opts, '--no-header')
                                let margin += len(split(opts, "\n"))
                              endif
                              return srcsz >= 0 ? min([srcsz + margin, size]) : size
                            endfunction
                            
                            function! s:getpos()
                              return {'tab': tabpagenr(), 'win': winnr(), 'winid': win_getid(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}
                            endfunction
                            
                            function! s:border_opt(window)
                              if type(a:window) != type({})
                                return ''
                              endif
                            
                              " Border style
                              let style = tolower(get(a:window, 'border', 'rounded'))
                              if !has_key(a:window, 'border') && !get(a:window, 'rounded', 1)
                                let style = 'sharp'
                              endif
                              if style == 'none' || style == 'no'
                                return ''
                              endif
                            
                              " For --border styles, we need fzf 0.24.0 or above
                              call fzf#exec('0.24.0')
                              let opt = ' --border=' . style
                              if has_key(a:window, 'highlight')
                                let color = s:get_color('fg', a:window.highlight)
                                if len(color)
                                  let opt .= ' --color=border:' . color
                                endif
                              endif
                              return opt
                            endfunction
                            
                            function! s:split(dict)
                              let directions = {
                              \ 'up':    ['topleft', 'resize', &lines],
                              \ 'down':  ['botright', 'resize', &lines],
                              \ 'left':  ['vertical topleft', 'vertical resize', &columns],
                              \ 'right': ['vertical botright', 'vertical resize', &columns] }
                              let ppos = s:getpos()
                              let is_popup = 0
                              try
                                if s:present(a:dict, 'window')
                                  if type(a:dict.window) == type({})
                                    if !s:popup_support()
                                      throw 'Nvim 0.4+ or Vim 8.2.191+ with popupwin feature is required for pop-up window'
                                    end
                                    call s:popup(a:dict.window)
                                    let is_popup = 1
                                  else
                                    execute 'keepalt' a:dict.window
                                  endif
                                elseif !s:splittable(a:dict)
                                  execute (tabpagenr()-1).'tabnew'
                                else
                                  for [dir, triple] in items(directions)
                                    let val = get(a:dict, dir, '')
                                    if !empty(val)
                                      let [cmd, resz, max] = triple
                                      if (dir == 'up' || dir == 'down') && val[0] == '~'
                                        let sz = s:calc_size(max, val, a:dict)
                                      else
                                        let sz = s:calc_size(max, val, {})
                                      endif
                                      execute cmd sz.'new'
                                      execute resz sz
                                      return [ppos, {}, is_popup]
                                    endif
                                  endfor
                                endif
                                return [ppos, is_popup ? {} : { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }, is_popup]
                              finally
                                if !is_popup
                                  setlocal winfixwidth winfixheight
                                endif
                              endtry
                            endfunction
                            
                            nnoremap <silent> <Plug>(fzf-insert) i
                            nnoremap <silent> <Plug>(fzf-normal) <Nop>
                            if exists(':tnoremap')
                              tnoremap <silent> <Plug>(fzf-insert) <C-\><C-n>i
                              tnoremap <silent> <Plug>(fzf-normal) <C-\><C-n>
                            endif
                            
                            function! s:execute_term(dict, command, temps) abort
                              let winrest = winrestcmd()
                              let pbuf = bufnr('')
                              let [ppos, winopts, is_popup] = s:split(a:dict)
                              call s:use_sh()
                              let b:fzf = a:dict
                              let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps,
                                        \ 'winopts': winopts, 'winrest': winrest, 'lines': &lines,
                                        \ 'columns': &columns, 'command': a:command }
                              function! fzf.switch_back(inplace)
                                if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt keepjumps b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif
                              endfunction
                              function! fzf.on_exit(id, code, ...)
                                if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
                                  if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
                                    close
                                  endif
                                  silent! execute 'tabnext' self.ppos.tab
                                  silent! execute self.ppos.win.'wincmd w'
                                endif
                            
                                if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif
                            
                                if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                  execute self.winrest
                                endif
                            
                                let lines = s:collect(self.temps)
                                if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif
                            
                                call s:pushd(self.dict)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)
                            
                                if &buftype == 'terminal'
                                  call feedkeys(&filetype == 'fzf' ? "\<Plug>(fzf-insert)" : "\<Plug>(fzf-normal)")
                                endif
                              endfunction
                            
                              try
                                call s:pushd(a:dict)
                                if s:is_win
                                  let fzf.temps.batchfile = s:fzf_tempname().'.bat'
                                  call s:writefile(s:wrap_cmds(a:command), fzf.temps.batchfile)
                                  let command = fzf.temps.batchfile
                                else
                                  let command = a:command
                                endif
                                let command .= s:term_marker
                                if has('nvim')
                                  call termopen(command, fzf)
                                else
                                  let term_opts = {'exit_cb': function(fzf.on_exit)}
                                  if v:version >= 802
                                    let term_opts.term_kill = 'term'
                                  endif
                                  if is_popup
                                    let term_opts.hidden = 1
                                  else
                                    let term_opts.curwin = 1
                                  endif
                                  let fzf.buf = term_start([&shell, &shellcmdflag, command], term_opts)
                                  if is_popup && exists('#TerminalWinOpen')
                                    doautocmd <nomodeline> TerminalWinOpen
                                  endif
                                  if !has('patch-8.0.1261') && !s:is_win
                                    call term_wait(fzf.buf, 20)
                                  endif
                                endif
                                tnoremap <buffer> <c-z> <nop>
                                if exists('&termwinkey') && (empty(&termwinkey) || &termwinkey =~? '<c-w>')
                                  tnoremap <buffer> <c-w> <c-w>.
                                endif
                              finally
                                call s:dopopd()
                              endtry
                              setlocal nospell bufhidden=wipe nobuflisted nonumber
                              setf fzf
                              startinsert
                              return []
                            endfunction
                            
                            function! s:collect(temps) abort
                              try
                                return filereadable(a:temps.result) ? readfile(a:temps.result) : []
                              finally
                                for tf in values(a:temps)
                                  silent! call delete(tf)
                                endfor
                              endtry
                            endfunction
                            
                            function! s:callback(dict, lines) abort
                              let popd = has_key(a:dict, 'pushd')
                              if popd
                                let w:fzf_pushd = a:dict.pushd
                              endif
                            
                              try
                                if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
                                endif
                                if has_key(a:dict, 'sink*')
                                  call a:dict['sink*'](a:lines)
                                elseif has_key(a:dict, 'sinklist')
                                  call a:dict['sinklist'](a:lines)
                                endif
                              catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
                              endtry
                            
                              " We may have opened a new window or tab
                              if popd
                                let w:fzf_pushd = a:dict.pushd
                                call s:dopopd()
                              endif
                            endfunction
                            
                            if has('nvim')
                              function s:create_popup(hl, opts) abort
                                let buf = nvim_create_buf(v:false, v:true)
                                let opts = extend({'relative': 'editor', 'style': 'minimal'}, a:opts)
                                let win = nvim_open_win(buf, v:true, opts)
                                call setwinvar(win, '&winhighlight', 'NormalFloat:'..a:hl)
                                call setwinvar(win, '&colorcolumn', '')
                                return buf
                              endfunction
                            else
                              function! s:create_popup(hl, opts) abort
                                let s:popup_create = {buf -> popup_create(buf, #{
                                  \ line: a:opts.row,
                                  \ col: a:opts.col,
                                  \ minwidth: a:opts.width,
                                  \ maxwidth: a:opts.width,
                                  \ minheight: a:opts.height,
                                  \ maxheight: a:opts.height,
                                  \ zindex: 1000,
                                \ })}
                                autocmd TerminalOpen * ++once call s:popup_create(str2nr(expand('<abuf>')))
                              endfunction
                            endif
                            
                            function! s:popup(opts) abort
                              let xoffset = get(a:opts, 'xoffset', 0.5)
                              let yoffset = get(a:opts, 'yoffset', 0.5)
                              let relative = get(a:opts, 'relative', 0)
                            
                              " Use current window size for positioning relatively positioned popups
                              let columns = relative ? winwidth(0) : &columns
                              let lines = relative ? winheight(0) : (&lines - has('nvim'))
                            
                              " Size and position
                              let width = min([max([8, a:opts.width > 1 ? a:opts.width : float2nr(columns * a:opts.width)]), columns])
                              let height = min([max([4, a:opts.height > 1 ? a:opts.height : float2nr(lines * a:opts.height)]), lines])
                              let row = float2nr(yoffset * (lines - height)) + (relative ? win_screenpos(0)[0] - 1 : 0)
                              let col = float2nr(xoffset * (columns - width)) + (relative ? win_screenpos(0)[1] - 1 : 0)
                            
                              " Managing the differences
                              let row = min([max([0, row]), &lines - has('nvim') - height])
                              let col = min([max([0, col]), &columns - width])
                              let row += !has('nvim')
                              let col += !has('nvim')
                            
                              call s:create_popup('Normal', {
                                \ 'row': row, 'col': col, 'width': width, 'height': height
                              \ })
                            endfunction
                            
                            let s:default_action = {
                              \ 'ctrl-t': 'tab split',
                              \ 'ctrl-x': 'split',
                              \ 'ctrl-v': 'vsplit' }
                            
                            function! s:shortpath()
                              let short = fnamemodify(getcwd(), ':~:.')
                              if !has('win32unix')
                                let short = pathshorten(short)
                              endif
                              let slash = (s:is_win && !&shellslash) ? '\' : '/'
                              return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)
                            endfunction
                            
                            function! s:cmd(bang, ...) abort
                              let args = copy(a:000)
                              let opts = { 'options': ['--multi'] }
                              if len(args) && isdirectory(expand(args[-1]))
                                let opts.dir = substitute(substitute(remove(args, -1), '\\\(["'']\)', '\1', 'g'), '[/\\]*$', '/', '')
                                if s:is_win && !&shellslash
                                  let opts.dir = substitute(opts.dir, '/', '\\', 'g')
                                endif
                                let prompt = opts.dir
                              else
                                let prompt = s:shortpath()
                              endif
                              let prompt = strwidth(prompt) < &columns - 20 ? prompt : '> '
                              call extend(opts.options, ['--prompt', prompt])
                              call extend(opts.options, args)
                              call fzf#run(fzf#wrap('FZF', opts, a:bang))
                            endfunction
                            
                            command! -nargs=* -complete=dir -bang FZF call s:cmd(<bang>0, <f-args>)
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /usr/share/vim/vimfiles/plugin/redact_pass.vim
Sourced 1 time
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
                            "
                            " redact_pass.vim: Switch off the 'viminfo', 'backup', 'writebackup',
                            " 'swapfile', and 'undofile' globally when editing a password in pass(1).
                            "
                            " This is to prevent anyone being able to extract passwords from your Vim
                            " cache files in the event of a compromise.
                            "
                            " Author: Tom Ryder <tom@sanctum.geek.nz>
                            " License: Same as Vim itself
                            "
    1              0.000003 if exists('g:loaded_redact_pass') || &compatible
                              finish
    1              0.000000 endif
    1              0.000002 if !has('autocmd') || v:version < 600
                              finish
    1              0.000000 endif
    1              0.000002 let g:loaded_redact_pass = 1
                            
                            " Check whether we should set redacting options or not
    1              0.000003 function! s:CheckArgsRedact()
                            
                              " Ensure there's one argument and it's the matched file
                              if argc() != 1 || fnamemodify(argv(0), ':p') !=# expand('<afile>:p')
                                return
                              endif
                            
                              " Disable all the leaky options globally
                              set nobackup
                              set nowritebackup
                              set noswapfile
                              set viminfo=
                              if has('persistent_undo')
                                set noundofile
                              endif
                            
                              " Tell the user what we're doing so they know this worked, via a message and
                              " a global variable they can check
                              redraw
                              echomsg 'Editing password file--disabled leaky options!'
                              let g:redact_pass_redacted = 1
                            
                            endfunction
                            
                            " Auto function loads only when Vim starts up
    1              0.000001 augroup redact_pass
    1              0.000083   autocmd!
    1              0.000012   autocmd VimEnter
                                    \ /dev/shm/pass.?*/?*.txt
                                    \,$TMPDIR/pass.?*/?*.txt
                                    \,/tmp/pass.?*/?*.txt
                                    \ call s:CheckArgsRedact()
                              " Work around macOS' dynamic symlink structure for temporary directories
    1              0.000003   if has('mac')
                                autocmd VimEnter
                                      \ /private/var/?*/pass.?*/?*.txt
                                      \ call s:CheckArgsRedact()
    1              0.000000   endif
    1              0.000002 augroup END

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-signature/after/plugin/signature.vim
Sourced 1 time
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
                            " vim: fdm=marker:et:ts=4:sw=2:sts=2
                            
                            " Maintainer:  Kartik Shenoy
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            " Exit if the signs feature is not available or if the app has already been loaded (or "compatible" mode set)
    1              0.000015 if (  !has('signs')
                             \ || &cp
                             \ )
                              finish
    1              0.000001 endif
                            
                            "" Exit if vim-signature is not loaded
    1              0.000002 if !exists('g:loaded_Signature')
                              finish
    1              0.000000 endif
                            
    1              0.000001 if exists('g:loaded_gitgutter')
                              if g:SignatureMarkTextHLDynamic
                                unlet g:SignatureMarkTextHL
                                let   g:SignatureMarkTextHL = function("signature#sign#GetGitGutterHLGroup")
                              endif
                              if g:SignatureMarkerTextHLDynamic
                                unlet g:SignatureMarkerTextHL
                                let   g:SignatureMarkerTextHL = function("signature#sign#GetGitGutterHLGroup")
                              endif
    1              0.000000 endif
                            
    1              0.000001 if exists('g:loaded_signify')
    1              0.000001   if g:SignatureMarkTextHLDynamic
                                unlet g:SignatureMarkTextHL
                                let   g:SignatureMarkTextHL = function("signature#sign#GetSignifyHLGroup")
    1              0.000000   endif
    1              0.000001   if g:SignatureMarkerTextHLDynamic
                                unlet g:SignatureMarkerTextHL
                                let   g:SignatureMarkerTextHL = function("signature#sign#GetSignifyHLGroup")
    1              0.000000   endif
    1              0.000011 endif

SCRIPT  /home/tony/.config/nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim
Sourced 1 time
Total time:   0.000579
 Self time:   0.000579

count  total (s)   self (s)
                            " Script Name: indentLine.vim
                            " Author:      Yggdroot <archofortune@gmail.com>
                            "
                            " Description: To show the indention levels with thin vertical lines
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000004 if !has("conceal") || exists("g:indentLine_loaded")
                                finish
    1              0.000000 endif
    1              0.000002 let g:indentLine_loaded = 1
                            
    1              0.000005 let g:indentLine_newVersion = get(g:,'indentLine_newVersion',v:version > 704 || v:version == 704 && has("patch792"))
                            
    1              0.000004 let g:indentLine_char = get(g:, 'indentLine_char', (&encoding ==# "utf-8" && &term isnot# "linux" ? '¦' : '|'))
    1              0.000002 let g:indentLine_char_list = get(g:, 'indentLine_char_list', [])
    1              0.000003 let g:indentLine_first_char = get(g:, 'indentLine_first_char', (&encoding ==# "utf-8" && &term isnot# "linux" ? '¦' : '|'))
    1              0.000002 let g:indentLine_indentLevel = get(g:, 'indentLine_indentLevel', 20)
    1              0.000002 let g:indentLine_enabled = get(g:, 'indentLine_enabled', 1)
    1              0.000002 let g:indentLine_fileType = get(g:, 'indentLine_fileType', [])
    1              0.000002 let g:indentLine_fileTypeExclude = get(g:, 'indentLine_fileTypeExclude', ['leaderf'])
    1              0.000002 let g:indentLine_bufNameExclude = get(g:, 'indentLine_bufNameExclude', [])
    1              0.000002 let g:indentLine_bufTypeExclude = get(g:, 'indentLine_bufTypeExclude', [])
    1              0.000002 let g:indentLine_showFirstIndentLevel = get(g:, 'indentLine_showFirstIndentLevel', 0)
    1              0.000002 let g:indentLine_maxLines = get(g:, 'indentLine_maxLines', 3000)
    1              0.000002 let g:indentLine_setColors = get(g:, 'indentLine_setColors', 1)
    1              0.000002 let g:indentLine_setConceal = get(g:, 'indentLine_setConceal', 1)
    1              0.000002 let g:indentLine_defaultGroup = get(g:, 'indentLine_defaultGroup', "")
    1              0.000002 let g:indentLine_faster = get(g:, 'indentLine_faster', 0)
    1              0.000003 let g:indentLine_leadingSpaceChar = get(g:, 'indentLine_leadingSpaceChar', (&encoding ==# "utf-8" && &term isnot# "linux" ? '˰' : '.'))
    1              0.000002 let g:indentLine_leadingSpaceEnabled = get(g:, 'indentLine_leadingSpaceEnabled', 0)
    1              0.000018 let g:indentLine_mysyntaxfile = fnamemodify(expand("<sfile>"), ":p:h:h")."/syntax/indentLine.vim"
                            
                            "{{{1 function! s:InitColor()
    1              0.000004 function! s:InitColor()
                                if !g:indentLine_setColors
                                    return
                                endif
                            
                                let default_term_bg = "NONE"
                                let default_gui_bg  = "NONE"
                                if &background ==# "light"
                                    let default_term_fg = 249
                                    let default_gui_fg = "Grey70"
                                else
                                    let default_term_fg = 239
                                    let default_gui_fg = "Grey30"
                                endif
                            
                                if g:indentLine_defaultGroup != ""
                                    let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
                                    let default_term_fg = synIDattr(default_id, "fg", "cterm") == "" ? default_term_fg :  synIDattr(default_id, "fg", "cterm")
                                    let default_term_bg = synIDattr(default_id, "bg", "cterm") == "" ? default_term_bg :  synIDattr(default_id, "bg", "cterm")
                                    let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
                                    let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
                                endif
                            
                                if !exists("g:indentLine_color_term")
                                    let term_color = default_term_fg
                                else
                                    let term_color = g:indentLine_color_term
                                endif
                            
                                if !exists("g:indentLine_bgcolor_term")
                                    let term_bgcolor = default_term_bg
                                else
                                    let term_bgcolor = g:indentLine_bgcolor_term
                                endif
                            
                                if !exists("g:indentLine_color_gui")
                                    let gui_color = default_gui_fg
                                else
                                    let gui_color = g:indentLine_color_gui
                                endif
                            
                                if !exists("g:indentLine_bgcolor_gui")
                                    let gui_bgcolor = default_gui_bg
                                else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
                                endif
                            
                                execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
                                execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
                                if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
                                endif
                            endfunction
                            
                            "{{{1 function! s:SetConcealOption()
    1              0.000001 function! s:SetConcealOption()
                                if !g:indentLine_setConceal
                                    return
                                endif
                                if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
                                    let b:indentLine_ConcealOptionSet = 1
                                    let b:indentLine_original_concealcursor = &l:concealcursor
                                    let b:indentLine_original_conceallevel = &l:conceallevel
                                    let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
                                    let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
                                endif
                            endfunction
                            
                            "{{{1 function! s:ResetConcealOption()
    1              0.000001 function! s:ResetConcealOption()
                                if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
                                    if exists("b:indentLine_original_concealcursor")
                                        let &l:concealcursor = b:indentLine_original_concealcursor
                                    endif
                                    if exists("b:indentLine_original_conceallevel")
                                        let &l:conceallevel = b:indentLine_original_conceallevel
                                    endif
                                    let b:indentLine_ConcealOptionSet = 0
                                endif
                            endfunction
                            
                            "{{{1 function! s:DisableOnDiff()
    1              0.000001 function! s:DisableOnDiff()
                                if &diff
                                    call s:IndentLinesDisable()
                                    call s:LeadingSpaceDisable()
                                endif
                            endfunction
                            
                            "{{{1 function! s:VimEnter()
    1              0.000001 function! s:VimEnter()
                                let init_winnr = winnr()
                                noautocmd windo call s:DisableOnDiff()
                                noautocmd exec init_winnr . "wincmd w"
                            endfunction
                            
                            "{{{1 function! s:ToggleOnDiff()
    1              0.000001 function! s:ToggleOnDiff()
                                if &diff
                                    call s:IndentLinesDisable()
                                    call s:LeadingSpaceDisable()
                                else
                                    call s:Setup()
                                endif
                            endfunction
                            
                            "{{{1 function! s:IndentLinesEnable()
    1              0.000001 function! s:IndentLinesEnable()
                                if g:indentLine_newVersion
                                    if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
                                        return
                                    endif
                            
                                    if !exists("w:indentLine_indentLineId")
                                        let w:indentLine_indentLineId = []
                                    endif
                            
                                    call s:SetConcealOption()
                            
                                    if g:indentLine_showFirstIndentLevel
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
                                    endif
                            
                                    let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                                    let n = len(g:indentLine_char_list)
                                    let level = 0
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        if n > 0
                                            let char = g:indentLine_char_list[level % n]
                                            let level += 1
                                        else
                                            let char = g:indentLine_char
                                        endif
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': char}))
                                    endfor
                            
                                    return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                            
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif
                            endfunction
                            
                            "{{{1 function! s:IndentLinesDisable()
    1              0.000001 function! s:IndentLinesDisable()
                                if g:indentLine_newVersion
                                    if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
                                        for id in w:indentLine_indentLineId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_indentLineId = []
                                    endif
                            
                                    call s:ResetConcealOption()
                                    return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry
                            endfunction
                            
                            "{{{1 function! s:IndentLinesToggle()
    1              0.000001 function! s:IndentLinesToggle()
                                if g:indentLine_newVersion
                                    if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
                                        let b:indentLine_enabled = 0
                                        call s:IndentLinesDisable()
                                    else
                                        let b:indentLine_enabled = 1
                                        call s:IndentLinesEnable()
                                    endif
                            
                                    return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    call s:IndentLinesDisable()
                                else
                                    call s:IndentLinesEnable()
                                endif
                            endfunction
                            
                            "{{{1 function! s:ResetWidth(...)
    1              0.000001 function! s:ResetWidth(...)
                                if 0 < a:0
                                    noautocmd let &l:shiftwidth = a:1
                                endif
                            
                                let b:indentLine_enabled = 1
                                call s:IndentLinesDisable()
                                call s:IndentLinesEnable()
                            endfunction
                            
                            "{{{1 function! s:AutoResetWidth()
    1              0.000001 function! s:AutoResetWidth()
                            
                                let l:enable = get(
                                                \ b:,
                                                \ 'indentLine_enabled',
                                                \ g:indentLine_enabled ? s:Filter() : 0
                                                \)
                            
                                let g:indentLine_autoResetWidth = get(g:, 'indentLine_autoResetWidth', 1)
                            
                                if l:enable != 1 || g:indentLine_autoResetWidth != 1
                                    return
                                endif
                            
                                let b:indentLine_enabled = l:enable
                                call s:IndentLinesDisable()
                                call s:IndentLinesEnable()
                            endfunction
                            
                            "{{{1 function! s:Filter()
    1              0.000001 function! s:Filter()
                                if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                    return 0
                                endif
                            
                                if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                    return 0
                                endif
                            
                                if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
                                endif
                            
                                for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
                                endfor
                            
                                return 1
                            endfunction
                            
                            "{{{1 function! s:Disable()
    1              0.000001 function! s:Disable()
                                if s:Filter() == 0
                                    call s:IndentLinesDisable()
                                    call s:LeadingSpaceDisable()
                                endif
                            endfunction
                            
                            "{{{1 function! s:Setup()
    1              0.000001 function! s:Setup()
                                if &filetype ==# ""
                                    call s:InitColor()
                                endif
                            
                                if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
                                    call s:IndentLinesEnable()
                                endif
                            
                                if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
                                endif
                            endfunction
                            
                            "{{{1 function! s:LeadingSpaceEnable()
    1              0.000001 function! s:LeadingSpaceEnable()
                                if g:indentLine_newVersion
                                    if exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled == 0
                                        return
                                    endif
                            
                                    if !exists("w:indentLine_leadingSpaceId")
                                        let w:indentLine_leadingSpaceId = []
                                    endif
                            
                                    call s:SetConcealOption()
                            
                                    call add(w:indentLine_leadingSpaceId, matchadd('Conceal', '\%(^\s*\)\@<= ', 0, -1, {'conceal': g:indentLine_leadingSpaceChar}))
                            
                                    if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
                                        call s:ResetWidth()
                                    endif
                            
                                    return
                                endif
                            
                                if g:indentLine_faster
                                    echoerr 'LeadingSpace can not be shown when g:indentLine_faster == 1'
                                    return
                                endif
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                                let b:indentLine_leadingSpaceEnabled = 1
                                call s:SetConcealOption()
                                execute 'syntax match IndentLineLeadingSpace /\%(^\s*\)\@<= / containedin=ALLBUT,IndentLine conceal cchar=' . g:indentLine_leadingSpaceChar
                            endfunction
                            
                            "{{{1 function! s:LeadingSpaceDisable()
    1              0.000001 function! s:LeadingSpaceDisable()
                                if g:indentLine_newVersion
                                    if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
                                    endif
                            
                                    return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry
                            endfunction
                            
                            "{{{1 function! s:LeadingSpaceToggle()
    1              0.000001 function! s:LeadingSpaceToggle()
                                if g:indentLine_newVersion
                                    if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        let b:indentLine_leadingSpaceEnabled = 0
                                        call s:LeadingSpaceDisable()
                                    else
                                        let b:indentLine_leadingSpaceEnabled = 1
                                        call s:LeadingSpaceEnable()
                                    endif
                            
                                    return
                                endif
                            
                                if exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceDisable()
                                else
                                    call s:LeadingSpaceEnable()
                                endif
                            endfunction
                            
                            "{{{1 augroup indentLine
    1              0.000002 augroup indentLine
    1              0.000269     autocmd!
    1              0.000003     if g:indentLine_newVersion
    1              0.000012         autocmd BufRead,BufNewFile,ColorScheme,Syntax * call s:InitColor()
    1              0.000003         if exists("##WinNew")
    1              0.000002             autocmd WinNew * call s:Setup()
    1              0.000001         endif
    1              0.000002         autocmd BufWinEnter * call s:IndentLinesDisable() | call s:LeadingSpaceDisable() | call s:Setup()
    1              0.000002         autocmd FileType * call s:Disable()
    1              0.000001         if exists("##OptionSet")
    1              0.000003             autocmd OptionSet diff call s:ToggleOnDiff()
    1              0.000003             autocmd OptionSet shiftwidth,tabstop noautocmd call s:AutoResetWidth()
    1              0.000000         endif
    1              0.000002         autocmd VimEnter * call s:VimEnter()
                                else
                                    autocmd BufWinEnter * call s:Setup()
                                    autocmd User * if exists("b:indentLine_enabled") || exists("b:indentLine_leadingSpaceEnabled") |
                                                    \ call s:Setup() | endif
                                    autocmd BufRead,BufNewFile,ColorScheme,Syntax * call s:InitColor()
                                    autocmd BufUnload * let b:indentLine_enabled = 0 | let b:indentLine_leadingSpaceEnabled = 0
                                    autocmd SourcePre $VIMRUNTIME/syntax/nosyntax.vim doautocmd indentLine BufUnload
                                    autocmd FileChangedShellPost * doautocmd indentLine BufUnload | call s:Setup()
                                    if exists("##OptionSet")
                                        autocmd OptionSet diff call s:ToggleOnDiff()
                                        autocmd OptionSet shiftwidth,tabstop noautocmd call s:AutoResetWidth()
                                    endif
                                    autocmd VimEnter * call s:VimEnter()
    1              0.000000     endif
    1              0.000001 augroup END
                            
                            "{{{1 commands
    1              0.000006 command! -nargs=? IndentLinesReset call s:ResetWidth(<f-args>)
    1              0.000003 command! IndentLinesToggle call s:IndentLinesToggle()
    1              0.000001 if g:indentLine_newVersion
    1              0.000003     command! -bar IndentLinesEnable let b:indentLine_enabled = 1 | call s:IndentLinesEnable()
    1              0.000004     command! -bar IndentLinesDisable let b:indentLine_enabled = 0 | call s:IndentLinesDisable()
    1              0.000004     command! -bar LeadingSpaceEnable let b:indentLine_leadingSpaceEnabled = 1 | call s:LeadingSpaceEnable()
    1              0.000003     command! -bar LeadingSpaceDisable let b:indentLine_leadingSpaceEnabled = 0 | call s:LeadingSpaceDisable()
                            else
                                command! -bar IndentLinesEnable call s:IndentLinesEnable()
                                command! -bar IndentLinesDisable call s:IndentLinesDisable()
                                command! -bar LeadingSpaceEnable call s:LeadingSpaceEnable()
                                command! -bar LeadingSpaceDisable call s:LeadingSpaceDisable()
    1              0.000000 endif
    1              0.000002 command! LeadingSpaceToggle call s:LeadingSpaceToggle()
                            
                            " vim:et:ts=4:sw=4:fdm=marker:fmr={{{,}}}
                            

SCRIPT  /home/tony/.config/nvim/autoload/plugged/rainbow_parentheses.vim/autoload/rainbow_parentheses.vim
Sourced 1 time
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
                            "==============================================================================
                            "  Description: Rainbow colors for parentheses, based on rainbow_parenthsis.vim
                            "               by Martin Krischik and others.
                            "==============================================================================
                            
    1              0.000005 function! s:uniq(list)
                              let ret = []
                              let map = {}
                              for items in a:list
                                let ok = 1
                                for item in filter(copy(items), '!empty(v:val)')
                                  if has_key(map, item)
                                    let ok = 0
                                  endif
                                  let map[item] = 1
                                endfor
                                if ok
                                  call add(ret, items)
                                endif
                              endfor
                              return ret
                            endfunction
                            
                            " Excerpt from https://github.com/junegunn/vim-journal
                            " http://stackoverflow.com/questions/27159322/rgb-values-of-the-colors-in-the-ansi-extended-colors-index-17-255
    1              0.000012 let s:ansi16 = {
                              \ 0:  '#000000', 1:  '#800000', 2:  '#008000', 3:  '#808000',
                              \ 4:  '#000080', 5:  '#800080', 6:  '#008080', 7:  '#c0c0c0',
                              \ 8:  '#808080', 9:  '#ff0000', 10: '#00ff00', 11: '#ffff00',
                              \ 12: '#0000ff', 13: '#ff00ff', 14: '#00ffff', 15: '#ffffff' }
    1              0.000001 function! s:rgb(color)
                              if a:color[0] == '#'
                                let r = str2nr(a:color[1:2], 16)
                                let g = str2nr(a:color[3:4], 16)
                                let b = str2nr(a:color[5:6], 16)
                                return [r, g, b]
                              endif
                            
                              let ansi = str2nr(a:color)
                            
                              if ansi < 16
                                return s:rgb(s:ansi16[ansi])
                              endif
                            
                              if ansi >= 232
                                let v = (ansi - 232) * 10 + 8
                                return [v, v, v]
                              endif
                            
                              let r = (ansi - 16) / 36
                              let g = ((ansi - 16) % 36) / 6
                              let b = (ansi - 16) % 6
                            
                              return map([r, g, b], 'v:val > 0 ? (55 + v:val * 40) : 0')
                            endfunction
                            
                            " http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
                            " http://alienryderflex.com/hsp.html
    1              0.000001 function! s:brightness_(rgb)
                              let [max, min] = map([max(a:rgb), min(a:rgb)], 'v:val / 255.0')
                              let [r, g, b]  = map(a:rgb, 'v:val / 255.0')
                              if max == min
                                return (max + min) / 2.0
                              endif
                              return sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)
                            endfunction
                            
    1              0.000001 let s:brightness = {}
    1              0.000001 function! s:brightness(color)
                              let color = filter(copy(a:color), '!empty(v:val)')[0]
                              if has_key(s:brightness, color)
                                return s:brightness[color]
                              endif
                              let b = s:brightness_(s:rgb(color))
                              let s:brightness[color] = b
                              return b
                            endfunction
                            
    1              0.000001 function! s:colors_to_hi(colors)
                              return
                                \ join(
                                \   values(
                                \     map(
                                \       filter({ 'ctermfg': a:colors[0], 'guifg': a:colors[1] },
                                \              '!empty(v:val)'),
                                \       'v:key."=".v:val')), ' ')
                            endfunction
                            
    1              0.000001 function! s:extract_fg(line)
                              let cterm = matchstr(a:line, 'ctermfg=\zs\S*\ze')
                              let gui   = matchstr(a:line, 'guifg=\zs\S*\ze')
                              return [cterm, gui]
                            endfunction
                            
    1              0.000001 function! s:blacklist()
                              redir => output
                                silent! hi Normal
                              redir END
                              let line  = split(output, '\n')[0]
                              let cterm = matchstr(line, 'ctermbg=\zs\S*\ze')
                              let gui   = matchstr(line, 'guibg=\zs\S*\ze')
                              let blacklist = {}
                              if !empty(cterm) | let blacklist[cterm] = 1 | endif
                              if !empty(gui)   | let blacklist[gui]   = 1 | endif
                              return [blacklist, s:extract_fg(line)]
                            endfunction
                            
    1              0.000002 let s:colors = { 'light': {}, 'dark': {} }
    1              0.000001 function! s:extract_colors()
                              if exists('g:colors_name') && has_key(s:colors[&background], g:colors_name)
                                return s:colors[&background][g:colors_name]
                              endif
                              redir => output
                                silent hi
                              redir END
                              let lines = filter(split(output, '\n'), 'v:val =~# "fg" && v:val !~? "links" && v:val !~# "bg"')
                              let colors = s:uniq(reverse(map(lines, 's:extract_fg(v:val)')))
                              let [blacklist, fg] = s:blacklist()
                              for c in get(g:, 'rainbow#blacklist', [])
                                let blacklist[c] = 1
                              endfor
                              let colors = filter(colors,
                                    \ '!has_key(blacklist, v:val[0]) && !has_key(blacklist, v:val[1])')
                            
                              if !empty(filter(copy(fg), '!empty(v:val)'))
                                let nb = s:brightness(fg)
                                let [first, second] = [[], []]
                                for cpair in colors
                                  let b = s:brightness(cpair)
                                  let diff = abs(nb - b)
                                  if diff <= 0.25
                                    call add(first, cpair)
                                  elseif diff <= 0.5
                                    call add(second, cpair)
                                  endif
                                endfor
                                let colors = extend(first, second)
                              endif
                            
                              let colors = map(colors, 's:colors_to_hi(v:val)')
                              if exists('g:colors_name')
                                let s:colors[&background][g:colors_name] = colors
                              endif
                              return colors
                            endfunction
                            
    1              0.000001 function! s:show_colors()
                              for level in reverse(range(1, s:max_level))
                                execute 'hi rainbowParensShell'.level
                              endfor
                            endfunction
                            
    1              0.000002 let s:generation = 0
    1              0.000001 function! rainbow_parentheses#activate(...)
                              let force = get(a:000, 0, 0)
                              if exists('#rainbow_parentheses') && get(b:, 'rainbow_enabled', -1) == s:generation && !force
                                return
                              endif
                            
                              let s:generation += 1
                              let s:max_level = get(g:, 'rainbow#max_level', 16)
                              let colors = exists('g:rainbow#colors') ?
                                \ map(copy(g:rainbow#colors[&bg]), 's:colors_to_hi(v:val)') :
                                \ s:extract_colors()
                            
                              for level in range(1, s:max_level)
                                let col = colors[(level - 1) % len(colors)]
                                execute printf('hi rainbowParensShell%d %s', s:max_level - level + 1, col)
                              endfor
                              call s:regions(s:max_level)
                            
                              command! -bang -nargs=? -bar RainbowParenthesesColors call s:show_colors()
                              augroup rainbow_parentheses
                                autocmd!
                                autocmd ColorScheme,Syntax * call rainbow_parentheses#activate(1)
                              augroup END
                              let b:rainbow_enabled = s:generation
                            endfunction
                            
    1              0.000001 function! rainbow_parentheses#deactivate()
                              if exists('#rainbow_parentheses')
                                for level in range(1, s:max_level)
                                  " FIXME How to cope with changes in rainbow#max_level?
                                  silent! execute 'hi clear rainbowParensShell'.level
                                  " FIXME buffer-local
                                  silent! execute 'syntax clear rainbowParens'.level
                                endfor
                                augroup rainbow_parentheses
                                  autocmd!
                                augroup END
                                augroup! rainbow_parentheses
                                delc RainbowParenthesesColors
                              endif
                            endfunction
                            
    1              0.000001 function! rainbow_parentheses#toggle()
                              if exists('#rainbow_parentheses')
                                call rainbow_parentheses#deactivate()
                              else
                                call rainbow_parentheses#activate()
                              endif
                            endfunction
                            
    1              0.000001 function! s:regions(max)
                              let pairs = get(g:, 'rainbow#pairs', [['(',')']])
                              for level in range(1, a:max)
                                let cmd = 'syntax region rainbowParens%d matchgroup=rainbowParensShell%d start=/%s/ end=/%s/ contains=%s'
                                let children = extend(['TOP'], map(range(level, a:max), '"rainbowParens".v:val'))
                                for pair in pairs
                                  let [open, close] = map(copy(pair), 'escape(v:val, "[]/")')
                                  execute printf(cmd, level, level, open, close, join(children, ','))
                                endfor
                              endfor
                            endfunction
                            

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-signature/autoload/signature/sign.vim
Sourced 1 time
Total time:   0.000194
 Self time:   0.000194

count  total (s)   self (s)
                            " vim: fdm=marker:et:ts=4:sw=2:sts=2
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000004 function! signature#sign#Place(sign, lnum)                                                                         "{{{1
                              " Description: Place signs for marks/markers on the specified line number
                              " Arguments:
                              "   sign : The mark/marker whose sign is to be placed
                              "   lnum : Line number on/from which the sign is to be placed/removed
                            
                              "echom "DEBUG: sign = " . a:sign . ",  lnum = " . a:lnum
                            
                              " If Signature is not enabled, return
                              if !b:sig_enabled | return | endif
                            
                              " FIXME: Highly inefficient. Needs work
                              " Place sign only if there are no signs from other plugins (eg. syntastic)
                              "let l:present_signs = s:GetInfo(1)
                              "if (  b:SignatureDeferPlacement
                              " \ && has_key(l:present_signs, a:lnum)
                              " \ && (l:present_signs[a:lnum]['name'] !~# '^sig_Sign_')
                              " \ )
                              "  return
                              "endif
                            
                              if signature#utils#IsValidMarker(a:sign)
                                let b:sig_markers[a:lnum] = a:sign . get(b:sig_markers, a:lnum, "")
                              elseif signature#utils#IsValidMark(a:sign)
                                let b:sig_marks[a:lnum] = a:sign . get(b:sig_marks, a:lnum, "")
                              else
                                echoerr "Unexpected sign found: " . a:sign
                              endif
                              "}}}3
                            
                              call s:RefreshLine(a:lnum)
                            endfunction
                            
                            
    1              0.000001 function! signature#sign#Remove(sign, lnum)                                                                        "{{{1
                              " Description: Remove signs for marks/markers from the specified line number
                              " Arguments:
                              "   sign : The mark/marker whose sign is to be placed/removed/toggled
                              "   lnum : Line number from which the sign is to be removed
                              "          If sign is a marker and lnum is 0, the sign will be removed from all lines
                              "          If sign is a mark   and lnum is 0, the lnum will be found and the sign will be removed from that line
                            
                              "echom "DEBUG: sign = " . a:sign . ",  lnum = " . a:lnum
                            
                              " If Signature is not enabled, return
                              if !b:sig_enabled | return | endif
                            
                              " Remove sign for markers
                              if signature#utils#IsValidMarker(a:sign)
                                let b:sig_markers[a:lnum] = substitute(b:sig_markers[a:lnum], "\\C" . escape( a:sign, '$^' ), "", "")
                            
                                " If there are no markers on the line, delete signs on that line
                                if b:sig_markers[a:lnum] == ""
                                  call remove(b:sig_markers, a:lnum)
                                endif
                                call s:RefreshLine(a:lnum)
                            
                              " Remove sign for marks
                              else
                                " For marks, if a:lnum == 0, find out the line where the mark was placed
                                if a:lnum == 0
                                  let l:arr = keys(filter(copy(b:sig_marks), 'v:val =~# a:sign'))
                                  if empty(l:arr) | return | endif
                                else
                                  let l:arr = [a:lnum]
                                endif
                                if (v:version >= 800)
                                  call assert_true(len(l:arr) == 1, "Multiple marks found where one was expected")
                                elseif (len(l:arr) != 1)
                                  echoerr "Multiple marks found where one was expected"
                                endif
                            
                                for l:lnum in l:arr
                                  " FIXME: Placed guard to avoid triggering issue #53
                                  if has_key(b:sig_marks, l:lnum)
                                    let b:sig_marks[l:lnum] = substitute(b:sig_marks[l:lnum], "\\C" . a:sign, "", "")
                                    " If there are no marks on the line, delete signs on that line
                                    if b:sig_marks[l:lnum] == ""
                                      call remove(b:sig_marks, l:lnum)
                                    endif
                                  endif
                                  call s:RefreshLine(l:lnum)
                                endfor
                              endif
                            endfunction
                            
                            
    1              0.000003 function! s:EvaluateHL(expr, lnum, ...)                                                                            "{{{1
                              " Description: If expr points to a function, call it and use its output as the highlight group.
                              "              If it is a string, use it directly.
                              "              If the optional argument is specified, use it as a fallback. If not, return an empty string
                            
                              if type(a:expr) == type("")
                                return a:expr
                              elseif type(a:expr) == type(function("tr"))
                                let l:retval = a:expr(a:lnum)
                                if (l:retval != "")
                                  return l:retval
                                endif
                              endif
                            
                              return (a:0 > 0 ? a:1 : "")
                            endfunction
                            
                            
    1              0.000002 function! s:RefreshLine(lnum)                                                                                      "{{{1
                              " Description: Decides what the sign string should be based on if there are any marks or markers (using b:sig_marks
                              "              and b:sig_markers) on the current line and the value of b:SignaturePrioritizeMarks.
                              " Arguments:
                              "   lnum : Line number for which the sign string is to be modified
                            
                              let l:id  = abs(a:lnum * 1000 + bufnr('%'))
                              let l:str = ""
                            
                              " Place the sign
                              if ( has_key(b:sig_marks, a:lnum)
                               \ && (  b:SignaturePrioritizeMarks
                               \    || !has_key(b:sig_markers, a:lnum)
                               \    )
                               \ )
                                let l:SignatureMarkTextHL = s:EvaluateHL(g:SignatureMarkTextHL, a:lnum, "SignatureMarkText")
                                let l:SignatureMarkLineHL = s:EvaluateHL(g:SignatureMarkLineHL, a:lnum, "SignatureMarkLine")
                                let l:str = substitute(b:SignatureMarkOrder, "\m", signature#utils#GetChar(b:sig_marks[a:lnum], 0), '')
                                let l:str = substitute(l:str,                "\p", signature#utils#GetChar(b:sig_marks[a:lnum], 1), '')
                            
                                execute 'sign define Signature_' . l:str . ' text=' . l:str . ' texthl=' . l:SignatureMarkTextHL . ' linehl=' . l:SignatureMarkLineHL
                            
                              elseif has_key(b:sig_markers, a:lnum)
                                let l:SignatureMarkerTextHL = s:EvaluateHL(g:SignatureMarkerTextHL, a:lnum, "SignatureMarkerText")
                                let l:SignatureMarkerLineHL = s:EvaluateHL(g:SignatureMarkerLineHL, a:lnum, "SignatureMarkerLine")
                            
                                " Since the same marker can be placed on multiple lines, we can't use the same sign for all of them.
                                " This is because if dynamic highlighting of markers is enabled then the sign placed on eg. a modified line should
                                " be highlighted differently than the one placed on an unchanged line.
                                " In order to support this, I append the name of the TextHL and LineHL group to the name of the sign.
                                let l:txt = signature#utils#GetChar(b:sig_markers[a:lnum], 0)
                                let l:str = l:txt . '_' . l:SignatureMarkerTextHL . '_' . l:SignatureMarkerLineHL
                            
                                execute 'sign define Signature_' . l:str . ' text=' . l:txt . ' texthl=' . l:SignatureMarkerTextHL . ' linehl=' . l:SignatureMarkerLineHL
                              else
                                call signature#sign#Unplace(a:lnum)
                              endif
                            
                              if (l:str != "")
                                execute 'sign place ' . l:id . ' line=' . a:lnum . ' name=Signature_' . l:str . ' buffer=' . bufnr('%')
                              endif
                            
                              " If there is only 1 mark/marker in the file, place a dummy to prevent flickering of the gutter when it is moved
                              " If there are no signs left, remove the dummy
                              call signature#sign#ToggleDummy()
                            endfunction
                            
                            
    1              0.000001 function! signature#sign#Refresh(...)                                                                              "{{{1
                              " Description: Add signs for new marks/markers and remove signs for deleted marks/markers
                              " Arguments:   Specify an argument to force a sign refresh
                            
                              call s:InitializeVars(a:0 && a:1)
                              " If Signature is not enabled, return
                              if !b:sig_enabled | return | endif
                            
                              for i in signature#mark#GetList('free', 'buf_curr')
                                " ... remove it
                                call signature#sign#Remove(i, 0)
                              endfor
                            
                              " Add signs for marks ...
                              for [l:mark, l:lnum, _] in signature#mark#GetList('used', 'buf_curr')
                                " ... if mark is not present in our b:sig_marks list or if it is present but at the wrong line,
                                " remove the old sign and add a new one
                                if (  !has_key(b:sig_marks, l:lnum)
                                 \ || (b:sig_marks[l:lnum] !~# l:mark)
                                 \ || a:0
                                 \ )
                                  call signature#sign#Remove(l:mark, 0)
                                  call signature#sign#Place (l:mark, l:lnum)
                                endif
                              endfor
                            
                              call signature#sign#ToggleDummy()
                            
                              " We do not add signs for markers as SignRefresh is executed periodically and we don't have a way to determine if the
                              " marker already has a sign or not
                            endfunction
                            
                            
    1              0.000001 function! signature#sign#Unplace(lnum)                                                                             "{{{1
                              " Description: Remove the sign from the specified line number
                              " FIXME: Clean-up. Undefine the sign
                              let l:id = abs(a:lnum * 1000 + bufnr('%'))
                              silent! execute 'sign unplace ' . l:id
                            endfunction
                            
                            
    1              0.000003 function! signature#sign#ToggleDummy(...)                                                                          "{{{1
                              " Description: Places a dummy sign to prevent flickering of the gutter when the mark is moved or the line containing
                              "              a mark/marker is deleted and then the delete is undone
                              " Arguments: (optional) 0 : force remove
                              "                       1 : force place
                            
                              let l:place  = a:0 ?  a:1 : (len(b:sig_marks) + len(b:sig_markers) == 1) && !b:sig_DummyExists
                              let l:remove = a:0 ? !a:1 : (len(b:sig_marks) + len(b:sig_markers) == 0) &&  b:sig_DummyExists
                            
                              if (l:place)
                                sign define Signature_Dummy
                                execute 'sign place 666 line=1 name=Signature_Dummy buffer=' . bufnr('%')
                                let b:sig_DummyExists = 1
                              elseif (l:remove)
                                silent! execute 'sign unplace 666 buffer=' . bufnr('%')
                                let b:sig_DummyExists = 0
                              endif
                            endfunction
                            
                            
    1              0.000001 function! s:GetInfo(...)                                                                                           "{{{1
                              " Description: Returns a dic of filenames, each of which is a dic of line numbers on which signs are placed
                              " Arguments: filename (optional).
                              "            If filename is provided, the return value will contain signs only present in the given file
                              " Eg. {
                              "       'vimrc': {
                              "         '711': {
                              "           'id': '1422',
                              "           'name': 'sig_Sign_1422'
                              "         },
                              "         '676': {
                              "           'id': '1352',
                              "           'name': 'sig_Sign_1352'
                              "         }
                              "       }
                              "     }
                            
                              " Redirect the input to a variable
                              redir => l:sign_str
                              silent! sign place
                              redir END
                            
                              " Create a Hash of files to store the info.
                              let l:signs_dic = {}
                              " The file that is currently being processed is stored into l:file
                              let l:match_file = ""
                              let l:file_found = 0
                            
                              " Split the string into an array of sentences and filter out empty lines
                              for i in filter( split( l:sign_str, '\n' ), 'v:val =~ "^[S ]"' )
                                let l:temp_file = matchstr( i, '\v(Signs for )@<=\S+:@=' )
                            
                                if l:temp_file != ""
                                  let l:match_file = l:temp_file
                                  let l:signs_dic[l:match_file] = {}
                                elseif l:match_file != ""
                                  " Get sign info
                                  let l:info_match = matchlist( i, '\vline\=(\d+)\s*id\=(\S+)\s*name\=(\S+)' )
                                  if !empty( l:info_match )
                                    let l:signs_dic[l:match_file][l:info_match[1]] = {
                                          \ 'id'   : l:info_match[2],
                                          \ 'name' : l:info_match[3],
                                          \ }
                                  endif
                                endif
                              endfor
                            
                              if a:0
                                "" Search for the full path first in the hash ...
                                "let l:curr_filepath = expand('%:p')
                                "if has_key( l:signs_dic, l:curr_filepath )
                                "  return filter( l:signs_dic, 'v:key ==# l:curr_filepath' )[l:curr_filepath]
                                "else
                                " ... if no entry is found for the full path, search for the filename in the hash ...
                                " Since we're searching for the current file, if present in the hash, it'll be as a filename and not the full path
                                let l:curr_filename = expand('%:t')
                                if has_key( l:signs_dic, l:curr_filename )
                                  return filter( l:signs_dic, 'v:key ==# l:curr_filename' )[l:curr_filename]
                                endif
                            
                                " ... if nothing is found, then return an empty hash to indicate that no signs are present in the current file
                                return {}
                              endif
                            
                              return l:signs_dic
                            endfunction
                            
                            
    1              0.000001 function! signature#sign#GetGitGutterHLGroup(lnum)                                                                 "{{{1
                              " Description: This returns the highlight group used by vim-gitgutter depending on how the line was edited
                            
                              let l:current_bufnr = bufnr('%')
                              let l:line_state = filter(copy(gitgutter#diff#process_hunks(l:current_bufnr, gitgutter#hunk#hunks(l:current_bufnr))), 'v:val[0] == a:lnum')
                            
                              if len(l:line_state) == 0
                                return ""
                              endif
                            
                              if     (l:line_state[0][1]) =~ 'added'            | return 'GitGutterAdd'
                              elseif (l:line_state[0][1]) =~ 'modified_removed' | return 'GitGutterChangeDelete'
                              elseif (l:line_state[0][1]) =~ 'modified'         | return 'GitGutterChange'
                              elseif (l:line_state[0][1]) =~ 'removed'          | return 'GitGutterDelete'
                              endif
                            endfunction
                            
                            
    1              0.000001 function! signature#sign#GetSignifyHLGroup(lnum)                                                                   "{{{1
                              " Description: This returns the highlight group used by vim-signify depending on how the line was edited
                              "              Thanks to @michaelmior
                            
                              if !exists('b:sy')
                                return ""
                              endif
                              call sy#sign#get_current_signs(b:sy)
                            
                              if has_key(b:sy.internal, a:lnum)
                                let l:line_state = b:sy.internal[a:lnum]['type']
                                if     l:line_state =~ 'SignifyAdd'    | return 'SignifySignAdd'
                                elseif l:line_state =~ 'SignifyChange' | return 'SignifySignChange'
                                elseif l:line_state =~ 'SignifyDelete' | return 'SignifySignDelete'
                                end
                              endif
                            
                              return ""
                            endfunction
                            
                            
                            " function! signature#sign#GetMarkSignLine(mark)                                                                   "{{{1
                            "   if !signature#utils#IsValidMark(a:mark)
                            "     echoe "Signature: Invalid mark " . a:mark
                            "     return
                            "   endif
                            
                            "   let l:sign_info=filter(split(execute('sign place'), '\n'),
                            "                        \ 'v:val =~ "\\vSignature_(.?' . a:mark . '|' . a:mark . '.?)$"')
                            
                            "   if (len(l:sign_info) != 1)
                            "     echoe "Signature: Expected single match, found " . len(l:sign_info)
                            "     return
                            "   endif
                            
                            "   return matchstr(l:sign_info[0], '\v(line\=)@<=\d+')
                            " endfunction
                            
                            
    1              0.000002 function! s:InitializeVars(...)                                                                                    "{{{1
                              " Description: Initialize variables
                              " Arguments:   Specify an argument to re-init
                            
                              if !exists('b:sig_marks')
                                " b:sig_marks = { lnum => signs_str }
                                let b:sig_marks = {}
                              else
                                " Lines can be removed using an external tool. Hence, we need to filter out marks placed on line numbers that are
                                " now greater than the total number of lines in the file.
                                let l:line_tot = line('$')
                                call filter( b:sig_marks, 'v:key <= l:line_tot' )
                              endif
                            
                              if !exists('b:sig_markers')
                                " b:sig_markers = { lnum => marker }
                                let b:sig_markers = {}
                              else
                                " Lines can be removed using an external tool. Hence, we need to filter out marks placed on line numbers that are
                                " now greater than the total number of lines in the file.
                                let l:line_tot = line('$')
                                call filter( b:sig_markers, 'v:key <= l:line_tot' )
                              endif
                            
                              call signature#utils#Set('b:sig_DummyExists'         , 0                          , a:0 && a:1)
                              call signature#utils#Set('b:sig_enabled'             , g:SignatureEnabledAtStartup, a:0 && a:1)
                              call signature#utils#Set('b:SignatureIncludeMarks'   , g:SignatureIncludeMarks    , a:0 && a:1)
                              call signature#utils#Set('b:SignatureIncludeMarkers' , g:SignatureIncludeMarkers  , a:0 && a:1)
                              call signature#utils#Set('b:SignatureMarkOrder'      , g:SignatureMarkOrder       , a:0 && a:1)
                              call signature#utils#Set('b:SignaturePrioritizeMarks', g:SignaturePrioritizeMarks , a:0 && a:1)
                              call signature#utils#Set('b:SignatureDeferPlacement' , g:SignatureDeferPlacement  , a:0 && a:1)
                              call signature#utils#Set('b:SignatureWrapJumps'      , g:SignatureWrapJumps       , a:0 && a:1)
                            endfunction

SCRIPT  /home/tony/.config/nvim/autoload/plugged/vim-signature/autoload/signature/mark.vim
Sourced 1 time
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
                            " vim: fdm=marker:et:ts=4:sw=2:sts=1
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000004 function! signature#mark#Toggle(mark)                                                                             " {{{1
                              " Description: mark = 'next' : Place new mark on current line else toggle specified mark on current line
                              " Arguments:   mark [a-z,A-Z]
                            
                              if a:mark == "next"
                                " Place new mark
                                let l:marks_list = signature#mark#GetList('free', 'buf_all')
                                if empty(l:marks_list)
                                  if (!g:SignatureRecycleMarks)
                                    " No marks available and mark re-use not in effect
                                    call s:ReportNoAvailableMarks()
                                    return
                                  endif
                                  " Remove a local mark
                                  let l:marks_list = signature#mark#GetList('used', 'buf_curr')[0]
                                  call signature#mark#Remove(l:marks_list[0])
                                endif
                                call s:Place(l:marks_list[0])
                            
                              else
                                " Toggle Mark
                                let l:used_marks = filter(signature#mark#GetList('used', 'buf_all'), 'v:val[0] ==# a:mark')
                                if (len(l:used_marks) > 0)
                                  let l:mark_pos = l:used_marks[0][1]
                                  let l:mark_buf = l:used_marks[0][2]
                            
                                  if (l:mark_buf == bufnr('%'))
                                    " If the mark is not in use in current buffer then it's a global ==> Don't worry about deleting it
                                    if (  (l:mark_pos == line('.'))
                                     \ && !g:SignatureForceMarkPlacement
                                     \ )
                                      " Mark is present on the current line. Remove it and return
                                      call signature#mark#Remove(a:mark)
                                      call signature#sign#ToggleDummy()
                                      return
                                    else
                                      " Mark is present elsewhere in the current buffer ==> Remove it and fall-through to place new mark.
                                      " If g:SignatureForceMarkPlacement is set, we remove and re-place it so that the sign string can be true
                                      " to the order in which the marks were placed.
                                      " For eg. if we place 'a, 'b and then 'a again, the sign string changes from "ab" to "ba"
                                      " Ask for confirmation before moving mark
                                      if (g:SignatureDeleteConfirmation)
                                        let choice = confirm("Mark '" . a:mark . "' has been used elsewhere. Reuse it?", "&Yes\n&No", 1)
                                        if choice == 2 | return | endif
                                      endif
                                      call signature#mark#Remove(a:mark)
                                    endif
                                  endif
                                endif
                            
                                " Place new mark
                                call s:Place(a:mark)
                              endif
                            endfunction
                            
                            
    1              0.000001 function! signature#mark#Remove(mark)                                                                             " {{{1
                              " Description: Remove 'mark' and its associated sign. If called without an argument, obtain it from the user
                              " Arguments:   mark = [a-z,A-Z]
                            
                              if !signature#utils#IsValidMark(a:mark)
                                return
                              endif
                            
                              let l:lnum = line("'" . a:mark)
                              call signature#sign#Remove(a:mark, l:lnum)
                              execute 'delmarks ' . a:mark
                              call s:ForceGlobalRemoval(a:mark)
                            endfunction
                            
                            
    1              0.000002 function! s:Place(mark)                                                                                           " {{{1
                              " Description: Place new mark at current cursor position
                              " Arguments:   mark = [a-z,A-Z]
                              " If a line is deleted or mark is manipulated using any non-signature method then b:sig_marks can go out of sync
                              " Thus, we forcibly remove signs for the mark present on any line before proceeding
                              call signature#sign#Remove(a:mark, 0)
                              execute 'normal! m' . a:mark
                              call signature#sign#Place(a:mark, line('.'))
                            endfunction
                            
                            
    1              0.000001 function! signature#mark#ToggleAtLine()                                                                           " {{{1
                              " Description: If no mark on current line, add one. If marks are on the current line, remove one.
                              let l:marks_here = filter(signature#mark#GetList('used', 'buf_curr'), 'v:val[1] == ' . line('.'))
                              if empty(l:marks_here)
                                " Set up for adding a mark
                                call signature#mark#Toggle('next')
                              else
                                " Delete first mark
                                call signature#mark#Remove(l:marks_here[0][0])
                              endif
                            endfunction
                            
                            
    1              0.000002 function! signature#mark#Purge(mode)                                                                              " {{{1
                              " Description: Delete all marks from current line
                              " Arguments:   mode = 'line' : Delete all marks from current line
                              "                     'all'  : Delete all marks used in the buffer
                            
                              let l:used_marks = signature#mark#GetList('used', 'buf_curr')
                              if (a:mode ==? 'line')
                                call filter(l:used_marks, 'v:val[1] == ' . line('.'))
                              endif
                            
                              if (  !empty(l:used_marks)
                               \ && g:SignaturePurgeConfirmation
                               \ )
                                let l:msg = 'Are you sure you want to delete all marks' . (a:mode ==? 'line' ? ' from the current line' : '') . '?'
                                let l:ans = confirm(l:msg . ' This cannot be undone.', "&Yes\n&No", 1)
                                if (l:ans != 1) | return | endif
                              endif
                            
                              for i in l:used_marks
                                call signature#mark#Remove(i[0])
                              endfor
                            
                              " If marks are modified using any non-signature method, b:sig_marks can go out of sync
                              if (a:mode ==? 'all')
                                for l:lnum in keys(b:sig_marks)
                                  call signature#sign#Unplace(l:lnum)
                                endfor
                              endif
                              call signature#sign#ToggleDummy()
                            endfunction
                            
                            
    1              0.000001 function! signature#mark#Goto(dir, loc, mode)                                                                     " {{{1
                              " Arguments:
                              "   dir   = next   : Jump forward
                              "           prev   : Jump backward
                              "   loc   = line   : Jump to first column of line with mark
                              "           spot   : Jump to exact column of the mark
                              "   mode  = pos    : Jump to next mark by position
                              "           alpha  : Jump to next mark by alphabetical order
                              "           global : Jump only to global marks (applies to all buffers and alphabetical order)
                            
                              let l:mark = ""
                              let l:dir  = a:dir
                            
                              if a:mode ==? "global"
                                let l:mark = s:GotoByAlphaGlobal(a:dir)
                              elseif a:mode ==? "alpha"
                                let l:mark = s:GotoByAlpha(a:dir)
                              elseif a:mode ==? "pos"
                                let l:mark = s:GotoByPos(a:dir)
                              endif
                            
                              " NOTE: If l:mark is an empty string then no movement will be made
                              if l:mark == "" | return | endif
                            
                              if a:loc ==? "line"
                                execute "normal! '" . l:mark
                              elseif a:loc ==? "spot"
                                execute 'normal! `' . l:mark
                              endif
                            endfunction
                            
                            
    1              0.000001 function! s:GotoByPos(dir)                                                                                        " {{{1
                              " Description: Jump to next/prev mark by location.
                              " Arguments: dir  = next   : Jump forward
                              "                   prev   : Jump backward
                            
                              " We need at least one mark to be present. If not, then return an empty string so that no movement will be made
                              if empty(b:sig_marks) | return "" | endif
                            
                              let l:lnum = line('.')
                            
                              " Get list of line numbers of lines with marks.
                              if a:dir ==? "next"
                                let l:targ = min(sort(keys(b:sig_marks), "signature#utils#NumericSort"))
                                let l:mark_lnums = sort(keys(filter(copy(b:sig_marks), 'v:key > l:lnum')), "signature#utils#NumericSort")
                              elseif a:dir ==? "prev"
                                let l:targ = max(sort(keys(b:sig_marks), "signature#utils#NumericSort"))
                                let l:mark_lnums = reverse(sort(keys(filter(copy(b:sig_marks), 'v:key < l:lnum')), "signature#utils#NumericSort"))
                              endif
                            
                              let l:targ = (empty(l:mark_lnums) ? (b:SignatureWrapJumps ? l:targ : "") : l:mark_lnums[0])
                              if empty(l:targ) | return "" | endif
                            
                              let l:mark = signature#utils#GetChar(b:sig_marks[l:targ], 0)
                              return l:mark
                            endfunction
                            
                            
    1              0.000001 function! s:GotoByAlpha(dir)                                                                                      " {{{1
                              " Description: Jump to next/prev mark by alphabetical order. Direction specified as input argument
                            
                              let l:used_marks = signature#mark#GetList('used', 'buf_curr')
                              let l:line_marks = filter(copy(l:used_marks), 'v:val[1] == ' . line('.'))
                            
                              " If there is only one mark in the current file, then return the same
                              if (len(l:used_marks) == 1)
                                return l:used_marks[0][0]
                              endif
                            
                              " Since we can place multiple marks on a line, to jump by alphabetical order we need to know what the current mark is.
                              " This information is kept in the b:sig_GotoByAlpha_CurrMark variable. For instance, if we have marks a, b and c
                              " on the current line and b:sig_GotoByAlpha_CurrMark has the value 'a' then we jump to 'b' and set the value of
                              " the variable to 'b'. Reinvoking this function will thus now jump to 'c'
                              if empty(l:line_marks)
                                if exists('b:sig_GotoByAlpha_CurrMark')
                                  unlet b:sig_GotoByAlpha_CurrMark
                                endif
                                " If there are no marks present on the current line then call GotoByPos to jump to the next line with a mark
                                return s:GotoByPos(a:dir)
                              endif
                            
                              if (( len(l:line_marks) == 1 ) || !exists('b:sig_GotoByAlpha_CurrMark') || (b:sig_GotoByAlpha_CurrMark ==? ""))
                                let b:sig_GotoByAlpha_CurrMark = l:line_marks[0][0]
                              endif
                            
                              for i in range( 0, len(l:used_marks) - 1 )
                                if l:used_marks[i][0] ==# b:sig_GotoByAlpha_CurrMark
                                  if a:dir ==? "next"
                                    if (( i != len(l:used_marks)-1 ) || b:SignatureWrapJumps)
                                      let b:sig_GotoByAlpha_CurrMark = l:used_marks[(i+1)%len(l:used_marks)][0]
                                    endif
                                  elseif a:dir ==? "prev"
                                    if ((i != 0) || b:SignatureWrapJumps)
                                      let b:sig_GotoByAlpha_CurrMark = l:used_marks[i-1][0]
                                    endif
                                  endif
                                  return b:sig_GotoByAlpha_CurrMark
                                endif
                              endfor
                            endfunction
                            
                            
    1              0.000001 function! s:GotoByAlphaGlobal(dir)                                                                                " {{{1
                              " Description: Jump to next/prev Global mark in any buffer by alphabetical order.
                              "              Direction is specified as input argument
                            
                              let l:used_marks = signature#mark#GetList('used', 'buf_all', 'global')
                              let l:line_marks = filter(copy(l:used_marks), 'v:val[1] == ' . line('.'))
                            
                              " If there is only one mark in the current file, return it
                              if (len(l:used_marks) == 1)
                                return l:used_marks[0][0]
                              endif
                              " If current line does not have a global mark on it then return the first used global mark
                              if empty(l:line_marks)
                                if exists('b:sig_GotoByAlphaGlobal_CurrMark')
                                  unlet b:sig_GotoByAlphaGlobal_CurrMark
                                endif
                                return l:used_marks[0][0]
                              endif
                            
                              " Since we can place multiple marks on a line, to jump by alphabetical order we need to know what the current mark is.
                              " This information is kept in the b:sig_GotoByAlphaGlobal_CurrMark variable. For instance, if we have marks A, B & C
                              " on the current line and b:sig_GotoByAlphaGlobal_CurrMark has the value 'A' then we jump to 'B' and set the value of
                              " the variable to 'B'. Reinvoking this function will thus now jump to 'C'
                              if (  (len(l:line_marks) == 1)
                               \ || !exists('b:sig_GotoByAlpha_CurrMark')
                               \ || (b:sig_GotoByAlphaGlobal_CurrMark ==? "")
                               \ )
                                let b:sig_GotoByAlphaGlobal_CurrMark = l:line_marks[0][0]
                              endif
                            
                              for i in range( 0, len(l:used_marks) - 1 )
                                if l:used_marks[i][0] ==# b:sig_GotoByAlphaGlobal_CurrMark
                                  if a:dir ==? "next"
                                    if (( i != len(l:used_marks)-1 ) || b:SignatureWrapJumps)
                                      let b:sig_GotoByAlphaGlobal_CurrMark = l:used_marks[(i+1)%len(l:used_marks)][0]
                                    endif
                                  elseif a:dir ==? "prev"
                                    if ((i != 0) || b:SignatureWrapJumps)
                                      let b:sig_GotoByAlphaGlobal_CurrMark = l:used_marks[i-1][0]
                                    endif
                                  endif
                                  return b:sig_GotoByAlphaGlobal_CurrMark
                                endif
                              endfor
                            endfunction
                            
                            
    1              0.000001 function! signature#mark#GetList(mode, scope, ...)                                                                " {{{1
                              " Arguments: mode    = 'used'     : Returns list of [ [used marks, line no., buf no.] ]
                              "                      'free'     : Returns list of [ free marks ]
                              "            scope   = 'buf_curr' : Limits scope to current buffer i.e used/free marks in current buffer
                              "                      'buf_all'  : Set scope to all buffers i.e used/free marks from all buffers
                              "            [type]  = 'global'   : Return only global marks
                            
                              let l:marks_list = []
                              let l:line_tot = line('$')
                              let l:buf_curr = bufnr('%')
                              let l:type     = (a:0 ? a:1 : "")
                            
                              " Respect order specified in g:SignatureIncludeMarks
                              for i in split(b:SignatureIncludeMarks, '\zs')
                                if (i =~# "[A-Z]")
                                  let [ l:buf, l:line, l:col, l:off ] = getpos( "'" . i )
                                  let l:marks_list = add(l:marks_list, [i, l:line, l:buf])
                                elseif (l:type !=? "global")
                                  let l:marks_list = add(l:marks_list, [i, line("'" .i), l:buf_curr])
                                endif
                              endfor
                            
                              if (a:mode ==? 'used')
                                if (a:scope ==? 'buf_curr')
                                  call filter( l:marks_list, '(v:val[2] == l:buf_curr) && (v:val[1] > 0)' )
                                else
                                  call filter( l:marks_list, 'v:val[1] > 0' )
                                endif
                              else
                                if (a:scope ==? 'buf_all')
                                  call filter( l:marks_list, 'v:val[1] == 0' )
                                else
                                  call filter( l:marks_list, '(v:val[1] == 0) || (v:val[2] != l:buf_curr)' )
                                endif
                                call map( l:marks_list, 'v:val[0]' )
                              endif
                            
                              return l:marks_list
                            endfunction
                            
                            
    1              0.000002 function! s:ForceGlobalRemoval(mark)                                                                              " {{{1
                              " Description: Edit viminfo/shada file to forcibly delete Global mark since vim's handling is iffy
                              " Arguments:   mark - The mark to delete
                            
                              if (  (a:mark !~# '[A-Z]')
                               \ || !g:SignatureForceRemoveGlobal
                               \ )
                                return
                              endif
                            
                              if has('nvim')
                                wshada!
                              else
                                wviminfo!
                              endif
                            endfunction
                            
                            
    1              0.000001 function! s:ReportNoAvailableMarks()                                                                              " {{{1
                              if g:SignatureErrorIfNoAvailableMarks
                                echoe "Signature: No free marks left."
                              else
                                echohl WarningMsg
                                echomsg "Signature: No free marks left."
                                echohl None
                              endif
                            endfunction
                            
                            
    1              0.000001 function! signature#mark#List(scope, ...)                                                                         " {{{1
                              " Description: Opens and populates location list with marks
                              " Arguments:   scope     = 0 : List local and global marks from current buffer
                              "                          1 : List only global marks from all buffers
                              "              [context] = 0 : Adds context around the mark
                            
                              let l:list = []
                              let l:buf_curr = bufnr('%')
                              let l:list_sep = {'bufnr': '', 'lnum' : ''}
                            
                              let l:SignatureIncludeMarks = (a:scope == 0 ? b:SignatureIncludeMarks : g:SignatureIncludeMarks)
                              for i in split(l:SignatureIncludeMarks, '\zs')
                                let [l:bufnr, l:lnum, l:col, l:off] = getpos( "'" . i )
                            
                                " Local marks set the buffer no. to 0, replace it with the actual buffer number
                                let l:bufnr = (l:bufnr == 0 ? l:buf_curr : l:bufnr)
                            
                                " Check that
                                "   1. Mark is set (lnum > 0)
                                "   2. If buf_all = 0, filter out global marks from other buffers
                                "   3. If buf_all = 1, filter out local marks from current buffer
                                if (  (l:lnum == 0)
                                 \ || (  (a:scope == 0)
                                 \    && (l:bufnr != l:buf_curr)
                                 \    )
                                 \ || (  (a:scope == 1)
                                 \    && (i       =~# "[a-z]")
                                 \    )
                                 \ )
                                  "echom 'DEBUG: Skipping mark ' . i
                                  continue
                                endif
                            
                                " If the buffer is not loaded, what's the point of showing empty context?
                                let l:context = (bufloaded(l:bufnr) && a:0 ? a:1 : 0)
                            
                                for context_lnum in range(l:lnum - l:context, l:lnum + l:context)
                                  let l:text = get(getbufline(l:bufnr, context_lnum), 0, "")
                                  if (!bufloaded(l:bufnr))
                                    " Buffer is not loaded, hence we won't be able to get the line. Opening the file should fix it
                                    let l:text = "~~~ File is not loaded into memory. Open file and rerun to see the line ~~~"
                                  elseif (l:text == "")
                                    " Line does not exist. Possibly because context_lnum > total no. of lines
                                    "echom 'DEBUG: Skipping line=' . context_lnum . ' for mark=' . i . " because line doesn't exist in buffer=" . l:bufnr
                                    continue
                                  endif
                            
                                  if     (context_lnum < l:lnum) | let l:text = '-: ' . l:text
                                  elseif (context_lnum > l:lnum) | let l:text = '+: ' . l:text
                                  else                           | let l:text = i . ': ' . l:text
                                  endif
                            
                                  let l:list = add(l:list,
                                    \              { 'text' : l:text,
                                    \                'bufnr': l:bufnr,
                                    \                'lnum' : context_lnum,
                                    \                'col'  : l:col,
                                    \                'type' : 'm'
                                    \              }
                                    \             )
                                endfor
                            
                                " Add separator when showing context
                                "if (a:context > 0)
                                "  let l:list = add(l:list, l:list_sep)
                                "endif
                              endfor
                            
                              " Remove the redundant separator at the end when showing context
                              "if (  (a:context > 0)
                              " \ && (len(l:list) > 0)
                              " \ )
                              "  call remove(l:list, -1)
                              "endif
                            
                              call setloclist(0, l:list) | lopen
                            endfunction

FUNCTION  <SNR>5_plug_expand()
    Defined: ~/.config/nvim/autoload/plug.vim:231
Called 1 time
Total time:   0.000041
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000040   0.000005   return s:plug_call('expand', a:fmt, 1)

FUNCTION  <SNR>5_rtp()
    Defined: ~/.config/nvim/autoload/plug.vim:475
Called 37 times
Total time:   0.000387
 Self time:   0.000123

count  total (s)   self (s)
   37   0.000382   0.000119   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))

FUNCTION  <SNR>107_LoadRemotePlugins()
    Defined: /usr/share/nvim/runtime/plugin/rplugin.vim:56
Called 1 time
Total time:   0.000206
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000177   0.000007   let g:loaded_remote_plugins = s:GetManifest()
    1              0.000026   if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
    1              0.000000   endif

FUNCTION  <SNR>65_AddAnsiGroups()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/plugin/coc.vim:187
Called 1 time
Total time:   0.001306
 Self time:   0.001306

count  total (s)   self (s)
    1              0.000002   let color_map = {}
    1              0.000002   let colors = ['#282828', '#cc241d', '#98971a', '#d79921', '#458588', '#b16286', '#689d6a', '#a89984', '#928374']
    1              0.000002   let names = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white', 'grey']
   10              0.000008   for i in range(0, len(names) - 1)
    9              0.000008     let name = names[i]
    9              0.000009     if exists('g:terminal_ansi_colors')
                                  let color_map[name] = s:get_color(get(g:terminal_ansi_colors, i, colors[i]), colors[i])
    9              0.000002     else
    9              0.000020       let color_map[name] = get(g:, 'terminal_color_'.i, colors[i])
    9              0.000002     endif
   10              0.000003   endfor
    1              0.000001   try
   10              0.000012     for name in keys(color_map)
    9              0.000026       let foreground = toupper(name[0]).name[1:]
    9              0.000011       let foregroundColor = color_map[name]
   90              0.000081       for key in keys(color_map)
   81              0.000209         let background = toupper(key[0]).key[1:]
   81              0.000099         let backgroundColor = color_map[key]
   81              0.000543         exe 'hi default CocList'.foreground.background.' guifg='.foregroundColor.' guibg='.backgroundColor
   90              0.000052       endfor
    9              0.000051       exe 'hi default CocListFg'.foreground. ' guifg='.foregroundColor. ' ctermfg='.foreground
    9              0.000063       exe 'hi default CocListBg'.foreground. ' guibg='.foregroundColor. ' ctermbg='.foreground
   10              0.000006     endfor
                              catch /.*/
                                " ignore invalid color
    1              0.000001   endtry

FUNCTION  signature#utils#IsValidMarker()
    Defined: ~/.config/nvim/autoload/plugged/vim-signature/autoload/signature/utils.vim:183
Called 52 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
   52              0.000091   return (  (b:SignatureIncludeMarkers =~# a:marker) && (a:marker != ' ') )

FUNCTION  signature#sign#ToggleDummy()
    Defined: ~/.config/nvim/autoload/plugged/vim-signature/autoload/signature/sign.vim:198
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
                              " Description: Places a dummy sign to prevent flickering of the gutter when the mark is moved or the line containing
                              "              a mark/marker is deleted and then the delete is undone
                              " Arguments: (optional) 0 : force remove
                              "                       1 : force place
                            
    1              0.000004   let l:place  = a:0 ?  a:1 : (len(b:sig_marks) + len(b:sig_markers) == 1) && !b:sig_DummyExists
    1              0.000003   let l:remove = a:0 ? !a:1 : (len(b:sig_marks) + len(b:sig_markers) == 0) &&  b:sig_DummyExists
                            
    1              0.000001   if (l:place)
                                sign define Signature_Dummy
                                execute 'sign place 666 line=1 name=Signature_Dummy buffer=' . bufnr('%')
                                let b:sig_DummyExists = 1
    1              0.000001   elseif (l:remove)
                                silent! execute 'sign unplace 666 buffer=' . bufnr('%')
                                let b:sig_DummyExists = 0
    1              0.000000   endif

FUNCTION  <SNR>5_is_local_plug()
    Defined: ~/.config/nvim/autoload/plug.vim:526
Called 38 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   38              0.000075     return a:repo[0] =~ '[/$~]'

FUNCTION  <SNR>5_loaded_names()
    Defined: ~/.config/nvim/autoload/plug.vim:435
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000031   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')

FUNCTION  <SNR>7_process_rtp()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:3580
Called 1 time
Total time:   0.000835
 Self time:   0.000835

count  total (s)   self (s)
                              " Remove vim-polyglot from paths and make everything absolute
    1              0.000002   let rtp = []
   51              0.000027   for path in a:rtp[1:-2]
   50              0.000489     let abspath = resolve(path)
   50              0.000050     if stridx(abspath, s:base) != 0
   48              0.000041       call add(rtp, abspath)
   50              0.000012     endif
   51              0.000012   endfor
    1              0.000002   let result = [a:rtp[0]]
                              " Then all other stuff (until vimruntime)
    1              0.000001   let i = 0
   40              0.000018   for path in rtp[0:len(rtp)-1]
   40              0.000022     if path == s:runtime
    1              0.000000       break
   39              0.000007     endif
   39              0.000032     call add(result, path)
   39              0.000020     let i = i + 1
   40              0.000010   endfor
                              " Then vim-polyglot
    1              0.000001   call add(result, s:base)
                              " Then all other files, until after-files
    3              0.000003   while i < len(rtp)
    3              0.000003     let path = rtp[i]
    3              0.000017     if match(path, '[/\\]after$') > -1
    1              0.000000       break
    2              0.000000     endif
    2              0.000002     call add(result, path)
    2              0.000001     let i = i + 1
    3              0.000001   endwhile
                              " Then vim-polyglot after path
    1              0.000002   call add(result, s:base . '/after')
                              " Then all other after paths
    8              0.000005   while i < len(rtp)
    7              0.000004     let path = rtp[i]
    7              0.000006     call add(result, path)
    7              0.000003     let i = i + 1
    8              0.000002   endwhile
                              " User's after directory is always last
    1              0.000002   call add(result, a:rtp[len(a:rtp)-1])
    1              0.000001   return result

FUNCTION  <SNR>119_InitializeVars()
    Defined: ~/.config/nvim/autoload/plugged/vim-signature/autoload/signature/sign.vim:343
Called 1 time
Total time:   0.000116
 Self time:   0.000052

count  total (s)   self (s)
                              " Description: Initialize variables
                              " Arguments:   Specify an argument to re-init
                            
    1              0.000003   if !exists('b:sig_marks')
                                " b:sig_marks = { lnum => signs_str }
    1              0.000003     let b:sig_marks = {}
                              else
                                " Lines can be removed using an external tool. Hence, we need to filter out marks placed on line numbers that are
                                " now greater than the total number of lines in the file.
                                let l:line_tot = line('$')
                                call filter( b:sig_marks, 'v:key <= l:line_tot' )
    1              0.000000   endif
                            
    1              0.000001   if !exists('b:sig_markers')
                                " b:sig_markers = { lnum => marker }
    1              0.000001     let b:sig_markers = {}
                              else
                                " Lines can be removed using an external tool. Hence, we need to filter out marks placed on line numbers that are
                                " now greater than the total number of lines in the file.
                                let l:line_tot = line('$')
                                call filter( b:sig_markers, 'v:key <= l:line_tot' )
    1              0.000000   endif
                            
    1   0.000018   0.000006   call signature#utils#Set('b:sig_DummyExists'         , 0                          , a:0 && a:1)
    1   0.000013   0.000005   call signature#utils#Set('b:sig_enabled'             , g:SignatureEnabledAtStartup, a:0 && a:1)
    1   0.000015   0.000006   call signature#utils#Set('b:SignatureIncludeMarks'   , g:SignatureIncludeMarks    , a:0 && a:1)
    1   0.000011   0.000004   call signature#utils#Set('b:SignatureIncludeMarkers' , g:SignatureIncludeMarkers  , a:0 && a:1)
    1   0.000010   0.000004   call signature#utils#Set('b:SignatureMarkOrder'      , g:SignatureMarkOrder       , a:0 && a:1)
    1   0.000011   0.000004   call signature#utils#Set('b:SignaturePrioritizeMarks', g:SignaturePrioritizeMarks , a:0 && a:1)
    1   0.000010   0.000003   call signature#utils#Set('b:SignatureDeferPlacement' , g:SignatureDeferPlacement  , a:0 && a:1)
    1   0.000010   0.000004   call signature#utils#Set('b:SignatureWrapJumps'      , g:SignatureWrapJumps       , a:0 && a:1)

FUNCTION  <SNR>87_match()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:145
Called 1 time
Total time:   0.000065
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000001   if a:pattern[0] == '='
                                return s:is(a:dir, a:pattern[1:])
    1              0.000001   elseif a:pattern[0] == '^'
                                return s:sub(a:dir, a:pattern[1:])
    1              0.000001   elseif a:pattern[0] == '>'
                                return s:child(a:dir, a:pattern[1:])
    1              0.000000   else
    1   0.000058   0.000004     return s:has(a:dir, a:pattern)
                              endif

FUNCTION  <SNR>117_InitColor()
    Defined: ~/.config/nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:35
Called 1 time
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000001     if !g:indentLine_setColors
                                    return
    1              0.000000     endif
                            
    1              0.000001     let default_term_bg = "NONE"
    1              0.000001     let default_gui_bg  = "NONE"
    1              0.000001     if &background ==# "light"
                                    let default_term_fg = 249
                                    let default_gui_fg = "Grey70"
    1              0.000000     else
    1              0.000001         let default_term_fg = 239
    1              0.000001         let default_gui_fg = "Grey30"
    1              0.000000     endif
                            
    1              0.000001     if g:indentLine_defaultGroup != ""
                                    let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
                                    let default_term_fg = synIDattr(default_id, "fg", "cterm") == "" ? default_term_fg :  synIDattr(default_id, "fg", "cterm")
                                    let default_term_bg = synIDattr(default_id, "bg", "cterm") == "" ? default_term_bg :  synIDattr(default_id, "bg", "cterm")
                                    let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
                                    let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
    1              0.000000     endif
                            
    1              0.000002     if !exists("g:indentLine_color_term")
    1              0.000001         let term_color = default_term_fg
                                else
                                    let term_color = g:indentLine_color_term
    1              0.000000     endif
                            
    1              0.000001     if !exists("g:indentLine_bgcolor_term")
    1              0.000001         let term_bgcolor = default_term_bg
                                else
                                    let term_bgcolor = g:indentLine_bgcolor_term
    1              0.000000     endif
                            
    1              0.000001     if !exists("g:indentLine_color_gui")
    1              0.000001         let gui_color = default_gui_fg
                                else
                                    let gui_color = g:indentLine_color_gui
    1              0.000000     endif
                            
    1              0.000001     if !exists("g:indentLine_bgcolor_gui")
    1              0.000001         let gui_bgcolor = default_gui_bg
                                else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
    1              0.000000     endif
                            
    1              0.000014     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
    1              0.000008     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
    1              0.000001     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
    1              0.000000     endif

FUNCTION  <SNR>72_InitVariable()
    Defined: ~/.config/nvim/autoload/plugged/nerdcommenter/plugin/nerdcommenter.vim:21
Called 19 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
   19              0.000021     if !exists(a:var)
   19              0.000051         execute 'let ' . a:var . ' = ' . string(a:value)
   19              0.000005     endif

FUNCTION  <SNR>35_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:26
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000001   syn clear
    1              0.000001   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000000   endif
                            
    1              0.000002   let s = expand("<amatch>")
    1              0.000001   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000000   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
                                for name in split(s, '\.')
                                  if !empty(name)
                                    exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
                                    exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
                                  endif
                                endfor
    1              0.000000   endif

FUNCTION  <SNR>5_plug_call()
    Defined: ~/.config/nvim/autoload/plug.vim:218
Called 41 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
   41              0.000180     return call(a:fn, a:000)

FUNCTION  <SNR>107_GetManifest()
    Defined: /usr/share/nvim/runtime/plugin/rplugin.vim:42
Called 1 time
Total time:   0.000170
 Self time:   0.000091

count  total (s)   self (s)
    1   0.000044   0.000005   let manifest = s:GetManifestPath()
    1              0.000031   if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
    2   0.000054   0.000014     for old_manifest in s:GetOldManifestPaths()
    1              0.000031       if filereadable(old_manifest)
                                    call rename(old_manifest, manifest)
                                    break
    1              0.000000       endif
    2              0.000001     endfor
    1              0.000000   endif
    1              0.000001   return manifest

FUNCTION  <SNR>117_IndentLinesEnable()
    Defined: ~/.config/nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:148
Called 1 time
Total time:   0.000207
 Self time:   0.000189

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000002         if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
                                        return
    1              0.000000         endif
                            
    1              0.000001         if !exists("w:indentLine_indentLineId")
    1              0.000001             let w:indentLine_indentLineId = []
    1              0.000000         endif
                            
    1   0.000022   0.000004         call s:SetConcealOption()
                            
    1              0.000001         if g:indentLine_showFirstIndentLevel
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
    1              0.000000         endif
                            
    1              0.000002         let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
    1              0.000001         let n = len(g:indentLine_char_list)
    1              0.000001         let level = 0
   21              0.000013         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
   20              0.000009             if n > 0
                                            let char = g:indentLine_char_list[level % n]
                                            let level += 1
   20              0.000005             else
   20              0.000013                 let char = g:indentLine_char
   20              0.000005             endif
   20              0.000084             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': char}))
   21              0.000007         endfor
                            
    1              0.000000         return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                            
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif

FUNCTION  AutoPairsMap()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:445
Called 12 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
                              " | is special key which separate map command from text
   12              0.000011   let key = a:key
   12              0.000008   if key == '|'
                                let key = '<BAR>'
   12              0.000004   end
   12              0.000029   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
   12              0.000122   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"

FUNCTION  <SNR>87_cd()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:224
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   if a:dir == getcwd() | return | endif
                              execute g:rooter_cd_cmd fnameescape(a:dir)
                              if !g:rooter_silent_chdir | redraw | echo 'cwd: '.a:dir | endif
                              if exists('#User#RooterChDir')
                                execute 'doautocmd' s:nomodeline 'User RooterChDir'
                              endif

FUNCTION  <SNR>117_ResetConcealOption()
    Defined: ~/.config/nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:110
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000002     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
                                    if exists("b:indentLine_original_concealcursor")
                                        let &l:concealcursor = b:indentLine_original_concealcursor
                                    endif
                                    if exists("b:indentLine_original_conceallevel")
                                        let &l:conceallevel = b:indentLine_original_conceallevel
                                    endif
                                    let b:indentLine_ConcealOptionSet = 0
    1              0.000000     endif

FUNCTION  which_key#register()
    Defined: ~/.config/nvim/autoload/plugged/vim-which-key/autoload/which_key.vim:16
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000004   let key = a:prefix ==? '<Space>' ? ' ' : a:prefix
    1              0.000001   let val = a:dict
    1              0.000006   call extend(s:desc, {key:val})

FUNCTION  coc#util#job_command()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/util.vim:127
Called 1 time
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000003   if (has_key(g:, 'coc_node_path'))
                                let node = expand(g:coc_node_path)
    1              0.000001   else
    1              0.000003     let node = $COC_NODE_PATH == '' ? 'node' : $COC_NODE_PATH
    1              0.000000   endif
    1              0.000010   if !executable(node)
                                echohl Error | echom '[coc.nvim] "'.node.'" is not executable, checkout https://nodejs.org/en/download/' | echohl None
                                return
    1              0.000000   endif
    1              0.000037   if !filereadable(s:root.'/build/index.js')
                                if isdirectory(s:root.'/src')
                                  echohl Error | echom '[coc.nvim] build/index.js not found, please install dependencies and compile coc.nvim by: yarn install' | echohl None
                                else
                                  echohl Error | echon '[coc.nvim] your coc.nvim is broken.' | echohl None
                                endif
                                return
    1              0.000000   endif
    1              0.000006   return [node] + get(g:, 'coc_node_args', ['--no-warnings']) + [s:root.'/build/index.js']

FUNCTION  signature#sign#Refresh()
    Defined: ~/.config/nvim/autoload/plugged/vim-signature/autoload/signature/sign.vim:157
Called 1 time
Total time:   0.002826
 Self time:   0.000655

count  total (s)   self (s)
                              " Description: Add signs for new marks/markers and remove signs for deleted marks/markers
                              " Arguments:   Specify an argument to force a sign refresh
                            
    1   0.000124   0.000009   call s:InitializeVars(a:0 && a:1)
                              " If Signature is not enabled, return
    1              0.000002   if !b:sig_enabled | return | endif
                            
   53   0.001076   0.000411   for i in signature#mark#GetList('free', 'buf_curr')
                                " ... remove it
   52   0.001102   0.000178     call signature#sign#Remove(i, 0)
   53              0.000016   endfor
                            
                              " Add signs for marks ...
    1   0.000459   0.000009   for [l:mark, l:lnum, _] in signature#mark#GetList('used', 'buf_curr')
                                " ... if mark is not present in our b:sig_marks list or if it is present but at the wrong line,
                                " remove the old sign and add a new one
                                if (  !has_key(b:sig_marks, l:lnum) || (b:sig_marks[l:lnum] !~# l:mark) || a:0 )
                                  call signature#sign#Remove(l:mark, 0)
                                  call signature#sign#Place (l:mark, l:lnum)
                                endif
    1              0.000001   endfor
                            
    1   0.000025   0.000009   call signature#sign#ToggleDummy()
                            
                              " We do not add signs for markers as SignRefresh is executed periodically and we don't have a way to determine if the
                              " marker already has a sign or not

FUNCTION  <SNR>65_Hi()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/plugin/coc.vim:351
Called 1 time
Total time:   0.001785
 Self time:   0.000479

count  total (s)   self (s)
    1              0.000026   hi default CocErrorSign     ctermfg=Red     guifg=#ff0000 guibg=NONE
    1              0.000006   hi default CocWarningSign   ctermfg=Brown   guifg=#ff922b guibg=NONE
    1              0.000005   hi default CocInfoSign      ctermfg=Yellow  guifg=#fab005 guibg=NONE
    1              0.000004   hi default CocHintSign      ctermfg=Blue    guifg=#15aabf guibg=NONE
    1              0.000003   hi default CocSelectedText  ctermfg=Red     guifg=#fb4934 guibg=NONE
    1              0.000003   hi default CocCodeLens      ctermfg=Gray    guifg=#999999 guibg=NONE
    1              0.000006   hi default CocUnderline     term=underline cterm=underline gui=underline
    1              0.000004   hi default CocBold          term=bold cterm=bold gui=bold
    1              0.000005   hi default CocItalic        term=italic cterm=italic gui=italic
    1              0.000006   if s:is_vim || has('nvim-0.4.0')
    1              0.000019     hi default CocStrikeThrough term=strikethrough cterm=strikethrough gui=strikethrough
                              else
                                hi default CocStrikeThrough guifg=#989898 ctermfg=gray
    1              0.000000   endif
    1              0.000004   hi default CocMarkdownLink  ctermfg=Blue    guifg=#15aabf guibg=NONE
    1              0.000003   hi default CocDisabled guifg=#999999 ctermfg=gray
    1              0.000002   hi default link CocFadeOut             Conceal
    1              0.000002   hi default link CocMarkdownCode        markdownCode
    1              0.000001   hi default link CocMarkdownHeader      markdownH1
    1              0.000001   hi default link CocMenuSel             PmenuSel
    1              0.000001   hi default link CocErrorFloat          CocErrorSign
    1              0.000001   hi default link CocWarningFloat        CocWarningSign
    1              0.000001   hi default link CocInfoFloat           CocInfoSign
    1              0.000001   hi default link CocHintFloat           CocHintSign
    1              0.000001   hi default link CocErrorHighlight      CocUnderline
    1              0.000002   hi default link CocWarningHighlight    CocUnderline
    1              0.000002   hi default link CocInfoHighlight       CocUnderline
    1              0.000001   hi default link CocHintHighlight       CocUnderline
    1              0.000001   hi default link CocDeprecatedHighlight CocStrikeThrough
    1              0.000001   hi default link CocUnusedHighlight     CocFadeOut
    1              0.000001   hi default link CocListMode            ModeMsg
    1              0.000001   hi default link CocListPath            Comment
    1              0.000001   hi default link CocHighlightText       CursorColumn
    1              0.000001   hi default link CocHoverRange          Search
    1              0.000001   hi default link CocCursorRange         Search
    1              0.000001   hi default link CocHighlightRead       CocHighlightText
    1              0.000001   hi default link CocHighlightWrite      CocHighlightText
                              " Tree view highlights
    1              0.000001   hi default link CocTreeTitle       Title
    1              0.000001   hi default link CocTreeDescription Comment
    1              0.000001   hi default link CocTreeOpenClose   CocBold
    1              0.000001   hi default link CocTreeSelected    CursorLine
    1              0.000002   hi default link CocSelectedRange   CocHighlightText
                              " Symbol highlights
    1              0.000001   hi default link CocSymbolDefault       MoreMsg
    1              0.000002   hi default link CocSymbolFile          Statement
    1              0.000001   hi default link CocSymbolModule        Statement
    1              0.000001   hi default link CocSymbolNamespace     Statement
    1              0.000001   hi default link CocSymbolPackage       Statement
    1              0.000045   hi default link CocSymbolClass         Statement
    1              0.000002   hi default link CocSymbolMethod        Function
    1              0.000001   hi default link CocSymbolProperty      Keyword
    1              0.000001   hi default link CocSymbolField         CocSymbolDefault
    1              0.000001   hi default link CocSymbolConstructor   Function
    1              0.000001   hi default link CocSymbolEnum          CocSymbolDefault
    1              0.000001   hi default link CocSymbolInterface     CocSymbolDefault
    1              0.000001   hi default link CocSymbolFunction      Function
    1              0.000001   hi default link CocSymbolVariable      CocSymbolDefault
    1              0.000001   hi default link CocSymbolConstant      Constant
    1              0.000001   hi default link CocSymbolString        String
    1              0.000001   hi default link CocSymbolNumber        Number
    1              0.000001   hi default link CocSymbolBoolean       Boolean
    1              0.000001   hi default link CocSymbolArray         CocSymbolDefault
    1              0.000001   hi default link CocSymbolObject        CocSymbolDefault
    1              0.000001   hi default link CocSymbolKey           Keyword
    1              0.000001   hi default link CocSymbolNull          Type
    1              0.000001   hi default link CocSymbolEnumMember    CocSymbolDefault
    1              0.000001   hi default link CocSymbolStruct        Keyword
    1              0.000001   hi default link CocSymbolEvent         Keyword
    1              0.000001   hi default link CocSymbolOperator      Operator
    1              0.000001   hi default link CocSymbolTypeParameter Operator
                            
    1              0.000005   if has('nvim')
    1              0.000004     hi default link CocFloating NormalFloat
                              else
                                hi default link CocFloating Pmenu
    1              0.000001   endif
    1              0.000008   if !exists('*sign_getdefined') || empty(sign_getdefined('CocCurrentLine'))
    1              0.000004     sign define CocCurrentLine linehl=CocMenuSel
    1              0.000001   endif
    1              0.000004   if !exists('*sign_getdefined') || empty(sign_getdefined('CocTreeSelected'))
    1              0.000002     sign define CocTreeSelected linehl=CocTreeSelected
    1              0.000000   endif
    1              0.000003   if has('nvim-0.5.0')
    1              0.000007     hi default CocCursorTransparent gui=strikethrough blend=100
    1              0.000001   endif
                            
    1              0.000003   if has('nvim')
    1              0.000004     let names = ['Error', 'Warning', 'Info', 'Hint']
    5              0.000005     for name in names
    4              0.000007       if !hlexists('Coc'.name.'VirtualText')
    4              0.000011         exe 'hi default link Coc'.name.'VirtualText Coc'.name.'Sign'
    4              0.000001       endif
    5              0.000002     endfor
    1              0.000000   endif
    1   0.001320   0.000014   call s:AddAnsiGroups()
                            
    1              0.000003   if get(g:, 'coc_default_semantic_highlight_groups', 1)
    1              0.000022     let hlMap = { 'Namespace': ['TSNamespace', 'Include'], 'Type': ['TSType', 'Type'], 'Class': ['TSConstructor', 'Special'], 'Enum': ['TSEnum', 'Type'], 'Interface': ['TSInterface', 'Type'], 'Struct': ['TSStruct', 'Identifier'], 'TypeParameter': ['TSParameter', 'Identifier'], 'Parameter': ['TSParameter', 'Identifier'], 'Variable': ['TSSymbol', 'Identifier'], 'Property': ['TSProperty', 'Identifier'], 'EnumMember': ['TSEnumMember', 'Constant'], 'Event': ['TSEvent', 'Keyword'], 'Function': ['TSFunction', 'Function'], 'Method': ['TSMethod', 'Function'], 'Macro': ['TSConstMacro', 'Define'], 'Keyword': ['TSKeyword', 'Keyword'], 'Modifier': ['TSModifier', 'StorageClass'], 'Comment': ['TSComment', 'Comment'], 'String': ['TSString', 'String'], 'Number': ['TSNumber', 'Number'], 'Boolean': ['TSBoolean', 'Boolean'], 'Regexp': ['TSStringRegex', 'String'], 'Operator': ['TSOperator', 'Operator'], 'Decorator': ['TSSymbol', 'Identifier'], 'Deprecated': ['TSStrike', 'CocDeprecatedHighlight'] }
   26              0.000024     for [key, value] in items(hlMap)
   25              0.000025       let ts = get(value, 0, '')
   25              0.000024       let fallback = get(value, 1, '')
   25              0.000066       execute 'hi default link CocSem'.key.' '.(hlexists(ts) ? ts : fallback)
   26              0.000006     endfor
    1              0.000000   endif

FUNCTION  <SNR>117_Filter()
    Defined: ~/.config/nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:286
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000005     if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                    return 0
    2              0.000001     endif
                            
    2              0.000004     if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                    return 0
    2              0.000001     endif
                            
    2              0.000005     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
    2              0.000000     endif
                            
    2              0.000003     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
    2              0.000001     endfor
                            
    2              0.000001     return 1

FUNCTION  <SNR>65_Enable()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/plugin/coc.vim:269
Called 1 time
Total time:   0.000422
 Self time:   0.000419

count  total (s)   self (s)
    1              0.000003   if get(g:, 'coc_enabled', 0) == 1
                                return
    1              0.000000   endif
    1              0.000002   let g:coc_enabled = 1
                            
    1              0.000003   augroup coc_nvim
    1              0.000267     autocmd!
                            
    1              0.000003     if exists('##MenuPopupChanged') && exists('*nvim_open_win')
                                  autocmd MenuPopupChanged *   call s:Autocmd('MenuPopupChanged', get(v:, 'event', {}), win_screenpos(winnr())[0] + winline() - 2)
    1              0.000000     endif
    1              0.000001     if exists('##CompleteChanged')
    1              0.000008       autocmd CompleteChanged *   call s:Autocmd('MenuPopupChanged', get(v:, 'event', {}), win_screenpos(winnr())[0] + winline() - 2)
    1              0.000000     endif
                            
    1   0.000016   0.000014     if coc#rpc#started()
    1              0.000006       autocmd VimEnter            * call coc#rpc#notify('VimEnter', [])
                                elseif get(g:, 'coc_start_at_startup', 1)
                                  autocmd VimEnter            * call coc#rpc#start_server()
    1              0.000000     endif
    1              0.000001     if s:is_vim
                                  if exists('##DirChanged')
                                    autocmd DirChanged        * call s:Autocmd('DirChanged', getcwd())
                                  endif
                                  if exists('##TerminalOpen')
                                    autocmd TerminalOpen      * call s:Autocmd('TermOpen', +expand('<abuf>'))
                                  endif
    1              0.000000     else
    1              0.000002       autocmd DirChanged        * call s:Autocmd('DirChanged', get(v:event, 'cwd', ''))
    1              0.000002       autocmd TermOpen          * call s:Autocmd('TermOpen', +expand('<abuf>'))
    1              0.000002       autocmd TermClose         * call s:Autocmd('TermClose', +expand('<abuf>'))
    1              0.000002       autocmd CursorMoved       * call coc#float#nvim_refresh_scrollbar(win_getid())
    1              0.000002       autocmd WinEnter          * call coc#float#nvim_win_enter(win_getid())
    1              0.000002       if exists('##WinClosed')
    1              0.000002         autocmd WinClosed       * call coc#float#close_related(+expand('<afile>'))
    1              0.000001         autocmd WinClosed       * call s:Autocmd('WinClosed', +expand('<afile>'))
    1              0.000000       endif
    1              0.000000     endif
    1              0.000004     if has('nvim-0.4.0') || has('patch-8.1.1719')
    1              0.000001       autocmd CursorHold        * call coc#float#check_related()
    1              0.000000     endif
    1              0.000002     autocmd WinLeave            * call s:Autocmd('WinLeave', win_getid())
    1              0.000001     autocmd WinEnter            * call s:Autocmd('WinEnter', win_getid())
    1              0.000002     autocmd BufWinLeave         * call s:Autocmd('BufWinLeave', +expand('<abuf>'), bufwinid(+expand('<abuf>')))
    1              0.000003     autocmd BufWinEnter         * call s:Autocmd('BufWinEnter', +expand('<abuf>'), win_getid())
    1              0.000002     autocmd FileType            * call s:Autocmd('FileType', expand('<amatch>'), +expand('<abuf>'))
    1              0.000001     autocmd CompleteDone        * call s:Autocmd('CompleteDone', get(v:, 'completed_item', {}))
    1              0.000001     autocmd InsertCharPre       * call s:HandleCharInsert(v:char, bufnr('%'))
    1              0.000001     if exists('##TextChangedP')
    1              0.000004       autocmd TextChangedP        * call s:Autocmd('TextChangedP', +expand('<abuf>'), {'lnum': line('.'), 'col': col('.'), 'line': getline('.'), 'changedtick': b:changedtick})
    1              0.000000     endif
    1              0.000002     autocmd TextChangedI        * call s:Autocmd('TextChangedI', +expand('<abuf>'), {'lnum': line('.'), 'col': col('.'), 'pre': strpart(getline('.'), 0, col('.') - 1), 'changedtick': b:changedtick})
    1              0.000002     autocmd InsertLeave         * call s:Autocmd('InsertLeave', +expand('<abuf>'))
    1              0.000001     autocmd InsertEnter         * call s:Autocmd('InsertEnter', +expand('<abuf>'))
    1              0.000001     autocmd BufHidden           * call s:Autocmd('BufHidden', +expand('<abuf>'))
    1              0.000002     autocmd BufEnter            * call s:Autocmd('BufEnter', +expand('<abuf>'))
    1              0.000002     autocmd TextChanged         * call s:Autocmd('TextChanged', +expand('<abuf>'), getbufvar(+expand('<abuf>'), 'changedtick'))
    1              0.000001     autocmd BufWritePost        * call s:Autocmd('BufWritePost', +expand('<abuf>'))
    1              0.000001     autocmd CursorMoved         * call s:Autocmd('CursorMoved', +expand('<abuf>'), [line('.'), col('.')])
    1              0.000001     autocmd CursorMovedI        * call s:Autocmd('CursorMovedI', +expand('<abuf>'), [line('.'), col('.')])
    1              0.000001     autocmd CursorHold          * call s:Autocmd('CursorHold', +expand('<abuf>'))
    1              0.000002     autocmd CursorHoldI         * call s:Autocmd('CursorHoldI', +expand('<abuf>'))
    1              0.000003     autocmd BufNewFile,BufReadPost * call s:Autocmd('BufCreate', +expand('<abuf>'))
    1              0.000001     autocmd BufUnload           * call s:Autocmd('BufUnload', +expand('<abuf>'))
    1              0.000003     autocmd BufWritePre         * call s:SyncAutocmd('BufWritePre', +expand('<abuf>'))
    1              0.000001     autocmd FocusGained         * if mode() !~# '^c' | call s:Autocmd('FocusGained') | endif
    1              0.000002     autocmd FocusLost           * call s:Autocmd('FocusLost')
    1              0.000002     autocmd VimResized          * call s:Autocmd('VimResized', &columns, &lines)
    1              0.000002     autocmd VimLeavePre         * let g:coc_vim_leaving = 1
    1              0.000013     autocmd BufReadCmd,FileReadCmd,SourceCmd list://* call coc#list#setup(expand('<amatch>'))
    1              0.000004     autocmd BufWriteCmd __coc_refactor__* :call coc#rpc#notify('saveRefactor', [+expand('<abuf>')])
    1              0.000003     autocmd ColorScheme * call s:Hi()
    1              0.000001   augroup end
    1              0.000002   if a:initialize == 0
                                 call coc#rpc#request('attach', [])
                                 echohl MoreMsg
                                 echom '[coc.nvim] Event enabled'
                                 echohl None
    1              0.000001   endif

FUNCTION  coc#util#get_config_home()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/util.vim:304
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000002   if !empty(get(g:, 'coc_config_home', ''))
                                  return resolve(expand(g:coc_config_home))
    1              0.000000   endif
    1              0.000002   if exists('$VIMCONFIG')
                                return resolve($VIMCONFIG)
    1              0.000000   endif
    1              0.000002   if has('nvim')
    1              0.000001     if exists('$XDG_CONFIG_HOME')
                                  return resolve($XDG_CONFIG_HOME."/nvim")
    1              0.000000     endif
    1              0.000001     if s:is_win
                                  return resolve($HOME.'/AppData/Local/nvim')
    1              0.000000     endif
    1              0.000007     return resolve($HOME.'/.config/nvim')
                              else
                                if s:is_win
                                  return resolve($HOME."/vimfiles")
                                endif
                                return resolve($HOME.'/.vim')
                              endif

FUNCTION  coc#util#get_data_home()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/util.vim:327
Called 1 time
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000002   if !empty(get(g:, 'coc_data_home', ''))
                                let dir = resolve(expand(g:coc_data_home))
    1              0.000000   else
    1              0.000001     if exists('$XDG_CONFIG_HOME')
                                  let dir = resolve($XDG_CONFIG_HOME."/coc")
    1              0.000000     else
    1              0.000001       if s:is_win
                                    let dir = resolve(expand('~/AppData/Local/coc'))
    1              0.000000       else
    1              0.000027         let dir = resolve(expand('~/.config/coc'))
    1              0.000001       endif
    1              0.000000     endif
    1              0.000000   endif
    1              0.000008   if !isdirectory(dir)
                                echohl MoreMsg | echom '[coc.nvim] creating data directory: '.dir | echohl None
                                call mkdir(dir, "p", 0755)
    1              0.000000   endif
    1              0.000001   return dir

FUNCTION  <SNR>5_define_commands()
    Defined: ~/.config/nvim/autoload/plug.vim:265
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000005   command! -nargs=+ -bar Plug call plug#(<args>)
    1              0.000011   if !executable('git')
                                return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')
    1              0.000000   endif
    1              0.000004   if has('win32') && &shellslash && (&shell =~# 'cmd\(\.exe\)\?$' || s:is_powershell(&shell))
                                return s:err('vim-plug does not support shell, ' . &shell . ', when shellslash is set.')
    1              0.000000   endif
    1              0.000003   if !has('nvim') && (has('win32') || has('win32unix')) && !has('multi_byte')
                                return s:err('Vim needs +multi_byte feature on Windows to run shell commands. Enable +iconv for best results.')
    1              0.000000   endif
    1              0.000005   command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])
    1              0.000003   command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])
    1              0.000002   command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)
    1              0.000003   command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif
    1              0.000001   command! -nargs=0 -bar PlugStatus  call s:status()
    1              0.000001   command! -nargs=0 -bar PlugDiff    call s:diff()
    1              0.000003   command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)

FUNCTION  <SNR>75_Initial()
    Defined: ~/.config/nvim/autoload/plugged/vim-closetag/plugin/closetag.vim:11
Called 1 time
Total time:   0.000146
 Self time:   0.000111

count  total (s)   self (s)
    1   0.000012   0.000006     call s:Declare('g:closetag_filetypes', 'html,xhtml,phtml')
    1   0.000007   0.000004     call s:Declare('g:closetag_xhtml_filetypes', 'xhtml')
                            
    1   0.000006   0.000003     call s:Declare('g:closetag_filenames', '*.html,*.xhtml,*.phtml')
    1   0.000006   0.000003     call s:Declare('g:closetag_xhtml_filenames', '*.xhtml')
                            
    1   0.000007   0.000004     call s:Declare('g:closetag_shortcut', '>')
    1   0.000006   0.000003     call s:Declare('g:closetag_close_shortcut', '')
                            
    1   0.000009   0.000003     call s:Declare('g:closetag_emptyTags_caseSensitive', 0)
                            
    1   0.000016   0.000009     call s:Declare('g:closetag_regions', { 'typescript.tsx': 'jsxRegion,tsxRegion', 'javascript.jsx': 'jsxRegion', 'typescriptreact': 'jsxRegion,tsxRegion', 'javascriptreact': 'jsxRegion', })
                            
    1              0.000008     let g:closetag_filenames = substitute(g:closetag_filenames, '\s*,\s\+', ',', 'g')
    1              0.000003     let g:closetag_xhtml_filenames = substitute(g:closetag_xhtml_filenames, '\s*,\s\+', ',', 'g')
    1              0.000003     let g:closetag_filetypes = substitute(g:closetag_filetypes, '\s*,\s\+', ',', 'g')
    1              0.000003     let g:closetag_xhtml_filetypes = substitute(g:closetag_xhtml_filetypes, '\s*,\s\+', ',', 'g')
                            
    1              0.000001     if g:closetag_shortcut != ''
    1              0.000006         exec "au User vim-closetag inoremap <silent> <buffer> " . g:closetag_shortcut . " ><Esc>:call <SID>CloseIt()<Cr>"
                            
    1              0.000001         if g:closetag_filetypes != ''
    1              0.000007             exec "au FileType " . g:closetag_filetypes . " inoremap <silent> <buffer> " . g:closetag_shortcut . " ><Esc>:call <SID>CloseIt()<Cr>"
    1              0.000000         en
    1              0.000001         if g:closetag_filenames != ''
    1              0.000010             exec "au BufNewFile,Bufread " . g:closetag_filenames . " inoremap <silent> <buffer> " . g:closetag_shortcut . " ><Esc>:call <SID>CloseIt()<Cr>"
    1              0.000000         en
    1              0.000000     en
                            
    1              0.000001     if g:closetag_close_shortcut != ''
                                    if g:closetag_filetypes != ''
                                        exec "au FileType " . g:closetag_filetypes . " inoremap <silent> <buffer> " . g:closetag_close_shortcut . " >"
                                    en
                                    if g:closetag_filenames != ''
                                        exec "au BufNewFile,Bufread " . g:closetag_filenames . " inoremap <silent> <buffer> " . g:closetag_close_shortcut . " >"
                                    en
    1              0.000000     en
                            
    1              0.000001     if g:closetag_xhtml_filetypes != ''
    1              0.000004         exec "au FileType " . g:closetag_xhtml_filetypes . " call <SID>Declare('b:closetag_use_xhtml', 1)"
    1              0.000000     en
    1              0.000001     if g:closetag_xhtml_filenames != ''
    1              0.000005         exec "au BufNewFile,Bufread " . g:closetag_xhtml_filenames . " call <SID>Declare('b:closetag_use_xhtml', 1)"
    1              0.000000     en
                            
    1              0.000003     com! -nargs=* -complete=file CloseTagEnableBuffer let b:closetag_disabled = 0
    1              0.000002     com! -nargs=* -complete=file CloseTagDisableBuffer let b:closetag_disabled = 1
    1              0.000004     com! -nargs=* -complete=file CloseTagToggleBuffer let b:closetag_disabled = exists('b:closetag_disabled') && b:closetag_disabled ? 0 : 1
                            
                                " Script rgular expresion used. Documents those nasty criters
                                " Don't check for quotes around attributes!!!
    1              0.000002     let s:ReqAttrib = '\(\(\s\|\n\)\+\([^>= \t]\+=[^>&]\+\)\(\s\|\n\)*\)\+\(\/\)\@\<!>'
    1              0.000001     let s:EndofName = '\($\|\s\|>\)'

FUNCTION  <SNR>87_rooter()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:68
Called 1 time
Total time:   0.000212
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000067   0.000006   if !s:activate() | return | endif
                            
    1              0.000002   let root = getbufvar('%', 'rootDir')
    1              0.000001   if empty(root)
    1   0.000125   0.000006     let root = s:root()
    1              0.000003     call setbufvar('%', 'rootDir', root)
    1              0.000000   endif
                            
    1              0.000001   if empty(root)
                                call s:rootless()
                                return
    1              0.000000   endif
                            
    1   0.000009   0.000005   call s:cd(root)

FUNCTION  <SNR>87_activate()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:87
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
                              " Directory browser plugins (e.g. vim-dirvish, NERDTree) tend to
                              " set a nofile buftype when you open a directory.
    1              0.000004   if &buftype != '' && &buftype != 'nofile' | return 0 | endif
                            
    1              0.000004   let patterns = split(g:rooter_targets, ',')
    1              0.000039   let fn = expand('%:p', 1)
                            
    1              0.000007   if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
                            
                              " directory
    1              0.000002   if empty(fn) || fn[-1:] == '/'
    1              0.000002     return index(patterns, '/') != -1
                              endif
                            
                              " file
                              if !filereadable(fn) | return 0 | endif
                              if !exists('*glob2regpat') | return 1 | endif
                            
                              for p in filter(copy(patterns), 'v:val != "/"')
                                if fn =~ glob2regpat(p)
                                  return 1
                                endif
                              endfor
                            
                              return 0

FUNCTION  plug#begin()
    Defined: ~/.config/nvim/autoload/plug.vim:239
Called 1 time
Total time:   0.000175
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000002   if a:0 > 0
    1              0.000002     let s:plug_home_org = a:1
    1   0.000092   0.000015     let home = s:path(s:plug_fnamemodify(s:plug_expand(a:1), ':p'))
                              elseif exists('g:plug_home')
                                let home = s:path(g:plug_home)
                              elseif has('nvim')
                                let home = stdpath('data') . '/plugged'
                              elseif !empty(&rtp)
                                let home = s:path(split(&rtp, ',')[0]) . '/plugged'
                              else
                                return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')
    1              0.000000   endif
    1   0.000012   0.000006   if s:plug_fnamemodify(home, ':t') ==# 'plugin' && s:plug_fnamemodify(home, ':h') ==# s:first_rtp
                                return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')
    1              0.000000   endif
                            
    1              0.000001   let g:plug_home = home
    1              0.000001   let g:plugs = {}
    1              0.000001   let g:plugs_order = []
    1              0.000001   let s:triggers = {}
                            
    1   0.000051   0.000005   call s:define_commands()
    1              0.000001   return 1

FUNCTION  <SNR>5_infer_properties()
    Defined: ~/.config/nvim/autoload/plug.vim:767
Called 38 times
Total time:   0.000998
 Self time:   0.000704

count  total (s)   self (s)
   38              0.000031   let repo = a:repo
   38   0.000197   0.000116   if s:is_local_plug(repo)
                                return { 'dir': s:dirpath(s:plug_expand(repo)) }
   38              0.000014   else
   38              0.000038     if repo =~ ':'
                                  let uri = repo
   38              0.000011     else
   38              0.000032       if repo !~ '/'
                                    throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)
   38              0.000011       endif
   38              0.000064       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')
   38              0.000057       let uri = printf(fmt, repo)
   38              0.000010     endif
   38   0.000375   0.000163     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }
                              endif

FUNCTION  signature#utils#Set()
    Defined: ~/.config/nvim/autoload/plugged/vim-signature/autoload/signature/utils.vim:4
Called 30 times
Total time:   0.000237
 Self time:   0.000237

count  total (s)   self (s)
                              " Description: Assign value to var if var is unset or if an optional 3rd arg is provided to force
                            
   30              0.000043   if (!exists(a:var) || a:0 && a:1)
   30              0.000023     if type(a:value)
   11              0.000037       execute 'let' a:var '=' string(a:value)
   19              0.000006     else
   19              0.000044       execute 'let' a:var '=' a:value
   30              0.000008     endif
   30              0.000008   endif
   30              0.000017   return a:var

FUNCTION  <SNR>5_assoc()
    Defined: ~/.config/nvim/autoload/plug.vim:312
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   let a:dict[a:key] = add(get(a:dict, a:key, []), a:val)

FUNCTION  <SNR>5_reorg_rtp()
    Defined: ~/.config/nvim/autoload/plug.vim:562
Called 1 time
Total time:   0.002738
 Self time:   0.002340

count  total (s)   self (s)
    1              0.000001   if !empty(s:first_rtp)
    1              0.000005     execute 'set rtp-='.s:first_rtp
    1              0.000003     execute 'set rtp-='.s:last_rtp
    1              0.000000   endif
                            
                              " &rtp is modified from outside
    1              0.000001   if exists('s:prtp') && s:prtp !=# &rtp
                                call s:remove_rtp()
                                unlet! s:middle
    1              0.000000   endif
                            
    1              0.000003   let s:middle = get(s:, 'middle', &rtp)
    1   0.000489   0.000091   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
    1              0.002111   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
    1              0.000057   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')
    1              0.000039   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
    1              0.000002   let s:prtp   = &rtp
                            
    1              0.000002   if !empty(s:first_rtp)
    1              0.000011     execute 'set rtp^='.s:first_rtp
    1              0.000007     execute 'set rtp+='.s:last_rtp
    1              0.000001   endif

FUNCTION  <SNR>117_IndentLinesDisable()
    Defined: ~/.config/nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:209
Called 1 time
Total time:   0.000027
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000003         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
                                        for id in w:indentLine_indentLineId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_indentLineId = []
    1              0.000000         endif
                            
    1   0.000014   0.000006         call s:ResetConcealOption()
    1              0.000001         return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry

FUNCTION  <SNR>106_LocalBrowse()
    Defined: /usr/share/nvim/runtime/plugin/netrwPlugin.vim:102
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    1              0.000001   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
    1              0.000000    return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  <SNR>118_brightness_()
    Defined: ~/.config/nvim/autoload/plugged/rainbow_parentheses.vim/autoload/rainbow_parentheses.vim:59
Called 23 times
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
   23              0.000083   let [max, min] = map([max(a:rgb), min(a:rgb)], 'v:val / 255.0')
   23              0.000055   let [r, g, b]  = map(a:rgb, 'v:val / 255.0')
   23              0.000015   if max == min
    4              0.000004     return (max + min) / 2.0
   19              0.000006   endif
   19              0.000040   return sqrt(0.299 * r * r + 0.587 * g * g + 0.114 * b * b)

FUNCTION  <SNR>86_defs()
    Defined: ~/.config/nvim/autoload/plugged/fzf.vim/plugin/fzf.vim:33
Called 1 time
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
    1              0.000004   let prefix = get(g:, 'fzf_command_prefix', '')
    1              0.000004   if prefix =~# '^[^A-Z]'
                                echoerr 'g:fzf_command_prefix must start with an uppercase letter'
                                return
    1              0.000000   endif
   23              0.000013   for command in a:commands
   22              0.000079     let name = ':'.prefix.matchstr(command, '\C[A-Z]\S\+')
   22              0.000028     if 2 != exists(name)
   20              0.000145       execute substitute(command, '\ze\C[A-Z]', prefix, '')
   22              0.000006     endif
   23              0.000006   endfor

FUNCTION  <SNR>118_blacklist()
    Defined: ~/.config/nvim/autoload/plugged/rainbow_parentheses.vim/autoload/rainbow_parentheses.vim:95
Called 1 time
Total time:   0.000045
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000002   redir => output
    1              0.000006     silent! hi Normal
    1              0.000002   redir END
    1              0.000006   let line  = split(output, '\n')[0]
    1              0.000004   let cterm = matchstr(line, 'ctermbg=\zs\S*\ze')
    1              0.000004   let gui   = matchstr(line, 'guibg=\zs\S*\ze')
    1              0.000002   let blacklist = {}
    1              0.000003   if !empty(cterm) | let blacklist[cterm] = 1 | endif
    1              0.000002   if !empty(gui)   | let blacklist[gui]   = 1 | endif
    1   0.000013   0.000006   return [blacklist, s:extract_fg(line)]

FUNCTION  <SNR>87_current()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:208
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000023   let fn = expand('%:p', 1)
    1              0.000005   if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
    1              0.000004   if empty(fn) | return getcwd() | endif  " opening vim without a file
                              if g:rooter_resolve_links | let fn = resolve(fn) | endif
                              return fnamemodify(fn, ':h')

FUNCTION  <SNR>7_detect_indent()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:2904
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000001     if &buftype ==# 'help'
                                  return
    1              0.000000     endif
                            
                                " Do not autodetect indent if language or user sets it
    1              0.000001     if &l:shiftwidth != s:default_shiftwidth
    1              0.000000       return
                                endif
                            
                                let b:sleuth_culprit = expand("<afile>:p")
                                if s:guess(getline(1, 128))
                                  return
                                endif
                                if s:guess(getline(1, 1024))
                                  return
                                endif
                                let pattern = polyglot#sleuth#GlobForFiletype(&filetype)
                                if len(pattern) == 0
                                  return
                                endif
                                let pattern = '{' . pattern . ',.git,.svn,.hg}'
                                let dir = expand('%:p:h')
                                let level = 3
                                while isdirectory(dir) && dir !=# fnamemodify(dir, ':h') && level > 0
                                  " Ignore files from homedir and root 
                                  if dir == expand('~') || dir == '/'
                                    unlet b:sleuth_culprit
                                    return
                                  endif
                                  for neighbor in glob(dir . '/' . pattern, 0, 1)[0:level]
                                    let b:sleuth_culprit = neighbor
                                    " Do not consider directories above .git, .svn or .hg
                                    if fnamemodify(neighbor, ":h:t")[0] == "."
                                      let level = 0
                                      continue
                                    endif
                                    if neighbor !=# expand('%:p') && filereadable(neighbor)
                                      if s:guess(readfile(neighbor, '', 32))
                                        return
                                      endif
                                    endif
                                  endfor
                            
                                  let dir = fnamemodify(dir, ':h')
                                  let level -= 1
                                endwhile
                            
                                let b:sleuth_culprit = "default"

FUNCTION  coc#rpc#start_server()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/rpc.vim:7
Called 1 time
Total time:   0.001751
 Self time:   0.000267

count  total (s)   self (s)
    1              0.000003   if get(g:, 'coc_node_env', '') ==# 'test'
                                " server already started
                                let s:client = coc#client#create(s:name, [])
                                let s:client['running'] = 1
                                let s:client['chan_id'] = get(g:, 'coc_node_channel_id', 0)
                                call dictwatcheradd(g:, 'coc_node_channel_id', function('s:ChannelSet'))
                                return
    1              0.000001   endif
    1              0.000001   if empty(s:client)
    1   0.000552   0.000111     let cmd = coc#util#job_command()
    1              0.000002     if empty(cmd) | return | endif
    1   0.000028   0.000008     let $COC_VIMCONFIG = coc#util#get_config_home()
    1   0.000055   0.000006     let $COC_DATA_HOME = coc#util#get_data_home()
    1   0.000303   0.000112     let s:client = coc#client#create(s:name, cmd)
    1              0.000000   endif
    1   0.000011   0.000004   if !coc#client#is_running('coc')
    1   0.000784   0.000009     call s:client['start']()
    1              0.000000   endif

FUNCTION  <SNR>5_escrtp()
    Defined: ~/.config/nvim/autoload/plug.vim:547
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000004   return escape(a:path, ' ,')

FUNCTION  <SNR>117_LeadingSpaceDisable()
    Defined: ~/.config/nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:364
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000002         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
    1              0.000000         endif
                            
    1              0.000000         return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry

FUNCTION  <SNR>5_parse_options()
    Defined: ~/.config/nvim/autoload/plug.vim:729
Called 6 times
Total time:   0.000403
 Self time:   0.000403

count  total (s)   self (s)
    6              0.000011   let opts = copy(s:base_spec)
    6              0.000007   let type = type(a:arg)
    6              0.000008   let opt_errfmt = 'Invalid argument for "%s" option of :Plug (expected: %s)'
    6              0.000006   if type == s:TYPE.string
                                if empty(a:arg)
                                  throw printf(opt_errfmt, 'tag', 'string')
                                endif
                                let opts.tag = a:arg
    6              0.000005   elseif type == s:TYPE.dict
   42              0.000030     for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
   36              0.000078       if has_key(a:arg, opt) && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
                                    throw printf(opt_errfmt, opt, 'string')
   36              0.000008       endif
   42              0.000014     endfor
   18              0.000012     for opt in ['on', 'for']
   12              0.000037       if has_key(a:arg, opt) && type(a:arg[opt]) != s:TYPE.list && (type(a:arg[opt]) != s:TYPE.string || empty(a:arg[opt]))
                                    throw printf(opt_errfmt, opt, 'string or list')
   12              0.000003       endif
   18              0.000005     endfor
    6              0.000021     if has_key(a:arg, 'do') && type(a:arg.do) != s:TYPE.funcref && (type(a:arg.do) != s:TYPE.string || empty(a:arg.do))
                                    throw printf(opt_errfmt, 'do', 'string or funcref')
    6              0.000002     endif
    6              0.000014     call extend(opts, a:arg)
    6              0.000006     if has_key(opts, 'dir')
                                  let opts.dir = s:dirpath(s:plug_expand(opts.dir))
    6              0.000002     endif
                              else
                                throw 'Invalid argument type (expected: string or dictionary)'
    6              0.000002   endif
    6              0.000004   return opts

FUNCTION  signature#utils#Maps()
    Defined: ~/.config/nvim/autoload/plugged/vim-signature/autoload/signature/utils.vim:35
Called 1 time
Total time:   0.000365
 Self time:   0.000092

count  total (s)   self (s)
                              " We create separate mappings for PlaceNextMark, mark#Purge('all') and PurgeMarkers instead of combining it with
                              " Leader/Input as if the user chooses to use some weird key like <BS> or <CR> for any of these 3, we need to be able
                              " to identify it. Eg. the nr2char(getchar()) will fail if the user presses a <BS>
    1              0.000003   let l:SignatureMapLeader = get(g:SignatureMap, 'Leader', 'm')
    1              0.000001   if (l:SignatureMapLeader == "")
                                echoe "Signature: g:SignatureMap.Leader shouldn't be left blank"
    1              0.000000   endif
    1   0.000035   0.000006   call s:Map(a:mode, 'Leader'           , l:SignatureMapLeader            , 'utils#Input()'                       )
    1   0.000021   0.000005   call s:Map(a:mode, 'PlaceNextMark'    , l:SignatureMapLeader . ","      , 'mark#Toggle("next")'                 )
    1   0.000018   0.000004   call s:Map(a:mode, 'ToggleMarkAtLine' , l:SignatureMapLeader . "."      , 'mark#ToggleAtLine()'                 )
    1   0.000016   0.000004   call s:Map(a:mode, 'PurgeMarksAtLine' , l:SignatureMapLeader . "-"      , 'mark#Purge("line")'                  )
    1   0.000016   0.000004   call s:Map(a:mode, 'PurgeMarks'       , l:SignatureMapLeader . "<Space>", 'mark#Purge("all")'                   )
    1   0.000018   0.000006   call s:Map(a:mode, 'PurgeMarkers'     , l:SignatureMapLeader . "<BS>"   , 'marker#Purge()'                      )
    1   0.000016   0.000004   call s:Map(a:mode, 'DeleteMark'       , "dm"                            , 'utils#Remove(v:count)'               )
    1   0.000016   0.000004   call s:Map(a:mode, 'GotoNextLineAlpha', "']"                            , 'mark#Goto("next", "line", "alpha")'  )
    1   0.000016   0.000004   call s:Map(a:mode, 'GotoPrevLineAlpha', "'["                            , 'mark#Goto("prev", "line", "alpha")'  )
    1   0.000016   0.000004   call s:Map(a:mode, 'GotoNextSpotAlpha', "`]"                            , 'mark#Goto("next", "spot", "alpha")'  )
    1   0.000015   0.000003   call s:Map(a:mode, 'GotoPrevSpotAlpha', "`["                            , 'mark#Goto("prev", "spot", "alpha")'  )
    1   0.000015   0.000003   call s:Map(a:mode, 'GotoNextLineByPos', "]'"                            , 'mark#Goto("next", "line", "pos")'    )
    1   0.000015   0.000003   call s:Map(a:mode, 'GotoPrevLineByPos', "['"                            , 'mark#Goto("prev", "line", "pos")'    )
    1   0.000015   0.000003   call s:Map(a:mode, 'GotoNextSpotByPos', "]`"                            , 'mark#Goto("next", "spot", "pos")'    )
    1   0.000015   0.000003   call s:Map(a:mode, 'GotoPrevSpotByPos', "[`"                            , 'mark#Goto("prev", "spot", "pos")'    )
    1   0.000015   0.000003   call s:Map(a:mode, 'GotoNextMarker'   , "]-"                            , 'marker#Goto("next", "same", v:count)')
    1   0.000015   0.000003   call s:Map(a:mode, 'GotoPrevMarker'   , "[-"                            , 'marker#Goto("prev", "same", v:count)')
    1   0.000018   0.000005   call s:Map(a:mode, 'GotoNextMarkerAny', "]="                            , 'marker#Goto("next", "any",  v:count)')
    1   0.000017   0.000005   call s:Map(a:mode, 'GotoPrevMarkerAny', "[="                            , 'marker#Goto("prev", "any",  v:count)')
    1   0.000015   0.000004   call s:Map(a:mode, 'ListBufferMarks'  , 'm/'                            , 'mark#List(0, 0)'                     )
    1   0.000015   0.000003   call s:Map(a:mode, 'ListBufferMarkers', 'm?'                            , 'marker#List(v:count, 0)'             )

FUNCTION  <SNR>7_SetDefault()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:68
Called 28 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
   28              0.000031   if !exists(a:name)
   28              0.000039     let {a:name} = a:value
   28              0.000007   endif

FUNCTION  <SNR>118_colors_to_hi()
    Defined: ~/.config/nvim/autoload/plugged/rainbow_parentheses.vim/autoload/rainbow_parentheses.vim:79
Called 16 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
   16              0.000106   return join(   values(     map(       filter({ 'ctermfg': a:colors[0], 'guifg': a:colors[1] },              '!empty(v:val)'),       'v:key."=".v:val')), ' ')

FUNCTION  <SNR>89_Map()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:708
Called 2 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
    2              0.000011   let flags = a:flags . (a:rhs =~# '<Plug>' ? '' : '<script>')
    2              0.000003   let head = a:lhs
    2              0.000002   let tail = ''
    2              0.000006   let keys = get(g:, a:mode.'remap', {})
    2              0.000004   if len(keys) && type(keys) == type({})
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
    2              0.000001   endif
    2              0.000007   if flags !~# '<unique>' || empty(mapcheck(head.tail, a:mode))
    2              0.000058     exe a:mode.'map' s:nowait flags head.tail a:rhs
    2              0.000001   endif

FUNCTION  <SNR>5_glob()
    Defined: ~/.config/nvim/autoload/plug.vim:297
Called 1 time
Total time:   0.000054
 Self time:   0.000048

count  total (s)   self (s)
    1   0.000054   0.000048   return s:lines(globpath(a:from, a:pattern))

FUNCTION  <SNR>118_uniq()
    Defined: ~/.config/nvim/autoload/plugged/rainbow_parentheses.vim/autoload/rainbow_parentheses.vim:6
Called 1 time
Total time:   0.002193
 Self time:   0.002193

count  total (s)   self (s)
    1              0.000001   let ret = []
    1              0.000001   let map = {}
  227              0.000084   for items in a:list
  226              0.000097     let ok = 1
  493              0.000602     for item in filter(copy(items), '!empty(v:val)')
  267              0.000209       if has_key(map, item)
  214              0.000092         let ok = 0
  267              0.000060       endif
  267              0.000187       let map[item] = 1
  493              0.000110     endfor
  226              0.000077     if ok
   24              0.000023       call add(ret, items)
  226              0.000047     endif
  227              0.000051   endfor
    1              0.000002   return ret

FUNCTION  <SNR>118_brightness()
    Defined: ~/.config/nvim/autoload/plugged/rainbow_parentheses.vim/autoload/rainbow_parentheses.vim:69
Called 24 times
Total time:   0.000804
 Self time:   0.000313

count  total (s)   self (s)
   24              0.000084   let color = filter(copy(a:color), '!empty(v:val)')[0]
   24              0.000027   if has_key(s:brightness, color)
    1              0.000001     return s:brightness[color]
   23              0.000007   endif
   23   0.000620   0.000130   let b = s:brightness_(s:rgb(color))
   23              0.000028   let s:brightness[color] = b
   23              0.000011   return b

FUNCTION  coc#client#is_running()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/client.vim:246
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002   let client = get(s:clients, a:name, v:null)
    1              0.000002   if empty(client) | return 0 | endif
    1              0.000002   if !client['running'] | return 0 | endif
                              if s:is_vim
                                let status = job_status(ch_getjob(client['channel']))
                                return status ==# 'run'
                              else
                                let chan_id = client['chan_id']
                                let [code] = jobwait([chan_id], 10)
                                return code == -1
                              endif

FUNCTION  <SNR>65_checkVersion()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/plugin/coc.vim:6
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000002   let l:unsupported = 0
    1              0.000003   if get(g:, 'coc_disable_startup_warning', 0) != 1
    1              0.000003     if has('nvim')
    1              0.000003       let l:unsupported = !has('nvim-0.3.2')
                                else
                                  let l:unsupported = !has('patch-8.0.1453')
    1              0.000000     endif
                            
    1              0.000001     if l:unsupported == 1
                                  echohl Error
                                  echom "coc.nvim requires at least Vim 8.0.1453 or Neovim 0.3.2, but you're using an older version."
                                  echom "Please upgrade your (neo)vim."
                                  echom "You can add this to your vimrc to avoid this message:"
                                  echom "    let g:coc_disable_startup_warning = 1"
                                  echom "Note that some features may error out or behave incorrectly."
                                  echom "Please do not report bugs unless you're using at least Vim 8.0.1453 or Neovim 0.3.2."
                                  echohl None
                                  sleep 2
    1              0.000000     else
    1              0.000002       if !has('nvim-0.4.0') && !has('patch-8.1.1719')
                                    echohl WarningMsg
                                    echom "coc.nvim works best on vim >= 8.1.1719 and neovim >= 0.4.0, consider upgrade your vim."
                                    echom "You can add this to your vimrc to avoid this message:"
                                    echom "    let g:coc_disable_startup_warning = 1"
                                    echom "Note that some features may behave incorrectly."
                                    echohl None
                                    sleep 2
    1              0.000000       endif
    1              0.000000     endif
    1              0.000000   endif

FUNCTION  <SNR>117_SetConcealOption()
    Defined: ~/.config/nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:96
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000001     if !g:indentLine_setConceal
                                    return
    1              0.000000     endif
    1              0.000002     if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
    1              0.000001         let b:indentLine_ConcealOptionSet = 1
    1              0.000002         let b:indentLine_original_concealcursor = &l:concealcursor
    1              0.000002         let b:indentLine_original_conceallevel = &l:conceallevel
    1              0.000006         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
    1              0.000003         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
    1              0.000000     endif

FUNCTION  <SNR>75_Declare()
    Defined: ~/.config/nvim/autoload/plugged/vim-closetag/plugin/closetag.vim:73
Called 8 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    8              0.000011     if !exists(a:var)
    8              0.000019         let {a:var} = a:def
    8              0.000003     en

FUNCTION  <SNR>5_dirpath()
    Defined: ~/.config/nvim/autoload/plug.vim:522
Called 38 times
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
   38              0.000205     return substitute(a:path, '[/\\]*$', '/', '')

FUNCTION  <SNR>118_extract_colors()
    Defined: ~/.config/nvim/autoload/plugged/rainbow_parentheses.vim/autoload/rainbow_parentheses.vim:109
Called 1 time
Total time:   0.006874
 Self time:   0.002359

count  total (s)   self (s)
    1              0.000005   if exists('g:colors_name') && has_key(s:colors[&background], g:colors_name)
                                return s:colors[&background][g:colors_name]
    1              0.000000   endif
    1              0.000002   redir => output
    1              0.000408     silent hi
    1              0.000017   redir END
    1              0.000980   let lines = filter(split(output, '\n'), 'v:val =~# "fg" && v:val !~? "links" && v:val !~# "bg"')
    1   0.004151   0.000594   let colors = s:uniq(reverse(map(lines, 's:extract_fg(v:val)')))
    1   0.000057   0.000012   let [blacklist, fg] = s:blacklist()
    1              0.000003   for c in get(g:, 'rainbow#blacklist', [])
                                let blacklist[c] = 1
    1              0.000000   endfor
    1              0.000040   let colors = filter(colors, '!has_key(blacklist, v:val[0]) && !has_key(blacklist, v:val[1])')
                            
    1              0.000004   if !empty(filter(copy(fg), '!empty(v:val)'))
    1   0.000054   0.000008     let nb = s:brightness(fg)
    1              0.000002     let [first, second] = [[], []]
   24              0.000014     for cpair in colors
   23   0.000843   0.000086       let b = s:brightness(cpair)
   23              0.000024       let diff = abs(nb - b)
   23              0.000016       if diff <= 0.25
    9              0.000010         call add(first, cpair)
   14              0.000009       elseif diff <= 0.5
    7              0.000009         call add(second, cpair)
   23              0.000006       endif
   24              0.000008     endfor
    1              0.000003     let colors = extend(first, second)
    1              0.000000   endif
                            
    1   0.000158   0.000049   let colors = map(colors, 's:colors_to_hi(v:val)')
    1              0.000002   if exists('g:colors_name')
    1              0.000003     let s:colors[&background][g:colors_name] = colors
    1              0.000000   endif
    1              0.000001   return colors

FUNCTION  signature#sign#Remove()
    Defined: ~/.config/nvim/autoload/plugged/vim-signature/autoload/signature/sign.vim:38
Called 52 times
Total time:   0.000925
 Self time:   0.000824

count  total (s)   self (s)
                              " Description: Remove signs for marks/markers from the specified line number
                              " Arguments:
                              "   sign : The mark/marker whose sign is to be placed/removed/toggled
                              "   lnum : Line number from which the sign is to be removed
                              "          If sign is a marker and lnum is 0, the sign will be removed from all lines
                              "          If sign is a mark   and lnum is 0, the lnum will be found and the sign will be removed from that line
                            
                              "echom "DEBUG: sign = " . a:sign . ",  lnum = " . a:lnum
                            
                              " If Signature is not enabled, return
   52              0.000059   if !b:sig_enabled | return | endif
                            
                              " Remove sign for markers
   52   0.000272   0.000171   if signature#utils#IsValidMarker(a:sign)
                                let b:sig_markers[a:lnum] = substitute(b:sig_markers[a:lnum], "\\C" . escape( a:sign, '$^' ), "", "")
                            
                                " If there are no markers on the line, delete signs on that line
                                if b:sig_markers[a:lnum] == ""
                                  call remove(b:sig_markers, a:lnum)
                                endif
                                call s:RefreshLine(a:lnum)
                            
                              " Remove sign for marks
   52              0.000015   else
                                " For marks, if a:lnum == 0, find out the line where the mark was placed
   52              0.000027     if a:lnum == 0
   52              0.000116       let l:arr = keys(filter(copy(b:sig_marks), 'v:val =~# a:sign'))
   52              0.000055       if empty(l:arr) | return | endif
                                else
                                  let l:arr = [a:lnum]
                                endif
                                if (v:version >= 800)
                                  call assert_true(len(l:arr) == 1, "Multiple marks found where one was expected")
                                elseif (len(l:arr) != 1)
                                  echoerr "Multiple marks found where one was expected"
                                endif
                            
                                for l:lnum in l:arr
                                  " FIXME: Placed guard to avoid triggering issue #53
                                  if has_key(b:sig_marks, l:lnum)
                                    let b:sig_marks[l:lnum] = substitute(b:sig_marks[l:lnum], "\\C" . a:sign, "", "")
                                    " If there are no marks on the line, delete signs on that line
                                    if b:sig_marks[l:lnum] == ""
                                      call remove(b:sig_marks, l:lnum)
                                    endif
                                  endif
                                  call s:RefreshLine(l:lnum)
                                endfor
                              endif

FUNCTION  <SNR>65_Autocmd()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/plugin/coc.vim:245
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000003   if !g:coc_service_initialized
    2              0.000003     return
                              endif
                              call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  <SNR>82_default_mapping()
    Defined: ~/.config/nvim/autoload/plugged/vim-easymotion/plugin/EasyMotion.vim:249
Called 1 time
Total time:   0.000522
 Self time:   0.000522

count  total (s)   self (s)
   18              0.000011         for motion in a:motions
                                        " Mapping {{{
   17              0.000026             if exists('g:EasyMotion_mapping_' . motion)
                                            " Backward compatible mapping [deprecated]
                                            silent exec 'map <silent> ' . eval('g:EasyMotion_mapping_' . motion) . ' <Plug>(easymotion-' . motion . ')'
   17              0.000262             elseif a:do_mapping && !hasmapto('<Plug>(easymotion-' . motion . ')') && empty(maparg('<Plug>(easymotion-prefix)' . motion, 'nov'))
                            
                                            " Do mapping
   17              0.000171                 silent exec 'map <silent> ' .'<Plug>(easymotion-prefix)' . motion . ' <Plug>(easymotion-' . motion . ')'
   17              0.000006             endif "}}}
   18              0.000007         endfor

FUNCTION  <SNR>107_GetOldManifestPaths()
    Defined: /usr/share/nvim/runtime/plugin/rplugin.vim:26
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000005   let prefix = exists('$MYVIMRC') ? $MYVIMRC : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
    1              0.000030   let origpath = fnamemodify(expand(prefix, 1), ':h').'/.'.fnamemodify(prefix, ':t').'-rplugin~'
    1              0.000003   if !has('win32')
    1              0.000001     return [origpath]
                              endif
                              " Windows used to use $APPLOCALDATA/nvim but stdpath('data') is
                              " $XDG_DATA_DIR/nvim-data
                              let pseudostdpath = exists('$LOCALAPPDATA') ? '$LOCALAPPDATA' : '~/AppData/Local'
                              let pseudostdpath = fnamemodify(expand(pseudostdpath), ':p')
                              return [substitute(pseudostdpath, '[/\\]\=$', '/', '') . 'nvim/rplugin.vim', origpath]

FUNCTION  <SNR>82_motion_map_helper()
    Defined: ~/.config/nvim/autoload/plugged/vim-easymotion/plugin/EasyMotion.vim:63
Called 6 times
Total time:   0.002829
 Self time:   0.002829

count  total (s)   self (s)
   90              0.000100     for [name, dict] in items(a:motions)
   84              0.000062         let mapargs = []
   84              0.000054         let xmapargs = []
   84              0.000131         if dict.fnc ==# 'S' || dict.fnc ==# 'SL' || dict.fnc ==# 'T' || dict.fnc ==# 'TL'
   42              0.000054             let mapargs  += [dict.cnt, 0, dict.direction]
   42              0.000053             let xmapargs += [dict.cnt, 1, dict.direction]
   42              0.000027         elseif dict.fnc ==# 'Search'
    5              0.000008             let mapargs  += [0, dict.direction, dict.respect_direction]
    5              0.000007             let xmapargs += [1, dict.direction, dict.respect_direction]
   37              0.000009         else
   37              0.000039             let mapargs  += [0, dict.direction]
   37              0.000036             let xmapargs += [1, dict.direction]
   84              0.000020         endif
                            
   84              0.000934         silent exec 'noremap  <silent><Plug>(easymotion-'.name.')' . '      :<C-u>call EasyMotion#' . dict.fnc . '('. join(mapargs, ',') . ')<CR>'
   84              0.000822         silent exec 'xnoremap <silent><Plug>(easymotion-'.name.')' . ' <Esc>:<C-u>call EasyMotion#' . dict.fnc . '('. join(xmapargs, ',') . ')<CR>'
                                " Example:
                                " noremap  <silent><Plug>(easymotion-f2) :<C-u>call EasyMotion#S(2,1,0)<CR>
                                " xnoremap <silent><Plug>(easymotion-f2) <Esc>:<C-u>call EasyMotion#S(2,1,0)<CR>
   90              0.000034     endfor

FUNCTION  <SNR>5_trim()
    Defined: ~/.config/nvim/autoload/plug.vim:449
Called 76 times
Total time:   0.000330
 Self time:   0.000330

count  total (s)   self (s)
   76              0.000318   return substitute(a:str, '[\/]\+$', '', '')

FUNCTION  <SNR>79_Map()
    Defined: ~/.config/nvim/autoload/plugged/vim-signature/autoload/signature/utils.vim:23
Called 21 times
Total time:   0.000273
 Self time:   0.000273

count  total (s)   self (s)
   21              0.000040   let l:map_lhs = get(g:SignatureMap, a:key, a:map_lhs_default)
   21              0.000014   if (l:map_lhs ==? '')
                                return
   21              0.000005   endif
   21              0.000014   if (a:mode ==? 'create')
   21              0.000155     silent! execute 'nnoremap <silent> <unique> ' . l:map_lhs . ' ' . ':<C-U>call signature#' . a:map_rhs . '<CR>'
                              elseif (a:mode ==? 'remove')
                                silent! execute 'nunmap ' . l:map_lhs
   21              0.000005   endif

FUNCTION  <SNR>118_rgb()
    Defined: ~/.config/nvim/autoload/plugged/rainbow_parentheses.vim/autoload/rainbow_parentheses.vim:31
Called 31 times
Total time:   0.000312
 Self time:   0.000261

count  total (s)   self (s)
   31              0.000030   if a:color[0] == '#'
   18              0.000027     let r = str2nr(a:color[1:2], 16)
   18              0.000021     let g = str2nr(a:color[3:4], 16)
   18              0.000020     let b = str2nr(a:color[5:6], 16)
   18              0.000017     return [r, g, b]
   13              0.000004   endif
                            
   13              0.000015   let ansi = str2nr(a:color)
                            
   13              0.000008   if ansi < 16
    8              0.000016     return s:rgb(s:ansi16[ansi])
    5              0.000001   endif
                            
    5              0.000003   if ansi >= 232
    2              0.000002     let v = (ansi - 232) * 10 + 8
    2              0.000002     return [v, v, v]
    3              0.000001   endif
                            
    3              0.000003   let r = (ansi - 16) / 36
    3              0.000003   let g = ((ansi - 16) % 36) / 6
    3              0.000002   let b = (ansi - 16) % 6
                            
    3              0.000012   return map([r, g, b], 'v:val > 0 ? (55 + v:val * 40) : 0')

FUNCTION  AutoPairsDefaultPairs()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:20
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000001   if exists('b:autopairs_defaultpairs')
                                return b:autopairs_defaultpairs
    1              0.000000   end
    1              0.000004   let r = copy(g:AutoPairs)
    1              0.000006   let allPairs = { 'vim': {'\v^\s*\zs"': ''}, 'rust': {'\w\zs<': '>', '&\zs''': ''}, 'php': {'<?': '?>//k]', '<?php': '?>//k]'} }
    4              0.000007   for [filetype, pairs] in items(allPairs)
    3              0.000004     if &filetype == filetype
                                  for [open, close] in items(pairs)
                                    let r[open] = close
                                  endfor
    3              0.000001     end
    4              0.000001   endfor
    1              0.000001   let b:autopairs_defaultpairs = r
    1              0.000001   return r

FUNCTION  <SNR>5_split_rtp()
    Defined: ~/.config/nvim/autoload/plug.vim:2790
Called 2 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    2              0.000064   return split(&rtp, '\\\@<!,')

FUNCTION  <SNR>87_has()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:172
Called 1 time
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
                              " We do not want a:dir to be treated as a glob so escape any wildcards.
                              " If this approach is problematic (e.g. on Windows), an alternative
                              " might be to change directory to a:dir, call globpath() with just
                              " a:identifier, then restore the working directory.
    1              0.000052   return !empty(globpath(escape(a:dir, '?*[]'), a:identifier, 1))

FUNCTION  <SNR>5_lines()
    Defined: ~/.config/nvim/autoload/plug.vim:863
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   return split(a:msg, "[\r\n]")

FUNCTION  AutoPairsTryInit()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:603
Called 1 time
Total time:   0.000987
 Self time:   0.000127

count  total (s)   self (s)
    1              0.000002   if exists('b:autopairs_loaded')
                                return
    1              0.000000   end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
    1              0.000001   if g:AutoPairsMapCR
    1              0.000002     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    1              0.000035       let info = maparg('<CR>', 'i', 0, 1)
    1              0.000002       if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
    1              0.000000       else
    1              0.000002         let old_cr = info['rhs']
    1   0.000024   0.000006         let old_cr = s:ExpandMap(old_cr)
    1              0.000005         let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
    1              0.000001         let is_expr = info['expr']
    1              0.000001         let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
    1              0.000000       endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
    1              0.000000     end
                            
    1              0.000004     if old_cr !~ 'AutoPairsReturn'
    1              0.000001       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
    1              0.000028         execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
    1              0.000001         let old_cr = wrapper_name
    1              0.000000       end
                                  " Always silent mapping
    1              0.000011       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    1              0.000000     end
    1              0.000000   endif
    1   0.000849   0.000007   call AutoPairsInit()

FUNCTION  <SNR>7_Observe()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:2683
Called 1 time
Total time:   0.000290
 Self time:   0.000290

count  total (s)   self (s)
    1              0.000002   augroup polyglot-observer
    1              0.000280     au!
    1              0.000005     au CursorHold,CursorHoldI <buffer> if (&ft == "" || &ft == "conf") | call s:PolyglotObserve(s:detect_func) | endif
    1              0.000001   augroup END

FUNCTION  <SNR>117_Setup()
    Defined: ~/.config/nvim/autoload/plugged/indentLine/after/plugin/indentLine.vim:317
Called 1 time
Total time:   0.000332
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000001     if &filetype ==# ""
    1   0.000071   0.000004         call s:InitColor()
    1              0.000000     endif
                            
    1   0.000022   0.000006     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
    1   0.000211   0.000005         call s:IndentLinesEnable()
    1              0.000000     endif
                            
    1   0.000023   0.000009     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
    1              0.000000     endif

FUNCTION  polyglot#init#init()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:19
Called 5 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                              " A no-op as sourcing this file is enough

FUNCTION  <SNR>87_root()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:117
Called 1 time
Total time:   0.000119
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000036   0.000004   let dir = s:current()
                            
                              " breadth-first search
    1              0.000001   while 1
    1              0.000002     for pattern in g:rooter_patterns
    1              0.000001       if pattern[0] == '!'
                                    let [p, exclude] = [pattern[1:], 1]
    1              0.000000       else
    1              0.000002         let [p, exclude] = [pattern, 0]
    1              0.000000       endif
    1   0.000070   0.000005       if s:match(dir, p)
    1              0.000001         if exclude
                                      break
    1              0.000001         else
    1              0.000001           return dir
                                    endif
                                  endif
                                endfor
                            
                                let [current, dir] = [dir, s:parent(dir)]
                                if current == dir | break | endif
                              endwhile
                            
                              return ''

FUNCTION  <SNR>5_plug_fnamemodify()
    Defined: ~/.config/nvim/autoload/plug.vim:227
Called 40 times
Total time:   0.000315
 Self time:   0.000164

count  total (s)   self (s)
   40   0.000308   0.000157   return s:plug_call('fnamemodify', a:fname, a:mods)

FUNCTION  <SNR>5_lazy()
    Defined: ~/.config/nvim/autoload/plug.vim:334
Called 74 times
Total time:   0.000447
 Self time:   0.000368

count  total (s)   self (s)
   74   0.000436   0.000356   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

FUNCTION  <SNR>5_path()
    Defined: ~/.config/nvim/autoload/plug.vim:518
Called 38 times
Total time:   0.000278
 Self time:   0.000103

count  total (s)   self (s)
   38   0.000273   0.000098     return s:trim(a:path)

FUNCTION  <SNR>5_to_a()
    Defined: ~/.config/nvim/autoload/plug.vim:289
Called 4 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    4              0.000009   return type(a:v) == s:TYPE.list ? a:v : [a:v]

FUNCTION  AutoPairsInit()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:471
Called 1 time
Total time:   0.000842
 Self time:   0.000591

count  total (s)   self (s)
    1              0.000001   let b:autopairs_loaded  = 1
    1              0.000002   if !exists('b:autopairs_enabled')
    1              0.000001     let b:autopairs_enabled = 1
    1              0.000000   end
                            
    1              0.000001   if !exists('b:AutoPairs')
    1   0.000043   0.000006     let b:AutoPairs = AutoPairsDefaultPairs()
    1              0.000000   end
                            
    1              0.000001   if !exists('b:AutoPairsMoveCharacter')
    1              0.000001     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
    1              0.000000   end
                            
    1              0.000001   let b:autopairs_return_pos = 0
    1              0.000001   let b:autopairs_saved_pair = [0, 0]
    1              0.000001   let b:AutoPairsList = []
                            
                              " buffer level map pairs keys
                              " n - do not map the first charactor of closed pair to close key
                              " m - close key jumps through multi line
                              " s - close key jumps only in the same line
   10              0.000012   for [open, close] in items(b:AutoPairs)
    9              0.000009     let o = open[-1:-1]
    9              0.000007     let c = close[0]
    9              0.000013     let opt = {'mapclose': 1, 'multiline':1}
    9              0.000009     let opt['key'] = c
    9              0.000005     if o == c
    6              0.000005       let opt['multiline'] = 0
    9              0.000002     end
    9              0.000031     let m = matchlist(close, '\v(.*)//(.*)$')
    9              0.000008     if len(m) > 0 
                                  if m[2] =~ 'n'
                                    let opt['mapclose'] = 0
                                  end
                                  if m[2] =~ 'm'
                                    let opt['multiline'] = 1
                                  end
                                  if m[2] =~ 's'
                                    let opt['multiline'] = 0
                                  end
                                  let ks = matchlist(m[2], '\vk(.)')
                                  if len(ks) > 0
                                    let opt['key'] = ks[1]
                                    let c = opt['key']
                                  end
                                  let close = m[1]
    9              0.000002     end
    9   0.000178   0.000031     call AutoPairsMap(o)
    9              0.000012     if o != c && c != '' && opt['mapclose']
    3   0.000051   0.000010       call AutoPairsMap(c)
    9              0.000003     end
    9              0.000019     let b:AutoPairsList += [[open, close, opt]]
   10              0.000004   endfor
                            
                              " sort pairs by length, longer pair should have higher priority
    1   0.000070   0.000044   let b:AutoPairsList = sort(b:AutoPairsList, "s:sortByLength")
                            
   10              0.000014   for item in b:AutoPairsList
    9              0.000015     let [open, close, opt] = item
    9              0.000010     if open == "'" && open == close
    1              0.000001       let item[0] = '\v(^|\W)\zs'''
    9              0.000002     end
   10              0.000004   endfor
                            
                            
    9              0.000014   for key in split(b:AutoPairsMoveCharacter, '\s*')
    8              0.000018     let escaped_key = substitute(key, "'", "''", 'g')
    8              0.000077     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
    9              0.000003   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    1              0.000001   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    1              0.000008     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsMapCh
    1              0.000007     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
    1              0.000000   endif
                            
    1              0.000001   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    1              0.000001     let do_abbrev = ""
    1              0.000002     if v:version == 703 && has("patch489") || v:version > 703
    1              0.000001       let do_abbrev = "<C-]>"
    1              0.000000     endif
    1              0.000008     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutFastWrap != ''
    1              0.000008     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutBackInsert != ''
    1              0.000008     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    1              0.000007     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    1              0.000009     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutJump != ''
    1              0.000008     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    1              0.000008     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    1              0.000000   end
                            
    1              0.000002   if &keymap != ''
                                let l:imsearch = &imsearch
                                let l:iminsert = &iminsert
                                let l:imdisable = &imdisable
                                execute 'setlocal keymap=' . &keymap
                                execute 'setlocal imsearch=' . l:imsearch
                                execute 'setlocal iminsert=' . l:iminsert
                                if l:imdisable
                                  execute 'setlocal imdisable'
                                else
                                  execute 'setlocal noimdisable'
                                end
    1              0.000000   end
                            

FUNCTION  rainbow_parentheses#activate()
    Defined: ~/.config/nvim/autoload/plugged/rainbow_parentheses.vim/autoload/rainbow_parentheses.vim:154
Called 1 time
Total time:   0.008298
 Self time:   0.000500

count  total (s)   self (s)
    1              0.000004   let force = get(a:000, 0, 0)
    1              0.000005   if exists('#rainbow_parentheses') && get(b:, 'rainbow_enabled', -1) == s:generation && !force
                                return
    1              0.000001   endif
                            
    1              0.000002   let s:generation += 1
    1              0.000002   let s:max_level = get(g:, 'rainbow#max_level', 16)
    1   0.006916   0.000042   let colors = exists('g:rainbow#colors') ? map(copy(g:rainbow#colors[&bg]), 's:colors_to_hi(v:val)') : s:extract_colors()
                            
   17              0.000010   for level in range(1, s:max_level)
   16              0.000022     let col = colors[(level - 1) % len(colors)]
   16              0.000067     execute printf('hi rainbowParensShell%d %s', s:max_level - level + 1, col)
   17              0.000005   endfor
    1   0.000947   0.000023   call s:regions(s:max_level)
                            
    1              0.000007   command! -bang -nargs=? -bar RainbowParenthesesColors call s:show_colors()
    1              0.000002   augroup rainbow_parentheses
    1              0.000284     autocmd!
    1              0.000010     autocmd ColorScheme,Syntax * call rainbow_parentheses#activate(1)
    1              0.000001   augroup END
    1              0.000003   let b:rainbow_enabled = s:generation

FUNCTION  <SNR>81_set_highlight_colors()
    Defined: ~/.config/nvim/autoload/plugged/quick-scope/plugin/quick_scope.vim:105
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                              " Priority for overruling other highlight matches.
    1              0.000004   let g:qs_hi_priority = get(g:, "qs_hi_priority", 1)
                            
                              " Highlight group marking first appearance of characters in a line.
    1              0.000001   let g:qs_hi_group_primary = 'QuickScopePrimary'
                              " Highlight group marking second appearance of characters in a line.
    1              0.000001   let g:qs_hi_group_secondary = 'QuickScopeSecondary'
                              " Highlight group marking dummy cursor when quick-scope is enabled on key
                              " press.
    1              0.000001   let g:qs_hi_group_cursor = 'QuickScopeCursor'
                            
    1              0.000002   if exists('g:qs_first_occurrence_highlight_color')
                                " backwards compatibility mode for old highlight configuration
                                augroup quick_scope_lazy_print
                                  if has('vim_starting')
                                    " register this as a lazy print error so as not to block Vim starting
                                    autocmd CursorHold,CursorHoldI * call quick_scope#lazy_print#err('option g:qs_first_occurrence_highlight_color is deprecated!')
                                  else
                                    echohl ErrorMsg
                                    echomsg s:plugin_name . ' option g:qs_first_occurrence_highlight_color is deprecated!'
                                    echohl None
                                  endif
                                augroup END
                            
                                let l:first_color = g:qs_first_occurrence_highlight_color
                                if l:first_color =~# '#'
                                  execute 'highlight default ' . g:qs_hi_group_primary . ' gui=underline guifg=' . l:first_color
                                else
                                  execute 'highlight default ' . g:qs_hi_group_primary . ' cterm=underline ctermfg=' . l:first_color
                                endif
    1              0.000000   else
    1              0.000004     execute 'highlight default link ' . g:qs_hi_group_primary . ' Function'
    1              0.000000   endif
                            
    1              0.000002   if exists('g:qs_second_occurrence_highlight_color')
                                " backwards compatibility mode for old highlight configuration
                                augroup quick_scope_lazy_print
                                  if has('vim_starting')
                                    " register this as a lazy print error so as not to block Vim starting
                                    autocmd CursorHold,CursorHoldI * call quick_scope#lazy_print#err('option g:qs_second_occurrence_highlight_color is deprecated!')
                                  else
                                    echohl ErrorMsg
                                    echomsg s:plugin_name . ' option g:qs_second_occurrence_highlight_color is deprecated!'
                                    echohl None
                                  endif
                                augroup END
                            
                                let l:second_color = g:qs_second_occurrence_highlight_color
                                if l:second_color =~# '#'
                                  execute 'highlight default ' . g:qs_hi_group_secondary . ' gui=underline guifg=' . l:second_color
                                else
                                  execute 'highlight default ' . g:qs_hi_group_secondary . ' cterm=underline ctermfg=' . l:second_color
                                endif
    1              0.000000   else
    1              0.000003     execute 'highlight default link ' . g:qs_hi_group_secondary . ' Define'
    1              0.000000   endif
                            
    1              0.000002   execute 'highlight default link ' . g:qs_hi_group_cursor . ' Cursor'

FUNCTION  <SNR>72_CreateMaps()
    Defined: ~/.config/nvim/autoload/plugged/nerdcommenter/plugin/nerdcommenter.vim:53
Called 18 times
Total time:   0.001259
 Self time:   0.001259

count  total (s)   self (s)
                                " Build up a map command like
                                " 'noremap <silent> <Plug>NERDCommenterComment :call nerdcommenter#Comment("n", "Comment")'
   18              0.000027     let plug = '<Plug>NERDCommenter' . a:target
   18              0.000028     let plug_start = 'noremap <silent> ' . plug . ' :call nerdcommenter#Comment("'
   18              0.000022     let plug_end = '", "' . a:target . '")<CR>'
                                " Build up a menu command like
                                " 'menu <silent> comment.Comment<Tab>\\cc <Plug>NERDCommenterComment'
   18              0.000057     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment', '&Plugin.Nerd\ &Commenter'], g:NERDMenuMode, '')
   18              0.000042     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')
   18              0.000016     if strlen(a:combo)
   13              0.000024         let leader = exists('g:mapleader') ? g:mapleader : '\'
   13              0.000029         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo
   18              0.000006     endif
   18              0.000034     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)
                                " Execute the commands built above for each requested mode.
   46              0.000085     for mode in (a:modes ==# '') ? [''] : split(a:modes, '\zs')
   28              0.000024         if strlen(a:combo)
   23              0.000185             execute mode . plug_start . mode . plug_end
   23              0.000127             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)
   23              0.000141                 execute mode . 'map <leader>' . a:combo . ' ' . plug
   23              0.000006             endif
   28              0.000006         endif
                                    " Check if the user wants the menu to be displayed.
   28              0.000019         if g:NERDMenuMode !=# 0
   28              0.000179             execute mode . menu_command
   28              0.000011         endif
   46              0.000022     endfor

FUNCTION  coc#client#create()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/client.vim:19
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000002   let client = {}
    1              0.000002   let client['command'] = a:command
    1              0.000001   let client['name'] = a:name
    1              0.000001   let client['running'] = 0
    1              0.000001   let client['async_req_id'] = 1
    1              0.000001   let client['async_callbacks'] = {}
                              " vim only
    1              0.000001   let client['channel'] = v:null
                              " neovim only
    1              0.000001   let client['chan_id'] = 0
    1              0.000004   let client['start'] = function('s:start', [], client)
    1              0.000003   let client['request'] = function('s:request', [], client)
    1              0.000002   let client['notify'] = function('s:notify', [], client)
    1              0.000003   let client['request_async'] = function('s:request_async', [], client)
    1              0.000002   let client['on_async_response'] = function('s:on_async_response', [], client)
    1              0.000001   let s:clients[a:name] = client
    1              0.000001   return client

FUNCTION  <SNR>107_GetManifestPath()
    Defined: /usr/share/nvim/runtime/plugin/rplugin.vim:7
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000001   let manifest_base = ''
                            
    1              0.000004   if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
    1              0.000000   endif
                            
    1              0.000003   let dest = stdpath('data')
    1              0.000001   if !empty(dest)
    1              0.000021     if !isdirectory(dest)
                                  call mkdir(dest, 'p', 0700)
    1              0.000000     endif
    1              0.000001     let manifest_base = dest
    1              0.000000   endif
                            
    1              0.000002   return manifest_base.'/rplugin.vim'

FUNCTION  <SNR>118_extract_fg()
    Defined: ~/.config/nvim/autoload/plugged/rainbow_parentheses.vim/autoload/rainbow_parentheses.vim:89
Called 227 times
Total time:   0.001371
 Self time:   0.001371

count  total (s)   self (s)
  227              0.000516   let cterm = matchstr(a:line, 'ctermfg=\zs\S*\ze')
  227              0.000626   let gui   = matchstr(a:line, 'guifg=\zs\S*\ze')
  227              0.000179   return [cterm, gui]

FUNCTION  <SNR>118_regions()
    Defined: ~/.config/nvim/autoload/plugged/rainbow_parentheses.vim/autoload/rainbow_parentheses.vim:204
Called 1 time
Total time:   0.000924
 Self time:   0.000924

count  total (s)   self (s)
    1              0.000006   let pairs = get(g:, 'rainbow#pairs', [['(',')']])
   17              0.000010   for level in range(1, a:max)
   16              0.000020     let cmd = 'syntax region rainbowParens%d matchgroup=rainbowParensShell%d start=/%s/ end=/%s/ contains=%s'
   16              0.000139     let children = extend(['TOP'], map(range(level, a:max), '"rainbowParens".v:val'))
   64              0.000034     for pair in pairs
   48              0.000175       let [open, close] = map(copy(pair), 'escape(v:val, "[]/")')
   48              0.000453       execute printf(cmd, level, level, open, close, join(children, ','))
   64              0.000023     endfor
   17              0.000005   endfor

FUNCTION  signature#mark#GetList()
    Defined: ~/.config/nvim/autoload/plugged/vim-signature/autoload/signature/mark.vim:281
Called 2 times
Total time:   0.000920
 Self time:   0.000920

count  total (s)   self (s)
                              " Arguments: mode    = 'used'     : Returns list of [ [used marks, line no., buf no.] ]
                              "                      'free'     : Returns list of [ free marks ]
                              "            scope   = 'buf_curr' : Limits scope to current buffer i.e used/free marks in current buffer
                              "                      'buf_all'  : Set scope to all buffers i.e used/free marks from all buffers
                              "            [type]  = 'global'   : Return only global marks
                            
    2              0.000004   let l:marks_list = []
    2              0.000005   let l:line_tot = line('$')
    2              0.000004   let l:buf_curr = bufnr('%')
    2              0.000003   let l:type     = (a:0 ? a:1 : "")
                            
                              " Respect order specified in g:SignatureIncludeMarks
  106              0.000096   for i in split(b:SignatureIncludeMarks, '\zs')
  104              0.000122     if (i =~# "[A-Z]")
   52              0.000094       let [ l:buf, l:line, l:col, l:off ] = getpos( "'" . i )
   52              0.000072       let l:marks_list = add(l:marks_list, [i, l:line, l:buf])
   52              0.000035     elseif (l:type !=? "global")
   52              0.000100       let l:marks_list = add(l:marks_list, [i, line("'" .i), l:buf_curr])
  104              0.000023     endif
  106              0.000027   endfor
                            
    2              0.000002   if (a:mode ==? 'used')
    1              0.000001     if (a:scope ==? 'buf_curr')
    1              0.000048       call filter( l:marks_list, '(v:val[2] == l:buf_curr) && (v:val[1] > 0)' )
                                else
                                  call filter( l:marks_list, 'v:val[1] > 0' )
    1              0.000000     endif
    1              0.000000   else
    1              0.000001     if (a:scope ==? 'buf_all')
                                  call filter( l:marks_list, 'v:val[1] == 0' )
    1              0.000000     else
    1              0.000037       call filter( l:marks_list, '(v:val[1] == 0) || (v:val[2] != l:buf_curr)' )
    1              0.000000     endif
    1              0.000020     call map( l:marks_list, 'v:val[0]' )
    2              0.000001   endif
                            
    2              0.000002   return l:marks_list

FUNCTION  <SNR>74_ExpandMap()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:596
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000001   let map = a:map
    1              0.000007   let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
    1              0.000008   let map = substitute(map, '\(<Plug>([^)]*)\)', '\=maparg(submatch(1), "i")', 'g')
    1              0.000001   return map

FUNCTION  coc#rpc#started()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/rpc.vim:28
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return !empty(s:client)

FUNCTION  plug#()
    Defined: ~/.config/nvim/autoload/plug.vim:709
Called 38 times
Total time:   0.002841
 Self time:   0.000999

count  total (s)   self (s)
   38              0.000027   if a:0 > 1
                                return s:err('Invalid number of arguments (1..2)')
   38              0.000012   endif
                            
   38              0.000014   try
   38   0.000263   0.000108     let repo = s:trim(a:repo)
   38   0.000490   0.000087     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec
   38   0.000457   0.000170     let name = get(opts, 'as', s:plug_fnamemodify(repo, ':t:s?\.git$??'))
   38   0.001203   0.000205     let spec = extend(s:infer_properties(name, repo), opts)
   38              0.000047     if !has_key(g:plugs, name)
   38              0.000053       call add(g:plugs_order, name)
   38              0.000011     endif
   38              0.000048     let g:plugs[name] = spec
   38              0.000067     let s:loaded[name] = get(s:loaded, name, 0)
                              catch
                                return s:err(repo . ' ' . v:exception)
   38              0.000015   endtry

FUNCTION  plug#end()
    Defined: ~/.config/nvim/autoload/plug.vim:342
Called 1 time
Total time:   0.033932
 Self time:   0.005181

count  total (s)   self (s)
    1              0.000001   if !exists('g:plugs')
                                return s:err('plug#end() called without calling plug#begin() first')
    1              0.000000   endif
                            
    1              0.000001   if exists('#PlugLOD')
                                augroup PlugLOD
                                  autocmd!
                                augroup END
                                augroup! PlugLOD
    1              0.000000   endif
    1              0.000002   let lod = { 'ft': {}, 'map': {}, 'cmd': {} }
                            
    1              0.000001   if exists('g:did_load_filetypes')
                                filetype off
    1              0.000000   endif
   39              0.000016   for name in g:plugs_order
   38              0.000035     if !has_key(g:plugs, name)
                                  continue
   38              0.000008     endif
   38              0.000031     let plug = g:plugs[name]
   38   0.000640   0.000193     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')
   36              0.000030       let s:loaded[name] = 1
   36              0.000013       continue
    2              0.000001     endif
                            
    2              0.000002     if has_key(plug, 'on')
    2              0.000005       let s:triggers[name] = { 'map': [], 'cmd': [] }
    3   0.000012   0.000008       for cmd in s:to_a(plug.on)
    1              0.000003         if cmd =~? '^<Plug>.\+'
                                      if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))
                                        call s:assoc(lod.map, cmd, name)
                                      endif
                                      call add(s:triggers[name].map, cmd)
    1              0.000003         elseif cmd =~# '^[A-Z]'
    1              0.000004           let cmd = substitute(cmd, '!*$', '', '')
    1              0.000002           if exists(':'.cmd) != 2
    1   0.000008   0.000004             call s:assoc(lod.cmd, cmd, name)
    1              0.000000           endif
    1              0.000002           call add(s:triggers[name].cmd, cmd)
                                    else
                                      call s:err('Invalid `on` option: '.cmd. '. Should start with an uppercase letter or `<Plug>`.')
    1              0.000000         endif
    3              0.000001       endfor
    2              0.000001     endif
                            
    2              0.000002     if has_key(plug, 'for')
                                  let types = s:to_a(plug.for)
                                  if !empty(types)
                                    augroup filetypedetect
                                    call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')
                                    augroup END
                                  endif
                                  for type in types
                                    call s:assoc(lod.ft, type, name)
                                  endfor
    2              0.000001     endif
    3              0.000002   endfor
                            
    2              0.000004   for [cmd, names] in items(lod.cmd)
    1              0.000013     execute printf( 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)', cmd, string(cmd), string(names))
    2              0.000001   endfor
                            
    1              0.000001   for [map, names] in items(lod.map)
                                for [mode, map_prefix, key_prefix] in [['i', '<C-\><C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]
                                  execute printf( '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>', mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)
                                endfor
    1              0.000000   endfor
                            
    1              0.000001   for [ft, names] in items(lod.ft)
                                augroup PlugLOD
                                  execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)', ft, string(ft), string(names))
                                augroup END
    1              0.000000   endfor
                            
    1   0.002747   0.000008   call s:reorg_rtp()
    1   0.029497   0.004633   filetype plugin indent on
    1              0.000005   if has('vim_starting')
    1              0.000003     if has('syntax') && !exists('g:syntax_on')
    1   0.000722   0.000029       syntax enable
    1              0.000000     end
                              else
                                call s:reload_plugins()
    1              0.000000   endif

FUNCTION  <SNR>68_start()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/client.vim:39
Called 1 time
Total time:   0.000775
 Self time:   0.000775

count  total (s)   self (s)
    1              0.000001   if self.running | return | endif
    1              0.000011   if !isdirectory(getcwd())
                                echohl Error | echon '[coc.nvim] Current cwd is not a valid directory.' | echohl None
                                return
    1              0.000000   endif
    1              0.000004   let timeout = string(get(g:, 'coc_channel_timeout', 30))
    1              0.000003   let disable_warning = string(get(g:, 'coc_disable_startup_warning', 0))
    1              0.000007   let tmpdir = fnamemodify(tempname(), ':p:h')
    1              0.000001   if s:is_vim
                                let options = { 'in_mode': 'json', 'out_mode': 'json', 'err_mode': 'nl', 'err_cb': {channel, message -> s:on_stderr(self.name, split(message, "\n"))}, 'exit_cb': {channel, code -> s:on_exit(self.name, code)}, 'env': { 'NODE_NO_WARNINGS': '1', 'VIM_NODE_RPC': '1', 'COC_NVIM': '1', 'COC_CHANNEL_TIMEOUT': timeout, 'TMPDIR': tmpdir, }}
                                if has("patch-8.1.350")
                                  let options['noblock'] = 1
                                endif
                                let job = job_start(self.command, options)
                                let status = job_status(job)
                                if status !=# 'run'
                                  let self.running = 0
                                  echohl Error | echom 'Failed to start '.self.name.' service' | echohl None
                                  return
                                endif
                                let self['running'] = 1
                                let self['channel'] = job_getchannel(job)
    1              0.000000   else
    1              0.000001     let original = {}
    1              0.000008     let opts = { 'rpc': 1, 'on_stderr': {channel, msgs -> s:on_stderr(self.name, msgs)}, 'on_exit': {channel, code -> s:on_exit(self.name, code)}, }
    1              0.000002     if has('nvim-0.5.0')
                                  " could use env option
    1              0.000003       let opts['env'] = { 'NODE_NO_WARNINGS': '1', 'COC_CHANNEL_TIMEOUT': timeout, 'TMPDIR': tmpdir }
                                else
                                  let original = { 'NODE_NO_WARNINGS': getenv('NODE_NO_WARNINGS'), 'TMPDIR': getenv('TMPDIR'), }
                                  if exists('*setenv')
                                    call setenv('NODE_NO_WARNINGS', '1')
                                    call setenv('COC_CHANNEL_TIMEOUT', timeout)
                                    call setenv('TMPDIR', tmpdir)
                                  else
                                    let $NODE_NO_WARNINGS = 1
                                    let $TMPDIR = tmpdir
                                  endif
    1              0.000000     endif
    1              0.000684     let chan_id = jobstart(self.command, opts)
    1              0.000005     if !empty(original)
                                  if exists('*setenv')
                                    for key in keys(original)
                                      call setenv(key, original[key])
                                    endfor
                                  else
                                    let $TMPDIR = original['TMPDIR']
                                  endif
    1              0.000000     endif
    1              0.000001     if chan_id <= 0
                                  echohl Error | echom 'Failed to start '.self.name.' service' | echohl None
                                  return
    1              0.000000     endif
    1              0.000002     let self['chan_id'] = chan_id
    1              0.000001     let self['running'] = 1
    1              0.000000   endif

FUNCTION  <SNR>74_sortByLength()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:467
Called 17 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
   17              0.000024   return len(a:i2[0])-len(a:i1[0])

FUNCTION  sneak#init()
    Defined: ~/.config/nvim/autoload/plugged/vim-sneak/plugin/sneak.vim:27
Called 1 time
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    1              0.000002   unlockvar g:sneak#opt
                              "options                                 v-- for backwards-compatibility
    1              0.000023   let g:sneak#opt = { 'f_reset' : get(g:, 'sneak#nextprev_f', get(g:, 'sneak#f_reset', 1)) ,'t_reset'      : get(g:, 'sneak#nextprev_t', get(g:, 'sneak#t_reset', 1)) ,'s_next'       : get(g:, 'sneak#s_next', 0) ,'absolute_dir' : get(g:, 'sneak#absolute_dir', 0) ,'use_ic_scs'   : get(g:, 'sneak#use_ic_scs', 0) ,'map_netrw'    : get(g:, 'sneak#map_netrw', 1) ,'label'        : get(g:, 'sneak#label', get(g:, 'sneak#streak', 0)) && (v:version >= 703) && has("conceal") ,'label_esc'    : get(g:, 'sneak#label_esc', get(g:, 'sneak#streak_esc', "\<space>")) ,'prompt'       : get(g:, 'sneak#prompt', '>') }
                            
    3              0.000018   for k in ['f', 't'] "if user mapped f/t to Sneak, then disable f/t reset.
    2              0.000029     if maparg(k, 'n') =~# 'Sneak'
                                  let g:sneak#opt[k.'_reset'] = 0
    2              0.000001     endif
    3              0.000002   endfor
    1              0.000002   lockvar g:sneak#opt

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   0.033932   0.005181  plug#end()
    1   0.008298   0.000500  rainbow_parentheses#activate()
    1   0.006874   0.002359  <SNR>118_extract_colors()
   38   0.002841   0.000999  plug#()
    6   0.002829             <SNR>82_motion_map_helper()
    1   0.002826   0.000655  signature#sign#Refresh()
    1   0.002738   0.002340  <SNR>5_reorg_rtp()
    1   0.002193             <SNR>118_uniq()
    1   0.001785   0.000479  <SNR>65_Hi()
    1   0.001751   0.000267  coc#rpc#start_server()
  227   0.001371             <SNR>118_extract_fg()
    1   0.001306             <SNR>65_AddAnsiGroups()
   18   0.001259             <SNR>72_CreateMaps()
   38   0.000998   0.000704  <SNR>5_infer_properties()
    1   0.000987   0.000127  AutoPairsTryInit()
   52   0.000925   0.000824  signature#sign#Remove()
    1   0.000924             <SNR>118_regions()
    2   0.000920             signature#mark#GetList()
    1   0.000842   0.000591  AutoPairsInit()
    1   0.000835             <SNR>7_process_rtp()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    1   0.033932   0.005181  plug#end()
    6              0.002829  <SNR>82_motion_map_helper()
    1   0.006874   0.002359  <SNR>118_extract_colors()
    1   0.002738   0.002340  <SNR>5_reorg_rtp()
    1              0.002193  <SNR>118_uniq()
  227              0.001371  <SNR>118_extract_fg()
    1              0.001306  <SNR>65_AddAnsiGroups()
   18              0.001259  <SNR>72_CreateMaps()
   38   0.002841   0.000999  plug#()
    1              0.000924  <SNR>118_regions()
    2              0.000920  signature#mark#GetList()
    1              0.000835  <SNR>7_process_rtp()
   52   0.000925   0.000824  signature#sign#Remove()
    1              0.000775  <SNR>68_start()
   38   0.000998   0.000704  <SNR>5_infer_properties()
    1   0.002826   0.000655  signature#sign#Refresh()
    1   0.000842   0.000591  AutoPairsInit()
    1              0.000522  <SNR>82_default_mapping()
    1   0.008298   0.000500  rainbow_parentheses#activate()
    1   0.001785   0.000479  <SNR>65_Hi()

